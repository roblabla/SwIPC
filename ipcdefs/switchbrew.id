interface nn::account::IAccountServiceForAdministrator is acc:su {
	[0] GetUserCount() -> i32;
	[1] GetUserExistence(nn::account::Uid) -> bool;
	[2] ListAllUsers() -> array<nn::account::Uid,10>;
	[3] ListOpenUsers() -> array<nn::account::Uid,10>;
	[4] GetLastOpenedUser() -> nn::account::Uid;
	[5] GetProfile(nn::account::Uid) -> object<nn::account::profile::IProfile>;
	[6] GetProfileDigest(nn::account::Uid) -> nn::account::ProfileDigest;
	[50] IsUserRegistrationRequestPermitted(u64, pid) -> bool;
	[51] TrySelectUserWithoutInteraction(bool) -> nn::account::Uid;
	@version(5.0.0+)
	[60] ListOpenContextStoredUsers();
	[100] GetUserRegistrationNotifier() -> object<nn::account::detail::INotifier>;
	[101] GetUserStateChangeNotifier() -> object<nn::account::detail::INotifier>;
	[102] GetBaasAccountManagerForSystemService(nn::account::Uid) -> object<nn::account::baas::IManagerForSystemService>;
	[103] GetBaasUserAvailabilityChangeNotifier() -> object<nn::account::detail::INotifier>;
	[104] GetProfileUpdateNotifier() -> object<nn::account::detail::INotifier>;
	@version(4.0.0+)
	[105] CheckNetworkServiceAvailabilityAsync();
	[110] StoreSaveDataThumbnail(nn::account::Uid, nn::ApplicationId, buffer<unknown,5,0>);
	[111] ClearSaveDataThumbnail(nn::account::Uid, nn::ApplicationId);
	[112] LoadSaveDataThumbnail(nn::account::Uid, nn::ApplicationId) -> (u32, buffer<unknown,6,0>);
	[113] GetSaveDataThumbnailExistence();
	[190] GetUserLastOpenedApplication(nn::account::Uid) -> (u32, nn::ApplicationId);
	@version(5.0.0+)
	[191] ActivateOpenContextHolder();
	[200] BeginUserRegistration() -> nn::account::Uid;
	[201] CompleteUserRegistration(nn::account::Uid);
	[202] CancelUserRegistration(nn::account::Uid);
	[203] DeleteUser(nn::account::Uid);
	[204] SetUserPosition(i32, nn::account::Uid);
	[205] GetProfileEditor(nn::account::Uid) -> object<nn::account::profile::IProfileEditor>;
	[206] CompleteUserRegistrationForcibly(nn::account::Uid);
	[210] CreateFloatingRegistrationRequest(u32, KObject) -> object<nn::account::baas::IFloatingRegistrationRequest>;
	[230] AuthenticateServiceAsync() -> object<nn::account::detail::IAsyncContext>;
	[250] GetBaasAccountAdministrator(nn::account::Uid) -> object<nn::account::baas::IAdministrator>;
	[290] ProxyProcedureForGuestLoginWithNintendoAccount(nn::account::detail::Uuid) -> object<nn::account::nas::IOAuthProcedureForExternalNsa>;
	[291] ProxyProcedureForFloatingRegistrationWithNintendoAccount(nn::account::detail::Uuid) -> object<nn::account::nas::IOAuthProcedureForExternalNsa>;
	[299] SuspendBackgroundDaemon() -> object<nn::account::detail::ISessionObject>;
	[997] DebugInvalidateTokenCacheForUser(nn::account::Uid);
	[998] DebugSetUserStateClose(nn::account::Uid);
	[999] DebugSetUserStateOpen(nn::account::Uid);
}

interface nn::account::IAccountServiceForApplication is acc:u0 {
	[0] GetUserCount() -> i32;
	[1] GetUserExistence(nn::account::Uid) -> bool;
	[2] ListAllUsers() -> array<nn::account::Uid,10>;
	[3] ListOpenUsers() -> array<nn::account::Uid,10>;
	[4] GetLastOpenedUser() -> nn::account::Uid;
	[5] GetProfile(nn::account::Uid) -> object<nn::account::profile::IProfile>;
	[6] GetProfileDigest(nn::account::Uid) -> nn::account::ProfileDigest;
	[50] IsUserRegistrationRequestPermitted(u64, pid) -> bool;
	[51] TrySelectUserWithoutInteraction(bool) -> nn::account::Uid;
	@version(5.0.0+)
	[60] ListOpenContextStoredUsers();
	[100] InitializeApplicationInfo(u64, pid);
	[101] GetBaasAccountManagerForApplication(nn::account::Uid) -> object<nn::account::baas::IManagerForApplication>;
	[102] AuthenticateApplicationAsync() -> object<nn::account::detail::IAsyncContext>;
	@version(4.0.0+)
	[103] CheckNetworkServiceAvailabilityAsync();
	[110] StoreSaveDataThumbnail(nn::account::Uid, buffer<unknown,5,0>);
	[111] ClearSaveDataThumbnail(nn::account::Uid);
	[120] CreateGuestLoginRequest(u32, KObject) -> object<nn::account::baas::IGuestLoginRequest>;
	@version(5.0.0+)
	[130] LoadOpenContext();
}

interface nn::account::IAccountServiceForSystemService is acc:u1 {
	[0] GetUserCount() -> i32;
	[1] GetUserExistence(nn::account::Uid) -> bool;
	[2] ListAllUsers() -> array<nn::account::Uid,10>;
	[3] ListOpenUsers() -> array<nn::account::Uid,10>;
	[4] GetLastOpenedUser() -> nn::account::Uid;
	[5] GetProfile(nn::account::Uid) -> object<nn::account::profile::IProfile>;
	[6] GetProfileDigest(nn::account::Uid) -> nn::account::ProfileDigest;
	[50] IsUserRegistrationRequestPermitted(u64, pid) -> bool;
	[51] TrySelectUserWithoutInteraction(bool) -> nn::account::Uid;
	@version(5.0.0+)
	[60] ListOpenContextStoredUsers();
	[100] GetUserRegistrationNotifier() -> object<nn::account::detail::INotifier>;
	[101] GetUserStateChangeNotifier() -> object<nn::account::detail::INotifier>;
	[102] GetBaasAccountManagerForSystemService(nn::account::Uid) -> object<nn::account::baas::IManagerForSystemService>;
	[103] GetBaasUserAvailabilityChangeNotifier() -> object<nn::account::detail::INotifier>;
	[104] GetProfileUpdateNotifier() -> object<nn::account::detail::INotifier>;
	@version(4.0.0+)
	[105] CheckNetworkServiceAvailabilityAsync();
	[110] StoreSaveDataThumbnail(nn::account::Uid, nn::ApplicationId, buffer<unknown,5,0>);
	[111] ClearSaveDataThumbnail(nn::account::Uid, nn::ApplicationId);
	[112] LoadSaveDataThumbnail(nn::account::Uid, nn::ApplicationId) -> (u32, buffer<unknown,6,0>);
	@version(5.0.0+)
	[113] GetSaveDataThumbnailExistence();
	[190] GetUserLastOpenedApplication(nn::account::Uid) -> (u32, nn::ApplicationId);
	@version(5.0.0+)
	[191] ActivateOpenContextHolder();
	[997] DebugInvalidateTokenCacheForUser(nn::account::Uid);
	[998] DebugSetUserStateClose(nn::account::Uid);
	[999] DebugSetUserStateOpen(nn::account::Uid);
}

interface nn::account::IBaasAccessTokenAccessor is acc:aa {
	[0] EnsureCacheAsync(nn::account::Uid) -> object<nn::account::detail::IAsyncContext>;
	[1] LoadCache(nn::account::Uid) -> (u32, buffer<unknown,6,0>);
	[2] GetDeviceAccountId(nn::account::Uid) -> u64;
	[50] RegisterNotificationTokenAsync(nn::npns::NotificationToken, nn::account::Uid) -> object<nn::account::detail::IAsyncContext>;
	[51] UnregisterNotificationTokenAsync(nn::account::Uid) -> object<nn::account::detail::IAsyncContext>;
}

interface nn::account::baas::IAdministrator {
	[0] CheckAvailability();
	[1] GetAccountId() -> nn::account::NetworkServiceAccountId;
	[2] EnsureIdTokenCacheAsync() -> object<nn::account::detail::IAsyncContext>;
	[3] LoadIdTokenCache() -> (u32, buffer<unknown,6,0>);
	[100] SetSystemProgramIdentification(u64, pid, buffer<nn::account::SystemProgramIdentification,25,16>);
	@version(4.0.0+)
	[110] GetServiceEntryRequirementCache();
	@version(4.0.0+)
	[111] InvalidateServiceEntryRequirementCache();
	@version(4.0.0+)
	[112] InvalidateTokenCache();
	[120] GetNintendoAccountId() -> nn::account::NintendoAccountId;
	[130] GetNintendoAccountUserResourceCache() -> (nn::account::NintendoAccountId, buffer<nn::account::nas::NasUserBase,26,591>, buffer<unknown,6,0>);
	[131] RefreshNintendoAccountUserResourceCacheAsync() -> object<nn::account::detail::IAsyncContext>;
	[132] RefreshNintendoAccountUserResourceCacheAsyncIfSecondsElapsed(u32) -> (bool, object<nn::account::detail::IAsyncContext>);
	@version(5.0.0+)
	[140] GetNetworkServiceLicenseCache();
	@version(5.0.0+)
	[141] RefreshNetworkServiceLicenseCacheAsync();
	@version(5.0.0+)
	[142] RefreshNetworkServiceLicenseCacheAsyncIfSecondsElapsed();
	[150] CreateAuthorizationRequest(u32, KObject, buffer<nn::account::nas::NasClientInfo,25,264>, buffer<nn::account::NintendoAccountAuthorizationRequestParameters,25,512>) -> object<nn::account::nas::IAuthorizationRequest>;
	[200] IsRegistered() -> bool;
	[201] RegisterAsync() -> object<nn::account::detail::IAsyncContext>;
	[202] UnregisterAsync() -> object<nn::account::detail::IAsyncContext>;
	[203] DeleteRegistrationInfoLocally();
	[220] SynchronizeProfileAsync() -> object<nn::account::detail::IAsyncContext>;
	[221] UploadProfileAsync() -> object<nn::account::detail::IAsyncContext>;
	[222] SynchronizeProfileAsyncIfSecondsElapsed(u32) -> (bool, object<nn::account::detail::IAsyncContext>);
	[250] IsLinkedWithNintendoAccount() -> bool;
	[251] CreateProcedureToLinkWithNintendoAccount() -> object<nn::account::nas::IOAuthProcedureForNintendoAccountLinkage>;
	[252] ResumeProcedureToLinkWithNintendoAccount(nn::account::detail::Uuid) -> object<nn::account::nas::IOAuthProcedureForNintendoAccountLinkage>;
	[255] CreateProcedureToUpdateLinkageStateOfNintendoAccount() -> object<nn::account::http::IOAuthProcedure>;
	[256] ResumeProcedureToUpdateLinkageStateOfNintendoAccount(nn::account::detail::Uuid) -> object<nn::account::http::IOAuthProcedure>;
	[260] CreateProcedureToLinkNnidWithNintendoAccount() -> object<nn::account::http::IOAuthProcedure>;
	[261] ResumeProcedureToLinkNnidWithNintendoAccount(nn::account::detail::Uuid) -> object<nn::account::http::IOAuthProcedure>;
	[280] ProxyProcedureToAcquireApplicationAuthorizationForNintendoAccount(nn::account::detail::Uuid) -> object<nn::account::http::IOAuthProcedure>;
	[997] DebugUnlinkNintendoAccountAsync() -> object<nn::account::detail::IAsyncContext>;
	[998] DebugSetAvailabilityErrorDetail(u32);
}

interface nn::account::baas::IFloatingRegistrationRequest {
	[0] GetSessionId() -> nn::account::detail::Uuid;
	[12] GetAccountId() -> nn::account::NetworkServiceAccountId;
	[13] GetLinkedNintendoAccountId() -> nn::account::NintendoAccountId;
	[14] GetNickname() -> array<i8,10>;
	[15] GetProfileImage() -> (u32, buffer<unknown,6,0>);
	[21] LoadIdTokenCache() -> (u32, buffer<unknown,6,0>);
	@version(1.0.0-3.0.2)
	[100] RegisterAsync() -> (nn::account::Uid, object<nn::account::detail::IAsyncContext>);
	@version(1.0.0-3.0.2)
	[101] RegisterWithUidAsync(nn::account::Uid) -> object<nn::account::detail::IAsyncContext>;
	@version(4.0.0+)
	[102] RegisterNetworkServiceAccountAsync();
	@version(4.0.0+)
	[103] RegisterNetworkServiceAccountWithUidAsync();
	[110] SetSystemProgramIdentification(u64, pid, buffer<nn::account::SystemProgramIdentification,25,16>);
	[111] EnsureIdTokenCacheAsync() -> object<nn::account::detail::IAsyncContext>;
}

interface nn::account::baas::IGuestLoginRequest {
	[0] GetSessionId() -> nn::account::detail::Uuid;
	[12] GetAccountId() -> nn::account::NetworkServiceAccountId;
	[13] GetLinkedNintendoAccountId() -> nn::account::NintendoAccountId;
	[14] GetNickname() -> array<i8,10>;
	[15] GetProfileImage() -> (u32, buffer<unknown,6,0>);
	[21] LoadIdTokenCache() -> (u32, buffer<unknown,6,0>);
}

interface nn::account::baas::IManagerForApplication {
	[0] CheckAvailability();
	[1] GetAccountId() -> nn::account::NetworkServiceAccountId;
	[2] EnsureIdTokenCacheAsync() -> object<nn::account::detail::IAsyncContext>;
	[3] LoadIdTokenCache() -> (u32, buffer<unknown,6,0>);
	[130] GetNintendoAccountUserResourceCacheForApplication() -> (nn::account::NintendoAccountId, buffer<nn::account::nas::NasUserBaseForApplication,26,104>, buffer<unknown,6,0>);
	[150] CreateAuthorizationRequest(u32, KObject, buffer<nn::account::NintendoAccountAuthorizationRequestParameters,25,512>) -> object<nn::account::nas::IAuthorizationRequest>;
	@version(5.0.0+)
	[160] StoreOpenContext();
}

interface nn::account::baas::IManagerForSystemService {
	[0] CheckAvailability();
	[1] GetAccountId() -> nn::account::NetworkServiceAccountId;
	[2] EnsureIdTokenCacheAsync() -> object<nn::account::detail::IAsyncContext>;
	[3] LoadIdTokenCache() -> (u32, buffer<unknown,6,0>);
	[100] SetSystemProgramIdentification(u64, pid, buffer<nn::account::SystemProgramIdentification,25,16>);
	@version(4.0.0+)
	[110] GetServiceEntryRequirementCache();
	@version(4.0.0+)
	[111] InvalidateServiceEntryRequirementCache();
	@version(4.0.0+)
	[112] InvalidateTokenCache();
	[120] GetNintendoAccountId() -> nn::account::NintendoAccountId;
	[130] GetNintendoAccountUserResourceCache() -> (nn::account::NintendoAccountId, buffer<nn::account::nas::NasUserBase,26,591>, buffer<unknown,6,0>);
	[131] RefreshNintendoAccountUserResourceCacheAsync() -> object<nn::account::detail::IAsyncContext>;
	[132] RefreshNintendoAccountUserResourceCacheAsyncIfSecondsElapsed(u32) -> (bool, object<nn::account::detail::IAsyncContext>);
	@version(5.0.0+)
	[140] GetNetworkServiceLicenseCache();
	@version(5.0.0+)
	[141] RefreshNetworkServiceLicenseCacheAsync();
	@version(5.0.0+)
	[142] RefreshNetworkServiceLicenseCacheAsyncIfSecondsElapsed();
	[150] CreateAuthorizationRequest(u32, KObject, buffer<nn::account::nas::NasClientInfo,25,264>, buffer<nn::account::NintendoAccountAuthorizationRequestParameters,25,512>) -> object<nn::account::nas::IAuthorizationRequest>;
}

interface nn::account::detail::IAsyncContext {
	[0] GetSystemEvent() -> KObject;
	[1] Cancel();
	[2] HasDone() -> bool;
	[3] GetResult();
}

interface nn::account::detail::INotifier {
	[0] GetSystemEvent() -> KObject;
}

interface nn::account::detail::ISessionObject {
	[999] Dummy();
}

interface nn::account::http::IOAuthProcedure {
	[0] PrepareAsync() -> object<nn::account::detail::IAsyncContext>;
	[1] GetRequest() -> (buffer<nn::account::RequestUrl,26,4096>, buffer<nn::account::CallbackUri,26,256>);
	[2] ApplyResponse(array<i8,9>);
	[3] ApplyResponseAsync(array<i8,9>) -> object<nn::account::detail::IAsyncContext>;
	[10] Suspend() -> nn::account::detail::Uuid;
}

interface nn::account::nas::IAuthorizationRequest {
	[0] GetSessionId() -> nn::account::detail::Uuid;
	[10] InvokeWithoutInteractionAsync() -> object<nn::account::detail::IAsyncContext>;
	[19] IsAuthorized() -> bool;
	[20] GetAuthorizationCode() -> (u32, buffer<unknown,6,0>);
	[21] GetIdToken() -> (u32, buffer<unknown,6,0>);
	[22] GetState() -> buffer<nn::account::nas::State,26,128>;
}

interface nn::account::nas::IOAuthProcedureForExternalNsa {
	[0] PrepareAsync() -> object<nn::account::detail::IAsyncContext>;
	[1] GetRequest() -> (buffer<nn::account::RequestUrl,26,4096>, buffer<nn::account::CallbackUri,26,256>);
	[2] ApplyResponse(array<i8,9>);
	[3] ApplyResponseAsync(array<i8,9>) -> object<nn::account::detail::IAsyncContext>;
	[10] Suspend() -> nn::account::detail::Uuid;
	[100] GetAccountId() -> nn::account::NetworkServiceAccountId;
	[101] GetLinkedNintendoAccountId() -> nn::account::NintendoAccountId;
	[102] GetNickname() -> array<i8,10>;
	[103] GetProfileImage() -> (u32, buffer<unknown,6,0>);
}

interface nn::account::nas::IOAuthProcedureForNintendoAccountLinkage {
	[0] PrepareAsync() -> object<nn::account::detail::IAsyncContext>;
	[1] GetRequest() -> (buffer<nn::account::RequestUrl,26,4096>, buffer<nn::account::CallbackUri,26,256>);
	[2] ApplyResponse(array<i8,9>);
	[3] ApplyResponseAsync(array<i8,9>) -> object<nn::account::detail::IAsyncContext>;
	[10] Suspend() -> nn::account::detail::Uuid;
	[100] GetRequestWithTheme(i32) -> (buffer<nn::account::RequestUrl,26,4096>, buffer<nn::account::CallbackUri,26,256>);
	[101] IsNetworkServiceAccountReplaced() -> bool;
	[199] GetUrlForIntroductionOfExtraMembership() -> buffer<nn::account::RequestUrl,26,4096>;
}

interface nn::account::profile::IProfile {
	# Takes an output type-0x1A buffer for [\#UserData](http://switchbrew.org/index.php?title=Account services#UserData "wikilink"), returns an output [\#ProfileBase](http://switchbrew.org/index.php?title=Account services#ProfileBase "wikilink").
	# 
	[0] Get() -> (nn::account::profile::ProfileBase, buffer<nn::account::profile::UserData,26,128>);
	# No input, returns an output [\#ProfileBase](http://switchbrew.org/index.php?title=Account services#ProfileBase "wikilink").
	# 
	[1] GetBase() -> nn::account::profile::ProfileBase;
	# No input, returns an output u32 for the size of the image buffer.
	# 
	[10] GetImageSize() -> u32;
	# Takes an output type-0x6 buffer, returns the same output u32 as [\#GetImageSize](#nn::account::profile::IProfile(10) "wikilink").
	# 
	# The output buffer contains the JPEG profile image icon. This is valid for both Miis and character icons.
	# 
	[11] LoadImage() -> (u32, buffer<unknown,6,0>);
}

interface nn::account::profile::IProfileEditor {
	# Takes an output type-0x1A buffer for [\#UserData](http://switchbrew.org/index.php?title=Account services#UserData "wikilink"), returns an output [\#ProfileBase](http://switchbrew.org/index.php?title=Account services#ProfileBase "wikilink").
	# 
	[0] Get() -> (nn::account::profile::ProfileBase, buffer<nn::account::profile::UserData,26,128>);
	# No input, returns an output [\#ProfileBase](http://switchbrew.org/index.php?title=Account services#ProfileBase "wikilink").
	# 
	[1] GetBase() -> nn::account::profile::ProfileBase;
	# No input, returns an output u32 for the size of the image buffer.
	# 
	[10] GetImageSize() -> u32;
	# Takes an output type-0x6 buffer, returns the same output u32 as [\#GetImageSize](#nn::account::profile::IProfile(10) "wikilink").
	# 
	# The output buffer contains the JPEG profile image icon. This is valid for both Miis and character icons.
	# 
	[11] LoadImage() -> (u32, buffer<unknown,6,0>);
	# Takes a [\#ProfileBase](http://switchbrew.org/index.php?title=Account services#ProfileBase "wikilink") and an input type-0x19 buffer for [\#UserData](http://switchbrew.org/index.php?title=Account services#UserData "wikilink").
	# 
	[100] Store(nn::account::profile::ProfileBase, buffer<nn::account::profile::UserData,25,128>);
	# Takes a [\#ProfileBase](http://switchbrew.org/index.php?title=Account services#ProfileBase "wikilink"), an input type-0x19 buffer for [\#UserData](http://switchbrew.org/index.php?title=Account services#UserData "wikilink"), and an input type-0x5 buffer.
	# 
	[101] StoreWithImage(nn::account::profile::ProfileBase, buffer<nn::account::profile::UserData,25,128>, buffer<unknown,5,0>);
}

interface nn::ahid::IServerSession is ahid:cd {
	@undocumented
	[0] Unknown0();
	@undocumented
	[1] Unknown1();
	@undocumented
	[2] Unknown2();
	@undocumented
	[3] Unknown3();
}

interface nn::ahid::hdr::ISession is ahid:hdr {
	@undocumented
	[0] Unknown0();
	@undocumented
	[1] Unknown1();
	@undocumented
	[2] Unknown2();
	@undocumented
	[3] Unknown3();
	@undocumented
	[4] Unknown4();
}

interface nn::am::service::IAllSystemAppletProxiesService is appletAE {
	[100] OpenSystemAppletProxy(u64, pid, KObject) -> object<nn::am::service::ISystemAppletProxy>;
	@version(1.0.0-2.3.0)
	[200] OpenLibraryAppletProxy(u64, pid, KObject) -> object<nn::am::service::ILibraryAppletProxy>;
	# Returns an [\#ILibraryAppletProxy](http://switchbrew.org/index.php?title=AM services#ILibraryAppletProxy "wikilink").
	# 
	# Takes a [reserved](http://switchbrew.org/index.php?title=IPC_Marshalling "wikilink") input u64(official user-processes use hard-coded value 0), a PID,a process copy-handle(cur-proc handle alias), and an 0x80-byte type-0x15 input buffer **AppletAttribute**.
	# 
	# Official user-processes use the same retry loop with this as the other Open\*Proxy commands.
	# 
	@version(3.0.0+)
	[201] OpenLibraryAppletProxy(u64, pid, KObject, buffer<nn::am::AppletAttribute,21,128>) -> object<nn::am::service::ILibraryAppletProxy>;
	[300] OpenOverlayAppletProxy(u64, pid, KObject) -> object<nn::am::service::IOverlayAppletProxy>;
	[350] OpenSystemApplicationProxy(u64, pid, KObject) -> object<nn::am::service::IApplicationProxy>;
	[400] CreateSelfLibraryAppletCreatorForDevelop(u64, pid) -> object<nn::am::service::ILibraryAppletCreator>;
}

interface nn::am::service::IApplicationProxyService is appletOE {
	# Returns an [\#IApplicationProxy](http://switchbrew.org/index.php?title=AM services#IApplicationProxy "wikilink"). See [\#appletAE](http://switchbrew.org/index.php?title=AM services#appletAE "wikilink").
	# 
	# Takes a [reserved](http://switchbrew.org/index.php?title=IPC_Marshalling "wikilink") input u64(official user-processes use hard-coded value 0), a PID, and a process copy-handle(cur-proc handle alias).
	# 
	# On failure, official user-processes will retry using this command in a loop while the retval is 0x19280, with svcSleepThread(10000000) being called first.
	# 
	[0] OpenApplicationProxy(u64, pid, KObject) -> object<nn::am::service::IApplicationProxy>;
}

interface nn::aocsrv::detail::IAddOnContentManager is aoc:u {
	[0] CountAddOnContentByApplicationId(nn::ncm::ApplicationId) -> i32;
	[1] ListAddOnContentByApplicationId(i32, i32, nn::ncm::ApplicationId) -> (i32, array<i32,6>);
	[2] CountAddOnContent(u64, pid) -> i32;
	[3] ListAddOnContent(i32, i32, u64, pid) -> (i32, array<i32,6>);
	[4] GetAddOnContentBaseIdByApplicationId(nn::ncm::ApplicationId) -> u64;
	[5] GetAddOnContentBaseId(u64, pid) -> u64;
	[6] PrepareAddOnContentByApplicationId(i32, nn::ncm::ApplicationId);
	[7] PrepareAddOnContent(i32, u64, pid);
	@version(4.0.0+)
	[8] GetAddOnContentListChangedEvent();
}

interface nn::apm::IManager is apm {
	[0] OpenSession() -> object<nn::apm::ISession>;
	[1] GetPerformanceMode() -> nn::apm::PerformanceMode;
}

interface nn::apm::IManagerPrivileged is apm:p {
	[0] OpenSession() -> object<nn::apm::ISession>;
}

interface nn::apm::ISession {
	[0] SetPerformanceConfiguration(nn::apm::PerformanceMode, nn::apm::PerformanceConfiguration);
	[1] GetPerformanceConfiguration(nn::apm::PerformanceMode) -> nn::apm::PerformanceConfiguration;
}

interface nn::apm::ISystemManager is apm:sys {
	[0] RequestPerformanceMode(nn::apm::PerformanceMode);
	[1] GetPerformanceEvent(nn::apm::EventTarget) -> KObject;
	[2] GetThrottlingState() -> nn::apm::ThrottlingState;
	[3] GetLastThrottlingState() -> nn::apm::ThrottlingState;
	[4] ClearLastThrottlingState();
	@version(5.0.0+)
	[5] LoadAndApplySettings();
}

interface nn::arp::detail::IReader is arp:r {
	@undocumented
	[0] GetApplicationLaunchProperty();
	@undocumented
	[1] GetApplicationLaunchPropertyWithApplicationId();
	@undocumented
	[2] GetApplicationControlProperty();
	@undocumented
	[3] GetApplicationControlPropertyWithApplicationId();
}

interface nn::arp::detail::IRegistrar {
	[0] Issue(u64);
	[1] SetApplicationLaunchProperty(u128);
	@undocumented
	[2] SetApplicationControlProperty();
}

interface nn::arp::detail::IWriter is arp:w {
	[0] AcquireRegistrar() -> object<IUnknown>;
	[1] DeleteProperties(u64);
}

interface nn::audio::detail::IAudioDebugManager is auddebug {
	[0] Unknown0(u32, u64, KObject);
	[1] Unknown1();
	[2] Unknown2();
	[3] Unknown3();
}

interface nn::audio::detail::IAudioDevice {
	[0] ListAudioDeviceName() -> (u32, buffer<unknown,6,0>);
	[1] SetAudioDeviceOutputVolume(u32, buffer<unknown,5,0>);
	[2] GetAudioDeviceOutputVolume(buffer<unknown,5,0>) -> u32;
	[3] GetActiveAudioDeviceName() -> buffer<unknown,6,0>;
	[4] QueryAudioDeviceSystemEvent() -> KObject;
	[5] GetActiveChannelCount() -> u32;
	@version(3.0.0+)
	[6] ListAudioDeviceNameAuto() -> (u32, buffer<unknown,34,0>);
	@version(3.0.0+)
	[7] SetAudioDeviceOutputVolumeAuto(u32, buffer<unknown,33,0>);
	@version(3.0.0+)
	[8] GetAudioDeviceOutputVolumeAuto(buffer<unknown,33,0>) -> u32;
	@version(3.0.0+)
	[10] GetActiveAudioDeviceNameAuto() -> buffer<unknown,34,0>;
	@version(3.0.0+)
	[11] QueryAudioDeviceInputEvent() -> KObject;
	@version(3.0.0+)
	[12] QueryAudioDeviceOutputEvent() -> KObject;
}

interface nn::audio::detail::IAudioIn {
	# Returns an u32 **AudioInState** (0x00=Started, 0x01=Stopped).
	# 
	[0] GetAudioInState() -> u32;
	[1] StartAudioIn();
	[2] StopAudioIn();
	[3] AppendAudioInBuffer(u64, buffer<unknown,5,0>);
	[4] RegisterBufferEvent() -> KObject;
	[5] GetReleasedAudioInBuffer() -> (u32, buffer<unknown,6,0>);
	[6] ContainsAudioInBuffer(u64) -> u8;
	@version(3.0.0+)
	[7] AppendAudioInBufferWithUserEvent(u64, KObject, buffer<unknown,5,0>);
	@version(3.0.0+)
	[8] AppendAudioInBufferAuto(u64, buffer<unknown,33,0>);
	@version(3.0.0+)
	[9] GetReleasedAudioInBufferAuto() -> (u32, buffer<unknown,34,0>);
	@version(3.0.0+)
	[10] AppendAudioInBufferWithUserEventAuto(u64, KObject, buffer<unknown,33,0>);
	@version(4.0.0+)
	[11] GetAudioInBufferCount();
	@version(4.0.0+)
	[12] SetAudioInDeviceGain();
	@version(4.0.0+)
	[13] GetAudioInDeviceGain();
}

interface nn::audio::detail::IAudioInManager is audin:u {
	[0] ListAudioIns() -> (u32, buffer<unknown,6,0>);
	[1] OpenAudioIn(u64, u64, pid, KObject, buffer<unknown,5,0>) -> (u128, object<IUnknown>, buffer<unknown,6,0>);
	@version(3.0.0+)
	[2] Unknown2() -> (u32, buffer<unknown,34,0>);
	@version(3.0.0+)
	[3] OpenAudioInAuto(u64, u64, pid, KObject, buffer<unknown,33,0>) -> (u128, object<IUnknown>, buffer<unknown,34,0>);
	@version(3.0.0+)
	[4] ListAudioInsAuto() -> (u32, buffer<unknown,34,0>);
}

interface nn::audio::detail::IAudioInManagerForApplet is audin:a {
	[0] RequestSuspendAudioIns(u64, u64) -> KObject;
	[1] RequestResumeAudioIns(u64, u64) -> KObject;
	[2] GetAudioInsProcessMasterVolume(u64) -> u32;
	[3] SetAudioInsProcessMasterVolume(u32, u64, u64);
}

interface nn::audio::detail::IAudioOut {
	# Returns an u32 **AudioOutState** (0x00=Started, 0x01=Stopped).
	# 
	[0] GetAudioOutState() -> u32;
	# Starts audio playback using data from appended buffers.
	# 
	[1] StartAudioOut();
	# Stops audio playback. This waits for audio playback to finish before returning.
	# 
	[2] StopAudioOut();
	# Takes a type-5 input buffer for sample data and a u64 which acts as a tag for the supplied buffer (official apps use the buffer's address).
	# 
	# The format of the input buffer is as follows:
	# 
	# | Offset | Size | Description                                           |
	# |--------|------|-------------------------------------------------------|
	# | 0x00   | 8    | Pointer to next buffer (unused)                       |
	# | 0x08   | 8    | Pointer to sample buffer                              |
	# | 0x10   | 8    | Capacity of sample buffer                             |
	# | 0x18   | 8    | Size of data in the sample buffer                     |
	# | 0x20   | 8    | Offset of data in the sample buffer (unused/ignored?) |
	# 
	[3] AppendAudioOutBuffer(u64, buffer<unknown,5,0>);
	# Returns an event handle that is signalled when a buffer is released.
	# 
	[4] RegisterBufferEvent() -> KObject;
	# Takes a type-6 output buffer which will be filled with the identifiers from [\#AppendAudioOutBuffer](#nn::audio::detail::IAudioOut(3) "wikilink") of audio buffers that have been released. Returns an u32 **ReleasedBuffersCount**.
	# 
	[5] GetReleasedAudioOutBuffer() -> (u32, buffer<unknown,6,0>);
	# Takes an u64 **tag** for the desired buffer. Returns 1 if the buffer was appended and not yet released.
	# 
	[6] ContainsAudioOutBuffer(u64) -> u8;
	# Same as [\#AppendAudioOutBuffer](#nn::audio::detail::IAudioOut(3) "wikilink") but takes a type-0x21 buffer instead.
	# 
	@version(3.0.0+)
	[7] AppendAudioOutBufferAuto(u64, buffer<unknown,33,0>);
	# Same as [\#GetReleasedAudioOutBuffer](#nn::audio::detail::IAudioOut(5) "wikilink") but takes a type-0x22 buffer instead.
	# 
	@version(3.0.0+)
	[8] GetReleasedAudioOutBufferAuto() -> (u32, buffer<unknown,34,0>);
	@version(4.0.0+)
	[9] GetAudioOutBufferCount();
	@version(4.0.0+)
	[10] GetAudioOutPlayedSampleCount();
	@version(4.0.0+)
	[11] FlushAudioOutBuffers();
}

interface nn::audio::detail::IAudioOutManager is audout:u {
	# Takes a type-6 output buffer. Populates the output buffer with the available audio output devices' names and returns an u32 with the number of device names written.
	# 
	[0] ListAudioOuts() -> (u32, buffer<unknown,6,0>);
	# Takes a type-5 input buffer (**DeviceNameIn**), a type-6 output buffer (**DeviceNameOut**), two u32s **SampleRate** (must be 48000) and **ChannelCount** (only the higher u16 is used), one u64 **ClientPID**, a PID and a copy-handle. Returns an [\#IAudioOut](#nn::audio::detail::IAudioOut "wikilink") object and four u32s: the sample rate, channel count, [PCM format](http://switchbrew.org/index.php?title=Audio services#PCM_format "wikilink"), and the initial AudioOutState.
	# 
	[1] OpenAudioOut(u64, u64, pid, KObject, buffer<unknown,5,0>) -> (u128, object<IUnknown>, buffer<unknown,6,0>);
	# Same as [\#ListAudioOuts](#nn::audio::detail::IAudioOutManager(0) "wikilink"), but takes a type-0x22 output buffer instead.
	# 
	@version(3.0.0+)
	[2] ListAudioOutsAuto() -> (u32, buffer<unknown,34,0>);
	# Same as [\#OpenAudioOut](#nn::audio::detail::IAudioOutManager(1) "wikilink"), but takes a type-0x21 input buffer instead.
	# 
	@version(3.0.0+)
	[3] OpenAudioOutAuto(u64, u64, pid, KObject, buffer<unknown,33,0>) -> (u128, object<IUnknown>, buffer<unknown,34,0>);
}

interface nn::audio::detail::IAudioOutManagerForApplet is audout:a {
	[0] RequestSuspendAudioOuts(u64, u64) -> KObject;
	[1] RequestResumeAudioOuts(u64, u64) -> KObject;
	[2] GetAudioOutsProcessMasterVolume(u64) -> u32;
	[3] SetAudioOutsProcessMasterVolume(u32, u64, u64);
	@version(4.0.0+)
	[4] GetAudioOutsProcessRecordVolume();
	@version(4.0.0+)
	[5] SetAudioOutsProcessRecordVolume();
}

interface nn::audio::detail::IAudioOutManagerForDebugger is audout:d {
	# Takes an u64 [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services#AppletResourceUserId "wikilink").
	# 
	[0] RequestSuspendForDebug(u64);
	# Takes an u64 [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services#AppletResourceUserId "wikilink").
	# 
	[1] RequestResumeForDebug(u64);
}

interface nn::audio::detail::IAudioRenderer {
	# Returns the Sample Rate. (u32)
	# 
	[0] GetAudioRendererSampleRate() -> u32;
	# Returns the Sample Count. (u32)
	# 
	[1] GetAudioRendererSampleCount() -> u32;
	# Returns the number of Mix Buffers. (u32)
	# 
	[2] GetAudioRendererMixBufferCount() -> u32;
	# Returns an AudioRenderState, 0x00=Started 0x01=Stopped (u32)
	# 
	[3] GetAudioRendererState() -> u32;
	[4] RequestUpdateAudioRenderer(buffer<unknown,5,0>) -> (buffer<unknown,6,0>, buffer<unknown,6,0>);
	[5] StartAudioRenderer();
	[6] StopAudioRenderer();
	[7] QuerySystemEvent() -> KObject;
	# Takes a upper limit of the rendering time in percent. (u32)
	# 
	[8] SetAudioRendererRenderingTimeLimit(u32);
	# Returns the upper limit of the rendering time in percent. (u32)
	# 
	[9] GetAudioRendererRenderingTimeLimit() -> u32;
	@version(3.0.0+)
	[10] RequestUpdateAudioRendererAuto(buffer<unknown,33,0>) -> (buffer<unknown,34,0>, buffer<unknown,34,0>);
	@version(3.0.0+)
	[11] ExecuteAudioRendererRendering();
}

interface nn::audio::detail::IAudioRendererManager is audren:u {
	[0] OpenAudioRenderer(bytes<52>, u64, u64, pid, KObject, KObject) -> object<IUnknown>;
	[1] GetAudioRendererWorkBufferSize(bytes<52>) -> u64;
	[2] GetAudioDeviceService(u64) -> object<IUnknown>;
	@version(3.0.0+)
	[3] OpenAudioRendererAuto(bytes<52>, u64, u64, u64, pid, KObject) -> object<IUnknown>;
	@version(4.0.0+)
	[4] GetAudioDeviceServiceWithRevisionInfo();
}

interface nn::audio::detail::IAudioRendererManagerForApplet is audren:a {
	[0] RequestSuspendAudioRenderers(u64, u64) -> KObject;
	[1] RequestResumeAudioRenderers(u64, u64) -> KObject;
	[2] GetAudioRenderersProcessMasterVolume(u64) -> u32;
	[3] SetAudioRenderersProcessMasterVolume(u32, u64, u64);
	[4] RegisterAppletResourceUserId(u64);
	[5] UnregisterAppletResourceUserId(u64);
	@version(4.0.0+)
	[6] GetAudioRenderersProcessRecordVolume();
	@version(4.0.0+)
	[7] SetAudioRenderersProcessRecordVolume();
}

interface nn::audio::detail::ICodecController is codecctl {
	# Takes no input.
	# 
	[0] InitializeCodecController();
	# Takes no input.
	# 
	[1] FinalizeCodecController();
	# Takes no input.
	# 
	[2] SleepCodecController();
	# Takes no input.
	# 
	[3] WakeCodecController();
	# Takes an u32 **Volume**.
	# 
	[4] SetCodecVolume();
	# Returns an u32 **VolumeMax**.
	# 
	[5] GetCodecVolumeMax();
	# Returns an u32 **VolumeMin**.
	# 
	[6] GetCodecVolumeMin();
	# Takes an u32 **Target**.
	# 
	[7] SetCodecActiveTarget();
	# Returns an u32 **Target**.
	# 
	[8] GetCodecActiveTarget();
	# Returns an event handle.
	# 
	[9] BindCodecHeadphoneMicJackInterrupt();
	# Returns a bool.
	# 
	[10] IsCodecHeadphoneMicJackInserted();
	# Takes no input.
	# 
	[11] ClearCodecHeadphoneMicJackInterrupt();
	# Returns a bool.
	# 
	[12] IsCodecDeviceRequested();
}

interface nn::audio::detail::IFinalOutputRecorder {
	[0] GetFinalOutputRecorderState() -> u32;
	[1] StartFinalOutputRecorder();
	[2] StopFinalOutputRecorder();
	[3] AppendFinalOutputRecorderBuffer(u64, buffer<unknown,5,0>);
	[4] RegisterBufferEvent() -> KObject;
	[5] GetReleasedFinalOutputRecorderBuffer() -> (u32, u64, buffer<unknown,6,0>);
	[6] ContainsFinalOutputRecorderBuffer(u64) -> u8;
	[7] Unknown7(u64) -> u64;
	@version(3.0.0+)
	[8] AppendFinalOutputRecorderBufferAuto(u64, buffer<unknown,33,0>);
	@version(3.0.0+)
	[9] GetReleasedFinalOutputRecorderBufferAuto() -> (u32, u64, buffer<unknown,34,0>);
}

interface nn::audio::detail::IFinalOutputRecorderManager is audrec:u {
	[0] OpenFinalOutputRecorder(u64, u64, KObject) -> (u128, object<IUnknown>);
}

interface nn::audio::detail::IFinalOutputRecorderManagerForApplet is audrec:a {
	[0] RequestSuspendFinalOutputRecorders(u64, u64) -> KObject;
	[1] RequestResumeFinalOutputRecorders(u64, u64) -> KObject;
}

interface nn::audioctrl::detail::IAudioController is audctl {
	[0] GetTargetVolume(u32) -> u32;
	[1] SetTargetVolume(u32, u32);
	[2] GetTargetVolumeMin() -> u32;
	[3] GetTargetVolumeMax() -> u32;
	@undocumented
	[4] IsTargetMute();
	[5] SetTargetMute(u8, u32);
	@undocumented
	[6] IsTargetConnected();
	@undocumented
	[7] SetDefaultTarget();
	[8] GetDefaultTarget() -> u32;
	[9] GetAudioOutputMode(u32) -> u32;
	[10] SetAudioOutputMode(u32, u32);
	[11] SetForceMutePolicy(u32);
	[12] GetForceMutePolicy() -> u32;
	[13] GetOutputModeSetting(u32) -> u32;
	[14] SetOutputModeSetting(u32, u32);
	[15] SetOutputTarget(u32);
	[16] SetInputTargetForceEnabled(u8);
	@version(3.0.0+)
	[17] SetHeadphoneOutputLevelMode(u32);
	@version(3.0.0+)
	[18] GetHeadphoneOutputLevelMode() -> u32;
	@version(3.0.0+)
	[19] AcquireAudioVolumeUpdateEventForPlayReport() -> KObject;
	@version(3.0.0+)
	[20] AcquireAudioOutputDeviceUpdateEventForPlayReport() -> KObject;
	@version(3.0.0+)
	[21] GetAudioOutputTargetForPlayReport() -> u32;
	@version(3.0.0+)
	[22] NotifyHeadphoneVolumeWarningDisplayedEvent();
	@version(4.0.0+)
	[23] SetSystemOutputMasterVolume();
	@version(4.0.0+)
	[24] GetSystemOutputMasterVolume();
	@version(4.0.0+)
	[25] GetAudioVolumeDataForPlayReport();
	@version(4.0.0+)
	[26] UpdateHeadphoneSettings();
}

interface nn::bcat::detail::ipc::IBcatService {
	[10100] RequestSyncDeliveryCache() -> object<nn::bcat::detail::ipc::IDeliveryCacheProgressService>;
	@version(5.0.0+)
	[10101] RequestSyncDeliveryCacheWithDirectoryName();
	@version(5.0.0+)
	[10200] CancelSyncDeliveryCacheRequest();
	[20100] RequestSyncDeliveryCacheWithApplicationId(u32, nn::ApplicationId) -> object<nn::bcat::detail::ipc::IDeliveryCacheProgressService>;
	@version(5.0.0+)
	[20101] RequestSyncDeliveryCacheWithApplicationIdAndDirectoryName();
	[30100] SetPassphrase(nn::ApplicationId, array<i8,9>);
	[30200] RegisterBackgroundDeliveryTask(u32, nn::ApplicationId);
	[30201] UnregisterBackgroundDeliveryTask(nn::ApplicationId);
	[30202] BlockDeliveryTask(nn::ApplicationId);
	[30203] UnblockDeliveryTask(nn::ApplicationId);
	[90100] EnumerateBackgroundDeliveryTask() -> (i32, array<nn::bcat::TaskInfo,6>);
	[90200] GetDeliveryList(nn::ApplicationId) -> (u64, buffer<unknown,6,0>);
	[90201] ClearDeliveryCacheStorage(nn::ApplicationId);
	[90300] GetPushNotificationLog() -> (i32, array<nn::bcat::PushNotificationLog,6>);
}

interface nn::bcat::detail::ipc::IDeliveryCacheDirectoryService {
	[0] Open(nn::bcat::DirectoryName);
	[1] Read() -> (i32, array<nn::bcat::DeliveryCacheDirectoryEntry,6>);
	[2] GetCount() -> i32;
}

interface nn::bcat::detail::ipc::IDeliveryCacheFileService {
	[0] Open(nn::bcat::DirectoryName, nn::bcat::FileName);
	[1] Read(i64) -> (u64, buffer<unknown,6,0>);
	[2] GetSize() -> i64;
	[3] GetDigest() -> nn::bcat::Digest;
}

interface nn::bcat::detail::ipc::IDeliveryCacheProgressService {
	[0] GetEvent() -> KObject;
	[1] GetImpl() -> buffer<nn::bcat::detail::DeliveryCacheProgressImpl,26,512>;
}

interface nn::bcat::detail::ipc::IDeliveryCacheStorageService {
	[0] CreateFileService() -> object<nn::bcat::detail::ipc::IDeliveryCacheFileService>;
	[1] CreateDirectoryService() -> object<nn::bcat::detail::ipc::IDeliveryCacheDirectoryService>;
	[10] EnumerateDeliveryCacheDirectory() -> (i32, array<nn::bcat::DirectoryName,6>);
}

interface nn::bcat::detail::ipc::IServiceCreator is bcat:a, bcat:m, bcat:u, bcat:s {
	[0] CreateBcatService(u64, pid) -> object<nn::bcat::detail::ipc::IBcatService>;
	[1] CreateDeliveryCacheStorageService(u64, pid) -> object<nn::bcat::detail::ipc::IDeliveryCacheStorageService>;
	[2] CreateDeliveryCacheStorageServiceWithApplicationId(nn::ApplicationId) -> object<nn::bcat::detail::ipc::IDeliveryCacheStorageService>;
}

interface nn::bluetooth::IBluetoothDriver is btdrv {
	[0] Unknown0();
	[1] Init() -> KObject;
	[2] Enable();
	[3] Disable();
	[4] CleanupAndShutdown();
	@undocumented
	[5] GetAdapterProperties();
	@undocumented
	[6] GetAdapterProperty();
	@undocumented
	[7] SetAdapterProperty();
	[8] StartDiscovery();
	[9] CancelDiscovery();
	@undocumented
	[10] CreateBond();
	[11] RemoveBond(bytes<6>);
	[12] CancelBond(bytes<6>);
	@undocumented
	[13] PinReply();
	@undocumented
	[14] SspReply();
	[15] Unknown15() -> (u32, buffer<unknown,10,0>);
	@undocumented
	[16] InitInterfaces();
	[17] HidHostInterface_Connect(bytes<6>);
	[18] HidHostInterface_Disconnect(bytes<6>);
	@undocumented
	[19] HidHostInterface_SendData();
	@undocumented
	[20] HidHostInterface_SendData2();
	@undocumented
	[21] HidHostInterface_SetReport();
	@undocumented
	[22] HidHostInterface_GetReport();
	[23] HidHostInterface_WakeController(bytes<6>);
	@undocumented
	[24] HidHostInterface_AddPairedDevice();
	@undocumented
	[25] HidHostInterface_GetPairedDevice();
	[26] HidHostInterface_CleanupAndShutdown();
	[27] Unknown27() -> (u32, buffer<unknown,10,0>);
	@undocumented
	[28] ExtInterface_SetTSI();
	@undocumented
	[29] ExtInterface_SetBurstMode();
	@undocumented
	[30] ExtInterface_SetZeroRetran();
	[31] ExtInterface_SetMcMode(u8);
	[32] ExtInterface_StartLlrMode();
	[33] ExtInterface_ExitLlrMode();
	[34] ExtInterface_SetRadio(u8);
	@undocumented
	[35] ExtInterface_SetVisibility();
	[36] Unknown36() -> KObject;
	[37] Unknown37() -> (u32, buffer<unknown,10,0>);
	@undocumented
	[38] HidHostInterface_GetLatestPlr();
	[39] ExtInterface_GetPendingConnections();
	@undocumented
	[40] HidHostInterface_GetChannelMap();
	[41] SetIsBluetoothBoostEnabled(u8);
	[42] GetIsBluetoothBoostEnabled() -> u8;
	[43] SetIsBluetoothAfhEnabled(u8);
	[44] GetIsBluetoothAfhEnabled() -> u8;
}

interface nn::bpc::IBoardPowerControlManager is bpc {
	[0] ShutdownSystem();
	[1] RebootSystem();
	[2] GetWakeupReason() -> u32;
	[3] GetShutdownReason() -> u32;
	[4] GetAcOk() -> u8;
	[5] GetBoardPowerControlEvent(u32) -> KObject;
	[6] GetSleepButtonState() -> u32;
	[7] GetPowerEvent(u32) -> KObject;
	[8] Unknown8(u64) -> u32;
	[9] Unknown9(u32);
	@undocumented
	[10] Unknown10();
}

interface nn::bpc::IRtcManager is bpc:r {
	[0] GetExternalRtcValue() -> u64;
	[1] SetExternalRtcValue(u64);
	[2] ReadExternalRtcResetFlag() -> u8;
	[3] ClearExternalRtcResetFlag();
}

interface nn::bsdsocket::cfg::ServerInterface is bsdcfg {
	@undocumented
	[0] SetIfUp();
	@undocumented
	[1] SetIfUpWithEvent();
	[2] CancelIf(buffer<unknown,5,0>);
	[3] SetIfDown(u32, buffer<unknown,5,0>);
	@undocumented
	[4] GetIfState();
	[5] DhcpRenew(buffer<unknown,5,0>);
	@undocumented
	[6] AddStaticArpEntry();
	[7] RemoveArpEntry(u32);
	@undocumented
	[8] LookupArpEntry();
	@undocumented
	[9] LookupArpEntry2();
	[10] ClearArpEntries();
	[11] ClearArpEntries2(buffer<unknown,5,0>);
	[12] PrintArpEntries();
}

interface nn::btm::IBtm is btm {
	[0] Unknown0() -> u32;
	@undocumented
	[1] Unknown1();
	@undocumented
	[2] RegisterSystemEventForConnectedDeviceConditionImpl();
	@undocumented
	[3] Unknown3();
	@undocumented
	[4] Unknown4();
	@undocumented
	[5] Unknown5();
	[6] Unknown6(u32);
	[7] Unknown7(u32);
	@undocumented
	[8] RegisterSystemEventForRegisteredDeviceInfoImpl();
	@undocumented
	[9] Unknown9();
	@undocumented
	[10] Unknown10();
	[11] Unknown11(bytes<6>);
	[12] Unknown12(bytes<6>);
	[13] Unknown13(bytes<6>);
	[14] EnableRadioImpl();
	[15] DisableRadioImpl();
	[16] Unknown16(bytes<6>);
	@undocumented
	[17] Unknown17();
	@version(2.0.0+)
	@undocumented
	[18] Unknown18();
	@version(4.0.0+)
	[19] Unknown19();
	@version(4.0.0+)
	[20] Unknown20();
	@version(4.0.0+)
	[21] Unknown21();
}

interface nn::btm::IBtmDebug is btm:dbg {
	@undocumented
	[0] RegisterSystemEventForDiscoveryImpl();
	@undocumented
	[1] Unknown1();
	@undocumented
	[2] Unknown2();
	@undocumented
	[3] Unknown3();
	@undocumented
	[4] Unknown4();
	@undocumented
	[5] Unknown5();
	@undocumented
	[6] Unknown6();
	@undocumented
	[7] Unknown7();
	@undocumented
	[8] Unknown8();
}

interface nn::btm::IBtmSystem is btm:sys {
	[0] GetCoreImpl() -> object<IUnknown>;
}

interface nn::btm::IBtmSystemCore {
	[0] StartGamepadPairingImpl();
	[1] CancelGamepadPairingImpl();
	[2] ClearGamepadPairingDatabaseImpl();
	[3] GetPairedGamepadCountImpl() -> u8;
	[4] EnableRadioImpl();
	[5] DisableRadioImpl();
	[6] GetRadioOnOffImpl() -> u8;
	@version(2.0.0+)
	@undocumented
	[7] AcquireRadioEventImpl();
	@version(2.0.0+)
	@undocumented
	[8] AcquireGamepadPairingEventImpl();
	@version(2.0.0+)
	[9] IsGamepadPairingStartedImpl() -> u8;
}

interface nn::capsrv::sf::IAlbumAccessorApplicationSession {
	[2001] OpenAlbumMovieReadStream();
	[2002] CloseAlbumMovieReadStream();
	[2003] GetAlbumMovieReadStreamMovieDataSize();
	[2004] ReadMovieDataFromAlbumMovieReadStream();
	[2005] GetAlbumMovieReadStreamBrokenReason();
}

interface nn::capsrv::sf::IAlbumAccessorService is caps:a {
	@undocumented
	[0] Unknown0();
	@undocumented
	[1] Unknown1();
	@undocumented
	[2] Unknown2();
	@undocumented
	[3] Unknown3();
	@undocumented
	[4] Unknown4();
	@undocumented
	[5] Unknown5();
	@undocumented
	[6] Unknown6();
	@undocumented
	[7] Unknown7();
	@undocumented
	[8] Unknown8();
	@undocumented
	[9] Unknown9();
	@undocumented
	[10] Unknown10();
	@undocumented
	[11] Unknown11();
	@undocumented
	[12] Unknown12();
	@undocumented
	[13] Unknown13();
	@undocumented
	[14] Unknown14();
	@undocumented
	[301] Unknown301();
	[401] Unknown401() -> u8;
	@undocumented
	[501] Unknown501();
	@undocumented
	[1001] Unknown1001();
	@undocumented
	[1002] Unknown1002();
	[8001] Unknown8001(u8);
	[8002] Unknown8002(u8);
	[8011] Unknown8011(u8);
	@undocumented
	[8012] Unknown8012();
	@undocumented
	[8021] Unknown8021();
	[10011] Unknown10011(u8);
}

interface nn::capsrv::sf::IAlbumApplicationService is caps:u {
	[102] GetAlbumFileListByAruid();
	[103] DeleteAlbumFileByAruid();
	[104] GetAlbumFileSizeByAruid();
	[110] LoadAlbumScreenShotImageByAruid();
	[120] LoadAlbumScreenShotThumbnailImageByAruid();
	[60002] OpenAccessorSessionForApplication();
}

interface nn::capsrv::sf::IAlbumControlService is caps:c {
	[2001] Unknown2001(u8);
	[2002] Unknown2002(u8);
	[2011] Unknown2011(u64, u64);
	[2012] Unknown2012(u64, u64);
	[2013] Unknown2013(u64) -> u64;
	[2014] Unknown2014(u64);
	@undocumented
	[2101] Unknown2101();
	@undocumented
	[2102] Unknown2102();
	@undocumented
	[2201] Unknown2201();
	@undocumented
	[2301] Unknown2301();
}

interface nn::capsrv::sf::IScreenShotApplicationService is caps:su {
	[201] SaveScreenShot(u32, u32, nn::applet::AppletResourceUserId, pid, buffer<unknown,69,0>) -> nn::capsrv::ApplicationAlbumEntry;
	[203] SaveScreenShotEx0(nn::capsrv::detail::ScreenShotAttributeEx0, u32, nn::applet::AppletResourceUserId, pid, buffer<unknown,69,0>) -> nn::capsrv::ApplicationAlbumEntry;
}

interface nn::capsrv::sf::IScreenShotControlService is caps:sc {
	@undocumented
	[1] Unknown1();
	@undocumented
	[2] Unknown2();
	[1001] Unknown1001(u64, u64);
	[1002] Unknown1002(u64, u64, u64);
	@undocumented
	[1003] Unknown1003();
	[1011] Unknown1011(u64);
	[1012] Unknown1012(u64);
	@undocumented
	[1201] Unknown1201();
	[1202] Unknown1202();
	[1203] Unknown1203(u64) -> (u64, buffer<unknown,6,0>);
}

interface nn::capsrv::sf::IScreenShotService is caps:ss {
	@undocumented
	[201] Unknown201();
	@undocumented
	[202] Unknown202();
	@undocumented
	[203] Unknown203();
	@undocumented
	[204] Unknown204();
}

interface nn::cec::ICecManager is cec-mgr {
	@undocumented
	[0] Unknown0();
	[1] Unknown1(u32) -> u32;
	[2] Unknown2(u32);
	@undocumented
	[3] Unknown3();
	@undocumented
	[4] Unknown4();
	@undocumented
	[5] Unknown5();
	@undocumented
	[6] Unknown6();
}

interface nn::codec::detail::IHardwareOpusDecoder {
	# Takes a type-5 input buffer (**OpusDataIn**) and a type-6 output buffer (**PcmDataOut**). Decodes the Opus source data to PCM and returns two u32s **DecodedSampleCount** and **DecodedDataSize**.
	# 
	[0] DecodeInterleaved(buffer<unknown,5,0>) -> (u32, u32, buffer<unknown,6,0>);
	# Takes a type-5 input buffer (**DecoderContextIn**). Sends the unknown context data to the hardware decoder.
	# 
	[1] SetContext(buffer<unknown,5,0>);
	@version(3.0.0+)
	[2] Unknown2(buffer<unknown,5,0>) -> (u32, u32, buffer<unknown,6,0>);
	@version(3.0.0+)
	[3] Unknown3(buffer<unknown,5,0>);
	@version(4.0.0+)
	[4] Unknown4();
	@version(4.0.0+)
	[5] Unknown5();
}

interface nn::codec::detail::IHardwareOpusDecoderManager is hwopus {
	# Takes two u32s **SampleRate** and **ChannelCount** packed as an u64, an u32 **WorkBufferSize** and a TransferMemory handle for **WorkBuffer**. Returns an [\#IHardwareOpusDecoder](#nn::codec::detail::IHardwareOpusDecoder "wikilink") object. The TransferMemory is created by the user-process with permissions=0.
	# 
	[0] Initialize(u64, u32, KObject) -> object<IUnknown>;
	# Takes two u32s **SampleRate** and **ChannelCount** packed as an u64. Returns the required size for the decoder's work buffer.
	# 
	[1] GetWorkBufferSize(u64) -> u32;
	@version(3.0.0+)
	[2] InitializeMultiStream(u32, KObject, buffer<unknown,25,272>) -> object<IUnknown>;
	@version(3.0.0+)
	[3] GetWorkBufferSizeMultiStream(buffer<unknown,25,272>) -> u32;
}

interface nn::dmnt::IInterface is dmnt:- {
	[0] BreakDebugProcess();
	[1] TerminateDebugProcess();
	[2] CloseHandle();
	[3] LoadImage();
	[4] GetProcessId();
	[5] GetProcessHandle();
	[6] WaitSynchronization();
	[7] GetDebugEvent();
	[8] GetProcessModuleInfo();
	[9] GetProcessList();
	[10] GetThreadList();
	[11] GetDebugThreadContext();
	[12] ContinueDebugEvent();
	[13] ReadDebugProcessMemory();
	[14] WriteDebugProcessMemory();
	[15] SetDebugThreadContext();
	[16] GetDebugThreadParam();
	[17] InitializeThreadInfo();
	[18] SetHardwareBreakPoint();
	[19] QueryDebugProcessMemory();
	[20] GetProcessMemoryDetails();
	[21] AttachByProgramId();
	[22] AttachOnLaunch();
	[23] GetDebugMonitorProcessId();
	[25] GetJitDebugProcessList();
	[26] CreateCoreDump();
	[27] GetAllDebugThreadInfo();
	[29] TargetIO_FileOpen();
	[30] TargetIO_FileClose();
	[31] TargetIO_FileRead();
	[32] TargetIO_FileWrite();
	[33] TargetIO_FileSetAttributes();
	[34] TargetIO_FileGetInformation();
	[35] TargetIO_FileSetTime();
	[36] TargetIO_FileSetSize();
	[37] TargetIO_FileDelete();
	[38] TargetIO_FileMove();
	[39] TargetIO_DirectoryCreate();
	[40] TargetIO_DirectoryDelete();
	[41] TargetIO_DirectoryRename();
	[42] TargetIO_DirectoryGetCount();
	[43] TargetIO_DirectoryOpen();
	[44] TargetIO_DirectoryGetNext();
	[45] TargetIO_DirectoryClose();
	[46] TargetIO_GetFreeSpace();
	[47] TargetIO_GetVolumeInformation();
	[48] InitiateCoreDump();
	[49] ContinueCoreDump();
	[50] AddTTYToCoreDump();
	[51] AddImageToCoreDump();
	[52] CloseCoreDump();
}

interface nn::erpt::sf::IContext is erpt:c {
	@undocumented
	[0] SubmitContext();
	@undocumented
	[1] CreateReport();
	@version(3.0.0+)
	@undocumented
	[2] Unknown2();
	@version(3.0.0+)
	[3] Unknown3();
	@version(3.0.0+)
	[4] Unknown4();
	@version(3.0.0+)
	[5] Unknown5();
	@version(5.0.0+)
	[6] Unknown6();
}

interface nn::erpt::sf::IManager {
	@undocumented
	[0] GetReportList();
	[1] GetEvent() -> KObject;
	@version(4.0.0+)
	[2] Unknown2();
	@version(5.0.0+)
	[3] Unknown3();
	@version(5.0.0+)
	[4] Unknown4();
}

interface nn::erpt::sf::IReport {
	@undocumented
	[0] Open();
	[1] Read() -> (u32, buffer<unknown,6,0>);
	[2] SetFlags(u32);
	[3] GetFlags() -> u32;
	[4] Close();
	[5] GetSize() -> u64;
}

interface nn::erpt::sf::ISession is erpt:r {
	[0] OpenReport() -> object<IUnknown>;
	[1] OpenManager() -> object<IUnknown>;
}

interface nn::es::IETicketService is es {
	@undocumented
	[1] ImportTicket();
	[2] ImportTicketCertificateSet(buffer<unknown,5,0>);
	[3] DeleteTicket(buffer<unknown,5,0>);
	[4] DeletePersonalizedTicket(u32);
	[5] DeleteAllCommonTicket();
	[6] DeleteAllPersonalizedTicket();
	[7] DeleteAllPersonalizedTicketEx(buffer<unknown,5,0>);
	@undocumented
	[8] GetTitleKey();
	[9] CountCommonTicket() -> u32;
	[10] CountPersonalizedTicket() -> u32;
	[11] ListCommonTicket() -> (u32, buffer<unknown,6,0>);
	[12] ListPersonalizedTicket() -> (u32, buffer<unknown,6,0>);
	@undocumented
	[13] ListMissingPersonalizedTicket();
	@undocumented
	[14] GetCommonTicketSize();
	@undocumented
	[15] GetPersonalizedTicketSize();
	@undocumented
	[16] GetCommonTicketData();
	@undocumented
	[17] GetPersonalizedTicketData();
	@undocumented
	[18] OwnTicket();
	@undocumented
	[19] GetTicketInfo();
	@undocumented
	[20] ListLightTicketInfo();
	@version(2.0.0+)
	@undocumented
	[21] SignData();
	@version(4.0.0+)
	[22] GetCommonTicketAndCertificateSize();
	@version(4.0.0+)
	[23] GetCommonTicketAndCertificateData();
	@version(4.0.0+)
	[24] ImportPrepurchaseRecord();
	@version(4.0.0+)
	[25] DeletePrepurchaseRecord();
	@version(4.0.0+)
	[26] DeleteAllPrepurchaseRecord();
	@version(4.0.0+)
	[27] CountPrepurchaseRecord();
	@version(4.0.0+)
	[28] ListPrepurchaseRecord();
	@version(4.0.0+)
	[29] ListPrepurchaseRecordInfo();
	@version(5.0.0+)
	[30] Unknown30();
	@version(5.0.0+)
	[31] Unknown31();
	@version(5.0.0+)
	[32] Unknown32();
	@version(5.0.0+)
	[33] Unknown33();
	@version(5.0.0+)
	[34] Unknown34();
	@version(5.0.0+)
	[35] Unknown35();
}

interface nn::eth::sf::IEthInterface is ethc:c {
	@undocumented
	[0] Initialize();
	[1] Cancel();
	[2] GetResult();
	@undocumented
	[3] GetMediaList();
	[4] SetMediaType(u32);
	@undocumented
	[5] GetMediaType();
}

interface nn::eth::sf::IEthInterfaceGroup is ethc:i {
	[0] GetReadableHandle() -> KObject;
	[1] Cancel();
	[2] GetResult();
	@undocumented
	[3] GetInterfaceList();
	[4] GetInterfaceCount() -> u32;
}

interface nn::eupld::sf::IControl is eupld:c {
	[0] SetUrl(buffer<unknown,5,0>);
	[1] ImportCrt(buffer<unknown,5,0>);
	@undocumented
	[2] ImportPki();
	@undocumented
	[3] SetAutoUpload();
}

interface nn::eupld::sf::IRequest is eupld:r {
	[0] Initialize() -> KObject;
	[1] UploadAll();
	[2] UploadSelected(buffer<unknown,5,0>);
	[3] GetUploadStatus() -> buffer<unknown,6,0>;
	[4] CancelUpload();
	[5] GetResult();
}

interface nn::fan::detail::IManager is fan {
	[0] Unknown0(u32) -> object<IUnknown>;
	[1] Unknown1();
	[2] Unknown2();
	[3] Unknown3();
	[4] Unknown4();
	[5] Unknown5();
	[6] Unknown6();
	[7] Unknown7();
}

interface nn::fatalsrv::IPrivateService is fatal:p {
	[0] GetFatalEvent() -> KObject;
}

interface nn::fatalsrv::IService is fatal:u {
	@undocumented
	[0] ThrowFatal();
	@undocumented
	[1] ThrowFatalWithPolicy();
	# Takes an input u64 errorcode and an unknown u64(TID maybe?). It also takes a type-0x15 error buffer and a pid-descriptor. The error buffer contains a stack trace. The stack trace address count is stored at errorbuffer+0x240 and the addresses are stored at errorbuffer+0x130+i\*8 where i = 0-&gt;address count
	# 
	@undocumented
	[2] ThrowFatalWithCpuContext();
}

interface nn::fgm::sf::IDebugger is fgm:dbg {
	[0] Initialize(u64, KObject) -> KObject;
	[1] Read() -> (u32, u32, u32, buffer<unknown,6,0>);
	[2] Cancel();
}

interface nn::fgm::sf::IRequest {
	[0] Initialize(nn::fgm::Module, u64, pid) -> KObject;
	[1] Set(u32, u32);
	[2] Get() -> u32;
	[3] Cancel();
}

interface nn::fgm::sf::ISession is fgm:0, fgm, fgm:9 {
	[0] Initialize() -> object<nn::fgm::sf::IRequest>;
}

interface nn::friends::detail::ipc::IFriendService {
	[0] GetCompletionEvent() -> KObject;
	[1] Cancel();
	[10100] GetFriendListIds(i32, nn::account::Uid, nn::friends::detail::ipc::SizedFriendFilter, u64, pid) -> (i32, array<nn::account::NetworkServiceAccountId,10>);
	[10101] GetFriendList(i32, nn::account::Uid, nn::friends::detail::ipc::SizedFriendFilter, u64, pid) -> (i32, array<nn::friends::detail::FriendImpl,6>);
	[10102] UpdateFriendInfo(nn::account::Uid, u64, pid, array<nn::account::NetworkServiceAccountId,9>) -> array<nn::friends::detail::FriendImpl,6>;
	[10110] GetFriendProfileImage(nn::account::Uid, nn::account::NetworkServiceAccountId) -> (i32, buffer<unknown,6,0>);
	[10200] SendFriendRequestForApplication(nn::account::Uid, nn::account::NetworkServiceAccountId, u64, pid, buffer<nn::friends::InAppScreenName,25,72>, buffer<nn::friends::InAppScreenName,25,72>);
	[10211] AddFacedFriendRequestForApplication(nn::friends::FacedFriendRequestRegistrationKey, nn::account::Nickname, nn::account::Uid, u64, pid, buffer<unknown,5,0>, buffer<nn::friends::InAppScreenName,25,72>, buffer<nn::friends::InAppScreenName,25,72>);
	[10400] GetBlockedUserListIds(i32, nn::account::Uid) -> (i32, array<nn::account::NetworkServiceAccountId,10>);
	[10500] GetProfileList(nn::account::Uid, array<nn::account::NetworkServiceAccountId,9>) -> array<nn::friends::detail::ProfileImpl,6>;
	[10600] DeclareOpenOnlinePlaySession(nn::account::Uid);
	[10601] DeclareCloseOnlinePlaySession(nn::account::Uid);
	[10610] UpdateUserPresence(nn::account::Uid, u64, pid, buffer<nn::friends::detail::UserPresenceImpl,25,224>);
	[10700] GetPlayHistoryRegistrationKey(bool, nn::account::Uid) -> buffer<nn::friends::PlayHistoryRegistrationKey,26,64>;
	[10701] GetPlayHistoryRegistrationKeyWithNetworkServiceAccountId(bool, nn::account::NetworkServiceAccountId) -> buffer<nn::friends::PlayHistoryRegistrationKey,26,64>;
	[10702] AddPlayHistory(nn::account::Uid, u64, pid, buffer<nn::friends::PlayHistoryRegistrationKey,25,64>, buffer<nn::friends::InAppScreenName,25,72>, buffer<nn::friends::InAppScreenName,25,72>);
	[11000] GetProfileImageUrl(nn::friends::Url, i32) -> nn::friends::Url;
	[20100] GetFriendCount(nn::account::Uid, nn::friends::detail::ipc::SizedFriendFilter, u64, pid) -> i32;
	[20101] GetNewlyFriendCount(nn::account::Uid) -> i32;
	[20102] GetFriendDetailedInfo(nn::account::Uid, nn::account::NetworkServiceAccountId) -> buffer<nn::friends::detail::FriendDetailedInfoImpl,26,2048>;
	[20103] SyncFriendList(nn::account::Uid);
	[20104] RequestSyncFriendList(nn::account::Uid);
	[20110] LoadFriendSetting(nn::account::Uid, nn::account::NetworkServiceAccountId) -> buffer<nn::friends::detail::FriendSettingImpl,26,64>;
	[20200] GetReceivedFriendRequestCount(nn::account::Uid) -> (i32, i32);
	[20201] GetFriendRequestList(i32, i32, nn::account::Uid) -> (i32, array<nn::friends::detail::FriendRequestImpl,6>);
	[20300] GetFriendCandidateList(i32, nn::account::Uid) -> (i32, array<nn::friends::detail::FriendCandidateImpl,6>);
	[20301] GetNintendoNetworkIdInfo(i32, nn::account::Uid) -> (i32, buffer<nn::friends::NintendoNetworkIdUserInfo,26,56>, array<nn::friends::detail::NintendoNetworkIdFriendImpl,6>);
	@version(5.0.0+)
	[20302] GetSnsAccountLinkage();
	@version(5.0.0+)
	[20303] GetSnsAccountProfile();
	@version(5.0.0+)
	[20304] GetSnsAccountFriendList();
	[20400] GetBlockedUserList(i32, nn::account::Uid) -> (i32, array<nn::friends::detail::BlockedUserImpl,6>);
	[20401] SyncBlockedUserList(nn::account::Uid);
	[20500] GetProfileExtraList(nn::account::Uid, array<nn::account::NetworkServiceAccountId,9>) -> array<nn::friends::detail::ProfileExtraImpl,6>;
	[20501] GetRelationship(nn::account::Uid, nn::account::NetworkServiceAccountId) -> nn::friends::Relationship;
	[20600] GetUserPresenceView(nn::account::Uid) -> buffer<nn::friends::detail::UserPresenceViewImpl,26,224>;
	[20700] GetPlayHistoryList(i32, nn::account::Uid) -> (i32, array<nn::friends::detail::PlayHistoryImpl,6>);
	[20701] GetPlayHistoryStatistics(nn::account::Uid) -> nn::friends::PlayHistoryStatistics;
	[20800] LoadUserSetting(nn::account::Uid) -> buffer<nn::friends::detail::UserSettingImpl,26,2048>;
	[20801] SyncUserSetting(nn::account::Uid);
	[20900] RequestListSummaryOverlayNotification();
	[21000] GetExternalApplicationCatalog(nn::settings::LanguageCode, nn::friends::ExternalApplicationCatalogId) -> buffer<nn::friends::ExternalApplicationCatalog,26,1208>;
	[30100] DropFriendNewlyFlags(nn::account::Uid);
	[30101] DeleteFriend(nn::account::Uid, nn::account::NetworkServiceAccountId);
	[30110] DropFriendNewlyFlag(nn::account::Uid, nn::account::NetworkServiceAccountId);
	[30120] ChangeFriendFavoriteFlag(bool, nn::account::Uid, nn::account::NetworkServiceAccountId);
	[30121] ChangeFriendOnlineNotificationFlag(bool, nn::account::Uid, nn::account::NetworkServiceAccountId);
	[30200] SendFriendRequest(i32, nn::account::Uid, nn::account::NetworkServiceAccountId);
	[30201] SendFriendRequestWithApplicationInfo(i32, nn::account::Uid, nn::account::NetworkServiceAccountId, nn::friends::ApplicationInfo, buffer<nn::friends::InAppScreenName,25,72>, buffer<nn::friends::InAppScreenName,25,72>);
	[30202] CancelFriendRequest(nn::account::Uid, nn::friends::RequestId);
	[30203] AcceptFriendRequest(nn::account::Uid, nn::friends::RequestId);
	[30204] RejectFriendRequest(nn::account::Uid, nn::friends::RequestId);
	[30205] ReadFriendRequest(nn::account::Uid, nn::friends::RequestId);
	[30210] GetFacedFriendRequestRegistrationKey(nn::account::Uid) -> nn::friends::FacedFriendRequestRegistrationKey;
	[30211] AddFacedFriendRequest(nn::friends::FacedFriendRequestRegistrationKey, nn::account::Nickname, nn::account::Uid, buffer<unknown,5,0>);
	[30212] CancelFacedFriendRequest(nn::account::Uid, nn::account::NetworkServiceAccountId);
	[30213] GetFacedFriendRequestProfileImage(nn::account::Uid, nn::account::NetworkServiceAccountId) -> (i32, buffer<unknown,6,0>);
	[30214] GetFacedFriendRequestProfileImageFromPath(array<i8,9>) -> (i32, buffer<unknown,6,0>);
	[30215] SendFriendRequestWithExternalApplicationCatalogId(i32, nn::account::Uid, nn::account::NetworkServiceAccountId, nn::friends::ExternalApplicationCatalogId, buffer<nn::friends::InAppScreenName,25,72>, buffer<nn::friends::InAppScreenName,25,72>);
	[30216] ResendFacedFriendRequest(nn::account::Uid, nn::account::NetworkServiceAccountId);
	[30217] SendFriendRequestWithNintendoNetworkIdInfo(nn::friends::MiiName, nn::friends::MiiImageUrlParam, nn::friends::MiiName, nn::friends::MiiImageUrlParam, i32, nn::account::Uid, nn::account::NetworkServiceAccountId);
	@version(5.0.0+)
	[30300] GetSnsAccountLinkPageUrl();
	@version(5.0.0+)
	[30301] UnlinkSnsAccount();
	[30400] BlockUser(i32, nn::account::Uid, nn::account::NetworkServiceAccountId);
	[30401] BlockUserWithApplicationInfo(i32, nn::account::Uid, nn::account::NetworkServiceAccountId, nn::friends::ApplicationInfo, buffer<nn::friends::InAppScreenName,25,72>);
	[30402] UnblockUser(nn::account::Uid, nn::account::NetworkServiceAccountId);
	[30500] GetProfileExtraFromFriendCode(nn::friends::FriendCode, nn::account::Uid) -> buffer<nn::friends::detail::ProfileExtraImpl,26,1024>;
	[30700] DeletePlayHistory(nn::account::Uid);
	[30810] ChangePresencePermission(i32, nn::account::Uid);
	[30811] ChangeFriendRequestReception(bool, nn::account::Uid);
	[30812] ChangePlayLogPermission(i32, nn::account::Uid);
	[30820] IssueFriendCode(nn::account::Uid);
	[30830] ClearPlayLog(nn::account::Uid);
	[49900] DeleteNetworkServiceAccountCache(nn::account::Uid);
}

interface nn::friends::detail::ipc::INotificationService {
	[0] GetEvent() -> KObject;
	[1] Clear();
	[2] Pop() -> nn::friends::detail::ipc::SizedNotificationInfo;
}

interface nn::friends::detail::ipc::IServiceCreator is friend:v, friend:u, friend:m, friend:s, friend:a {
	[0] CreateFriendService() -> object<nn::friends::detail::ipc::IFriendService>;
	[1] CreateNotificationService(nn::account::Uid) -> object<nn::friends::detail::ipc::INotificationService>;
	@version(4.0.0+)
	[2] CreateDaemonSuspendSessionService();
}

interface nn::fssrv::sf::IDeviceOperator {
	[0] IsSdCardInserted() -> u8;
	[1] GetSdCardSpeedMode() -> u64;
	@version(2.0.0+)
	[2] GetSdCardCid(u64) -> buffer<unknown,6,0>;
	@version(2.0.0+)
	[3] GetSdCardUserAreaSize() -> u64;
	@version(2.0.0+)
	[4] GetSdCardProtectedAreaSize() -> u64;
	@version(2.0.0+)
	[5] GetAndClearSdCardErrorInfo(u64) -> (u128, u64, buffer<unknown,6,0>);
	[100] GetMmcCid(u64) -> buffer<unknown,6,0>;
	[101] GetMmcSpeedMode() -> u64;
	[110] EraseMmc(u32);
	[111] GetMmcPartitionSize(u32) -> u64;
	@version(2.0.0+)
	[112] GetMmcPatrolCount() -> u32;
	@version(2.0.0+)
	[113] GetAndClearMmcErrorInfo(u64) -> (u128, u64, buffer<unknown,6,0>);
	@version(2.0.0+)
	[114] GetMmcExtendedCsd(u64) -> buffer<unknown,6,0>;
	@version(4.0.0+)
	[115] SuspendMmcPatrol();
	@version(4.0.0+)
	[116] ResumeMmcPatrol();
	[200] IsGameCardInserted() -> u8;
	[201] EraseGameCard(u32, u64);
	[202] GetGameCardHandle() -> u32;
	# Returns a titleID and the title-version for it.
	# 
	# -   Output u32 with ARMS-gamecard: title-version v131162. This is the title-version for [2.1.0](http://switchbrew.org/index.php?title=2.1.0 "wikilink"), which is the sysupdate included with this gamecard. Launch-day gamecards return title-version v450.
	# -   Output u64 with ARMS-gamecard: titleID 0100000000000816.
	# 
	# [NS](http://switchbrew.org/index.php?title=NS_Services "wikilink") appears to only use this with [Content\_Manager\_services\#GetTitleIdInfo](http://switchbrew.org/index.php?title=Content_Manager_services#GetTitleIdInfo "wikilink") and [Content\_Manager\_services\#GetUpdateTitleList](http://switchbrew.org/index.php?title=Content_Manager_services#GetUpdateTitleList "wikilink") with storageid=nandsys, for checking whether a sysupdate is required.
	# 
	[203] GetGameCardUpdatePartitionInfo(u32) -> (u32, u64);
	[204] FinalizeGameCardDriver();
	[205] GetGameCardAttribute(u32) -> u8;
	[206] GetGameCardDeviceCertificate(u32, u64) -> buffer<unknown,6,0>;
	[207] GetGameCardAsicInfo(u64, u64, buffer<unknown,5,0>) -> buffer<unknown,6,0>;
	[208] GetGameCardIdSet(u64) -> buffer<unknown,6,0>;
	[209] WriteToGameCard(u64, u64) -> buffer<unknown,6,0>;
	[210] SetVerifyWriteEnalbleFlag(u8);
	[211] GetGameCardImageHash(u32, u64) -> buffer<unknown,6,0>;
	@version(2.0.0+)
	[212] GetGameCardErrorInfo(u64, u64, buffer<unknown,5,0>) -> buffer<unknown,6,0>;
	@version(2.0.0+)
	[213] EraseAndWriteParamDirectly(u64, buffer<unknown,5,0>);
	@version(2.0.0+)
	[214] ReadParamDirectly(u64) -> buffer<unknown,6,0>;
	@version(2.0.0+)
	[215] ForceEraseGameCard();
	@version(2.0.0+)
	[216] GetGameCardErrorInfo() -> u128;
	@version(2.1.0+)
	[217] GetGameCardErrorReportInfo() -> bytes<64>;
	@version(3.0.0+)
	[218] GetGameCardDeviceId(u64) -> buffer<unknown,6,0>;
	[300] SetSpeedEmulationMode(u32);
	[301] GetSpeedEmulationMode() -> u32;
	@version(5.0.0+)
	[400] SuspendSdmmcControl();
	@version(5.0.0+)
	[401] ResumeSdmmcControl();
}

interface nn::fssrv::sf::IDirectory {
	# Takes a type-0x6 output buffer. Returns an output u64(?) for the total number of read entries, this is 0 when no more entries are available.
	# 
	# The output buffer contains the read array of [\#DirectoryEntry](http://switchbrew.org/index.php?title=Filesystem services#DirectoryEntry "wikilink"). This doesn't include entries for . and ...
	# 
	[0] Read() -> (u64, buffer<unknown,6,0>);
	# Returns an u64 for the total number of readable entries.
	# 
	[1] GetEntryCount() -> u64;
}

interface nn::fssrv::sf::IEventNotifier {
	[0] GetEventHandle() -> KObject;
}

interface nn::fssrv::sf::IFile {
	[0] Read(u32, u64, u64) -> (u64, buffer<unknown,70,0>);
	[1] Write(u32, u64, u64, buffer<unknown,69,0>);
	[2] Flush();
	[3] SetSize(u64);
	[4] GetSize() -> u64;
	@version(4.0.0+)
	[5] OperateRange();
}

interface nn::fssrv::sf::IFileSystem {
	[0] CreateFile(u32, u64, buffer<unknown,25,769>);
	[1] DeleteFile(buffer<unknown,25,769>);
	[2] CreateDirectory(buffer<unknown,25,769>);
	[3] DeleteDirectory(buffer<unknown,25,769>);
	[4] DeleteDirectoryRecursively(buffer<unknown,25,769>);
	[5] RenameFile(buffer<unknown,25,769>, buffer<unknown,25,769>);
	[6] RenameDirectory(buffer<unknown,25,769>, buffer<unknown,25,769>);
	# Takes a type-0x9 input buffer for the path and returns [\#DirectoryEntryType](http://switchbrew.org/index.php?title=Filesystem services#DirectoryEntryType "wikilink") as an output u32.
	# 
	[7] GetEntryType(buffer<unknown,25,769>) -> u32;
	# Takes a type-0x19 input buffer for the path, and an u32 **mode**. **mode** controls how the file is opened, based on which bits are set:
	# 
	# -   When bit 0 is set, the file is Readable: you can use the Read operation.
	# -   When bit 1 is set, the file is Writable: you can use the Write operation.
	# -   When bit 2 is set, the file is Appendable: unless this bit is set, you will not be able to write beyond the end of a file (such writes will result in an error 0x307202)
	# 
	[8] OpenFile(u32, buffer<unknown,25,769>) -> object<IUnknown>;
	# Takes a type-0x9 input buffer for the path and an u64 **filter\_flags**. **filter\_flags** controls what type of entries are read by the [\#IDirectory](#nn::fssrv::sf::IDirectory "wikilink"): bitmask 0x1 = directories, bitmask 0x2 = files.
	# 
	[9] OpenDirectory(u32, buffer<unknown,25,769>) -> object<IUnknown>;
	# Like [3DS](http://switchbrew.org/index.php?title=https://3dbrew.org/wiki/FS:ControlArchive), this has to be used after writing to savedata for the changes to take affect.
	# 
	[10] Commit();
	# Takes a type-0x9 input buffer for the path and returns an output byte-size u64 for the total free space with this FS.
	# 
	[11] GetFreeSpaceSize(buffer<unknown,25,769>) -> u64;
	# Takes a type-0x9 input buffer for the path and returns an output byte-size u64 for the total space available with this FS(free+used).
	# 
	[12] GetTotalSpaceSize(buffer<unknown,25,769>) -> u64;
	# Takes a type-0x9 input buffer for the path and clears the contents of the directory specified in the path.
	# 
	@version(3.0.0+)
	[13] CleanDirectoryRecursively(buffer<unknown,25,769>);
	@version(3.0.0+)
	[14] GetFileTimeStampRaw(buffer<unknown,25,769>) -> bytes<32>;
	@version(4.0.0+)
	[15] QueryEntry();
}

interface nn::fssrv::sf::IFileSystemProxy is fsp-srv {
	# Takes an input [\#FileSystemType](http://switchbrew.org/index.php?title=Filesystem services#FileSystemType "wikilink") and an u64 title-id. Returns an [\#IFileSystem](#nn::fssrv::sf::IFileSystem "wikilink").
	# 
	# \[2.0.0+\] This function was removed.
	# 
	@version(1.0.0)
	[0] OpenFileSystem();
	# Takes a pid-descriptor.
	# 
	[1] SetCurrentProcess(u64, pid);
	[2] OpenDataFileSystemByCurrentProcess() -> object<IUnknown>;
	# Takes an input [\#FileSystemType](http://switchbrew.org/index.php?title=Filesystem services#FileSystemType "wikilink") and an u64 title-id. Returns an [\#IFileSystem](#nn::fssrv::sf::IFileSystem "wikilink").
	# 
	# Web-applet loads the [\#FileSystemType](http://switchbrew.org/index.php?title=Filesystem services#FileSystemType "wikilink") (which must be **ContentManual**) from u32\_table\[inparam\].
	# 
	# Note: web-applet strings refer to both this cmd and [\#OpenFileSystemWithId](#nn::fssrv::sf::IFileSystemProxy(8) "wikilink") as MountContent, but official nn\_sf\_sync symbols use OpenXX names.
	# 
	@version(2.0.0+)
	[7] OpenFileSystemWithPatch(u32, u64) -> object<IUnknown>;
	# Takes a type-0x19 input buffer, an [\#FileSystemType](http://switchbrew.org/index.php?title=Filesystem services#FileSystemType "wikilink") and an u64 title-id. Returns an [\#IFileSystem](#nn::fssrv::sf::IFileSystem "wikilink").
	# 
	# The [\#IFileSystem](#nn::fssrv::sf::IFileSystem "wikilink") must be **ContentMeta** if the NCA type is 0 (control).
	# 
	# The input buffer is the output string path from [GetApplicationContentPath](http://switchbrew.org/index.php?title=NS_Services#GetApplicationContentPath "wikilink").
	# 
	# May return errors when attempting to access NCA-paths for an update-title with a gamecard, when the gamecard isn't inserted. May return error 0x7D402 in some cases with update-titles. Non-val2 in32 values with NCA-type1 are unusable, even for normal titles.
	# 
	# The official MountApplicationPackage func uses this with in64=0 and [\#FileSystemType](http://switchbrew.org/index.php?title=Filesystem services#FileSystemType "wikilink") **ApplicationPackage**.
	# 
	# After the [\#FileSystemType](http://switchbrew.org/index.php?title=Filesystem services#FileSystemType "wikilink") specific permissions are checked, it then gets the func retval for permissions-type 0x25 and func0.
	# 
	# When [\#FileSystemType](http://switchbrew.org/index.php?title=Filesystem services#FileSystemType "wikilink") is **ContentMeta**, it uses in64=0xffffffffffffffff internally, otherwise it checks if in64 is set to 0xffffffffffffffff then throws an error if so. When the in64 used internally is not 0xffffffffffffffff, it's compared with the NCA titleID, then an error is thrown on mismatch.
	# 
	@version(2.0.0+)
	[8] OpenFileSystemWithId(u32, u64, buffer<unknown,25,769>) -> object<IUnknown>;
	@version(3.0.0+)
	[9] OpenDataFileSystemByApplicationId(u64) -> object<IUnknown>;
	# Takes a type-0x19 input buffer string and a u32 [Bis partitionID](http://switchbrew.org/index.php?title=Flash_Filesystem "wikilink"). Official user-process code sets instr\[0\] = 0 normally. Returns an [\#IFileSystem](#nn::fssrv::sf::IFileSystem "wikilink").
	# 
	# Only partitionIDs for FAT partitions are usable with this, otherwise error 0x2EE202 is returned. Seems to be about the same as [\#OpenBisStorage](#nn::fssrv::sf::IFileSystemProxy(12) "wikilink") except this mounts the partition filesystem instead of allowing direct access to the partition sectors.
	# 
	[11] OpenBisFileSystem(u32, buffer<unknown,25,769>) -> object<IUnknown>;
	# Takes a u32 partition ID, returns 0x2EE202 for partitions which do not exist, 0x320002 for partitions which cannot be opened and a valid [\#IStorage](#nn::fssrv::sf::IStorage "wikilink") handle otherwise.
	# 
	[12] OpenBisStorage(u32) -> object<IUnknown>;
	[13] InvalidateBisCache();
	[17] OpenHostFileSystem(buffer<unknown,25,769>) -> object<IUnknown>;
	[18] OpenSdCardFileSystem() -> object<IUnknown>;
	@version(2.0.0+)
	[19] FormatSdCardFileSystem();
	# Takes an input u64.
	# 
	[21] DeleteSaveDataFileSystem(u64);
	# Takes a 0x40-byte Save-struct entry, a 0x40-byte SaveCreate-struct entry, and a 0x10-byte input struct.
	# 
	# Only the first 0x5-bytes in the 0x10-byte struct are initialized: all-zero when automatically creating savedata during savecommon mount by official user-processes. In the dedicated save-creation code in official user-processes: +0 u32 = 0x40060, +4 u8 = 1.
	# 
	# Creates regular savedata.
	# 
	[22] CreateSaveDataFileSystem(bytes<64>, bytes<64>, u128);
	# Takes a 0x40-byte Save-struct entry and a 0x40-byte SaveCreate-struct entry.
	# 
	# Creates savedata in the SYSTEM [NAND](http://switchbrew.org/index.php?title=Flash_Filesystem "wikilink") partition.
	# 
	[23] CreateSaveDataFileSystemBySystemSaveDataId(bytes<64>, bytes<64>);
	[24] RegisterSaveDataFileSystemAtomicDeletion(buffer<unknown,5,0>);
	@version(2.0.0+)
	[25] DeleteSaveDataFileSystemBySaveDataSpaceId(u8, u64);
	@version(2.0.0+)
	[26] FormatSdCardDryRun();
	@version(2.0.0+)
	[27] IsExFatSupported() -> u8;
	@version(4.0.0+)
	[28] DeleteSaveDataFileSystemBySaveDataAttribute();
	# Takes two input u32s (gamecard handle, partition ID), and returns an [\#IStorage](#nn::fssrv::sf::IStorage "wikilink") for the [partition](http://switchbrew.org/index.php?title=Gamecard_Format "wikilink").
	# 
	[30] OpenGameCardStorage(u32, u32) -> object<IUnknown>;
	# Takes two input u32s, with the second u32 located at +4 in rawdata after the first u32. Returns an [\#IFileSystem](#nn::fssrv::sf::IFileSystem "wikilink").
	# 
	# Mounts a [gamecard partition](http://switchbrew.org/index.php?title=Gamecard_Partition "wikilink").
	# 
	[31] OpenGameCardFileSystem(u32, u32) -> object<IUnknown>;
	@version(3.0.0+)
	[32] ExtendSaveDataFileSystem(u8, u64, u64, u64);
	@version(5.0.0+)
	[33] DeleteCacheStorage();
	@version(5.0.0+)
	[34] GetCacheStorageSize();
	# Takes an input u8 [\#SaveDataSpaceId](http://switchbrew.org/index.php?title=Filesystem services#SaveDataSpaceId "wikilink") and a 0x40-byte Save-struct entry. Official user-process code is only known to use value 1 for the u8.
	# 
	# Returns an [\#IFileSystem](#nn::fssrv::sf::IFileSystem "wikilink").
	# 
	# Permissions aren't checked until the specified save is successfully found.
	# 
	# Only one process (specifically only one [\#IFileSystem](#nn::fssrv::sf::IFileSystem "wikilink") session) can mount a given savedata at any given time (this includes SystemSaveData).
	# 
	[51] OpenSaveDataFileSystem(u8, bytes<64>) -> object<IUnknown>;
	# Takes an input u8 [\#SaveDataSpaceId](http://switchbrew.org/index.php?title=Filesystem services#SaveDataSpaceId "wikilink") and a 0x40-byte Save-struct entry. Web-applet only uses value0 for the input u8.
	# 
	# Returns an [\#IFileSystem](#nn::fssrv::sf::IFileSystem "wikilink").
	# 
	# Mounts savedata in the SYSTEM [NAND](http://switchbrew.org/index.php?title=Flash_Filesystem "wikilink") partition.
	# 
	[52] OpenSaveDataFileSystemBySystemSaveDataId(u8, bytes<64>) -> object<IUnknown>;
	@version(2.0.0+)
	[53] OpenReadOnlySaveDataFileSystem(u8, bytes<64>) -> object<IUnknown>;
	@version(3.0.0+)
	[57] ReadSaveDataFileSystemExtraDataBySaveDataSpaceId(u8, u64) -> buffer<unknown,6,0>;
	[58] ReadSaveDataFileSystemExtraData(u64) -> buffer<unknown,6,0>;
	@version(2.0.0+)
	[59] WriteSaveDataFileSystemExtraData(u8, u64, buffer<unknown,5,0>);
	# No input, returns an output [\#ISaveDataInfoReader](#nn::fssrv::sf::ISaveDataInfoReader "wikilink").
	# 
	[60] OpenSaveDataInfoReader() -> object<IUnknown>;
	# Takes an input u8 [\#SaveDataSpaceId](http://switchbrew.org/index.php?title=Filesystem services#SaveDataSpaceId "wikilink"), returns an output [\#ISaveDataInfoReader](#nn::fssrv::sf::ISaveDataInfoReader "wikilink").
	# 
	[61] OpenSaveDataInfoReaderBySaveDataSpaceId(u8) -> object<IUnknown>;
	@version(5.0.0+)
	[62] OpenCacheStorageList();
	@version(5.0.0+)
	[64] OpenSaveDataInternalStorageFileSystem();
	@version(5.0.0+)
	[65] UpdateSaveDataMacForDebug();
	@version(5.0.0+)
	[66] WriteSaveDataFileSystemExtraData2();
	[80] OpenSaveDataMetaFile(u8, u32, bytes<64>) -> object<IUnknown>;
	@version(4.0.0+)
	[81] OpenSaveDataTransferManager();
	@version(5.0.0+)
	[82] OpenSaveDataTransferManagerVersion2();
	[100] OpenImageDirectoryFileSystem(u32) -> object<IUnknown>;
	# Takes a [\#ContentStorageId](http://switchbrew.org/index.php?title=Filesystem services#ContentStorageId "wikilink"). Invalid values return 0x2EE202.
	# 
	# Returns an [\#IFileSystem](#nn::fssrv::sf::IFileSystem "wikilink") with NCA files. The read data from these files is identical to the data read by [Content\_Manager\_services\#ReadEntryRaw](http://switchbrew.org/index.php?title=Content_Manager_services#ReadEntryRaw "wikilink").
	# 
	[110] OpenContentStorageFileSystem(u32) -> object<IUnknown>;
	[200] OpenDataStorageByCurrentProcess() -> object<IUnknown>;
	@version(3.0.0+)
	[201] OpenDataStorageByProgramId(u64) -> object<IUnknown>;
	# Takes a [\#StorageId](http://switchbrew.org/index.php?title=Filesystem services#StorageId "wikilink") and a TitleID.
	# 
	# Returns a [domain object ID](http://switchbrew.org/index.php?title=IPC_Marshalling#Domain_message "wikilink") implementing the [\#IStorage](#nn::fssrv::sf::IStorage "wikilink") interface for data archives.
	# 
	[202] OpenDataStorageByDataId(u8, u64) -> object<IUnknown>;
	[203] OpenPatchDataStorageByCurrentProcess() -> object<IUnknown>;
	# This command returns a session to a port implementing the [\#IDeviceOperator](#nn::fssrv::sf::IDeviceOperator "wikilink") interface.
	# 
	[400] OpenDeviceOperator() -> object<IUnknown>;
	# This command returns a session to a port implementing the [\#IEventNotifier](#nn::fssrv::sf::IEventNotifier "wikilink") interface.
	# 
	[500] OpenSdCardDetectionEventNotifier() -> object<IUnknown>;
	# This command returns a session to a port implementing the [\#IEventNotifier](#nn::fssrv::sf::IEventNotifier "wikilink") interface.
	# 
	[501] OpenGameCardDetectionEventNotifier() -> object<IUnknown>;
	@version(5.0.0+)
	[510] OpenSystemDataUpdateEventNotifier();
	@version(5.0.0+)
	[511] NotifySystemDataUpdateEvent();
	@version(1.0.0-3.0.2)
	[600] SetCurrentPosixTime(u64);
	[601] QuerySaveDataTotalSize(u64, u64) -> u64;
	# Takes an unknown input u64 and a type-0x6 output buffer.
	# 
	# The input u64 high-byte must be non-zero, otherwise an [error](http://switchbrew.org/index.php?title=Error_codes "wikilink") is returned(0xE02).
	# 
	[602] VerifySaveDataFileSystem(u64) -> buffer<unknown,6,0>;
	[603] CorruptSaveDataFileSystem(u64);
	[604] CreatePaddingFile(u64);
	[605] DeleteAllPaddingFiles();
	@version(2.0.0+)
	[606] GetRightsId(u8, u64) -> u128;
	@version(2.0.0+)
	[607] RegisterExternalKey(u128, u128);
	@version(2.0.0+)
	[608] UnregisterAllExternalKey();
	@version(2.0.0+)
	[609] GetRightsIdByPath(buffer<unknown,25,769>) -> u128;
	@version(3.0.0+)
	[610] GetRightsIdAndKeyGenerationByPath(buffer<unknown,25,769>) -> (u8, u128);
	@version(4.0.0+)
	[611] SetCurrentPosixTimeWithTimeDifference();
	@version(4.0.0+)
	[612] GetFreeSpaceSizeForSaveData();
	@version(4.0.0+)
	[613] VerifySaveDataFileSystemBySaveDataSpaceId();
	@version(4.0.0+)
	[614] CorruptSaveDataFileSystemBySaveDataSpaceId();
	@version(5.0.0+)
	[615] QuerySaveDataInternalStorageTotalSize();
	# Takes in the 0x10 byte SD card encryption seed, and loads it into FS-module state.
	# 
	# [NS](http://switchbrew.org/index.php?title=NS_Services "wikilink")-module reads the 0x10 bytes from SdCard:/Nintendo/Contents/private, and compares them to the first 0x10 bytes of the ns\_appman:/private (in [system savedata](http://switchbrew.org/index.php?title=Flash_Filesystem#System_Savegames "wikilink") 0x8000000000000043). If they match, NS calls this command using bytes 0x10-0x20 from ns\_appman:/private. The rest of this file (0x1F0 bytes total) is (usually/always?) all-zero.
	# 
	@version(2.0.0+)
	[620] SetSdCardEncryptionSeed(u128);
	@version(4.0.0+)
	[630] SetSdCardAccessibility();
	@version(4.0.0+)
	[631] IsSdCardAccessible();
	@version(4.0.0+)
	[640] IsSignedSystemPartitionOnSdCardValid();
	@version(5.0.0+)
	[700] OpenAccessFailureResolver();
	@version(5.0.0+)
	[701] GetAccessFailureDetectionEvent();
	@version(5.0.0+)
	[702] IsAccessFailureDetected();
	@version(5.0.0+)
	[710] ResolveAccessFailure();
	@version(5.0.0+)
	[720] AbandonAccessFailure();
	@version(2.0.0+)
	[800] GetAndClearFileSystemProxyErrorInfo() -> bytes<128>;
	[1000] SetBisRootForHost(u32, buffer<unknown,25,769>);
	[1001] SetSaveDataSize(u64, u64);
	[1002] SetSaveDataRootPath(buffer<unknown,25,769>);
	[1003] DisableAutoSaveDataCreation();
	# Takes an input u32.
	# 
	[1004] SetGlobalAccessLogMode(u32);
	# Returns an output u32.
	# 
	# GlobalAccessLogMode is normally 0.
	# 
	[1005] GetGlobalAccessLogMode() -> u32;
	# Takes a type-0x5 input buffer.
	# 
	# The input buffer is the string to output to the log. User-processes normally include a newline at the end.
	# 
	# User-processes only use this when the value previously loaded from [\#GetGlobalAccessLogMode](#nn::fssrv::sf::IFileSystemProxy(1005) "wikilink") has bit1 set.
	# 
	# When bit1 in GlobalAccessLogMode is clear, FS-module will just return 0 for OutputAccessLogToSdCard. However even with that set the log doesn't show up SD, unknown why.
	# 
	# The input buffer is written to the $FsAccessLog:/FsAccessLog.txt file, where $FsAccessLog is the SD-card mount-name. It's written to the current end of the file(appended).
	# 
	[1006] OutputAccessLogToSdCard(buffer<unknown,5,0>);
	@version(4.0.0+)
	[1007] RegisterUpdatePartition();
	@version(4.0.0+)
	[1008] OpenRegisteredUpdatePartition();
	@version(4.0.0+)
	[1009] GetAndClearMemoryReportInfo();
	@version(5.1.0+)
	[1010] Unknown1010();
	@version(4.0.0+)
	[1100] OverrideSaveDataTransferTokenSignVerificationKey();
}

interface nn::fssrv::sf::IFileSystemProxyForLoader is fsp-ldr {
	[0] OpenCodeFileSystem(u64, buffer<unknown,25,769>) -> object<IUnknown>;
	[1] IsArchivedProgram(u64) -> u8;
	@version(4.0.0+)
	[2] SetCurrentProcess();
}

interface nn::fssrv::sf::IProgramRegistry is fsp-pr {
	# Takes a storageID, a pid, a titleID, a 0x1C type-A buffer for the [ FS Access Header](http://switchbrew.org/index.php?title=NPDM#FS_Access_Header "wikilink"), and a 0x2C type-A buffer for the [ FS Access Control](http://switchbrew.org/index.php?title=NPDM#FS_Access_Control "wikilink")
	# 
	# Final FS permissions are stored as (ACI0\_perms & ACID\_perms). Will panic(svcBreak) when buffer sizes from ipc-rawdata are invalid.
	# 
	[0] RegisterProgram(u8, u64, u64, u64, u64, buffer<unknown,5,0>, buffer<unknown,5,0>);
	# Takes a pid. Removes registered FS permissions for that PID.
	# 
	[1] UnregisterProgram(u64);
	@version(4.0.0+)
	[2] SetCurrentProcess();
	# Seems to sets a global flag to inputval & 1.
	# 
	# When the flag is zero, it will set ret=0 instead of ret={error} when verifying the fixed-key [NPDM](http://switchbrew.org/index.php?title=NPDM "wikilink") ACID signature fails. This also skips verifying the [NCA Header](http://switchbrew.org/index.php?title=NCA_Format "wikilink") signature using the ACID key. Note that if verifying the fixed-key ACID signature is successful, and verifying the ACID-key NCA header signature fails, it will throw an error and abort.
	# 
	[256] SetEnabledProgramVerification(u8);
}

interface nn::fssrv::sf::ISaveDataInfoReader {
	# Takes a type-0x6 output buffer. Returns an output u64 for total output entries. This buffer contains an array of [\#SaveDataInfo](http://switchbrew.org/index.php?title=Filesystem services#SaveDataInfo "wikilink").
	# 
	# This is used to get [\#SaveDataInfo](http://switchbrew.org/index.php?title=Filesystem services#SaveDataInfo "wikilink") for all savedata on the system (or all savedata for the current [\#SaveDataSpaceId](http://switchbrew.org/index.php?title=Filesystem services#SaveDataSpaceId "wikilink")). When used multiple times, it will resume reading where it left off, until no more entries are available (in that case the out u64 is value 0).
	# 
	[0] ReadSaveDataInfo() -> (u64, buffer<unknown,6,0>);
}

interface nn::fssrv::sf::IStorage {
	[0] Read(u64, u64) -> buffer<unknown,70,0>;
	[1] Write(u64, u64, buffer<unknown,69,0>);
	[2] Flush();
	[3] SetSize(u64);
	[4] GetSize() -> u64;
	@version(4.0.0+)
	[5] OperateRange();
}

interface nn::gpio::IManager is gpio {
	# Takes a raw [\#GpioPadDescriptor](http://switchbrew.org/index.php?title=Bus services#GpioPadDescriptor "wikilink") and returns a [\#IPadSession](#nn::gpio::IPadSession "wikilink") session for it.
	# 
	[0] OpenSessionForDev(u32) -> object<IUnknown>;
	# Same thing as [\#OpenSessionForDev](#nn::gpio::IManager(0) "wikilink") except it takes a **GpioPadName** which is then converted to a [\#GpioPadDescriptor](http://switchbrew.org/index.php?title=Bus services#GpioPadDescriptor "wikilink"). Returns an [\#IPadSession](#nn::gpio::IPadSession "wikilink") session.
	# 
	[1] OpenSession(u32) -> object<IUnknown>;
	# Same as [\#OpenSession](#nn::gpio::IManager(1) "wikilink") but panics on failure.
	# 
	[2] OpenSessionForTest(u32) -> object<IUnknown>;
	[3] IsWakeEventActive(u32) -> u8;
	[4] GetWakeEventActiveFlagSet() -> u128;
	[5] SetWakeEventActiveFlagSetForDebug(u8, u32);
	[6] SetWakePinDebugMode(u8);
	# Same as [\#OpenSession](#nn::gpio::IManager(1) "wikilink") but takes a **DeviceCode** instead of a **GpioPadName**.
	# 
	@version(5.0.0+)
	[7] OpenSession2();
	@version(5.0.0+)
	[8] IsWakeEventActive2();
	@version(5.0.0+)
	[9] SetWakeEventActiveFlagSetForDebug2();
}

interface nn::gpio::IPadSession {
	[0] SetDirection(u32);
	[1] GetDirection() -> u32;
	[2] SetInterruptMode(u32);
	[3] GetInterruptMode() -> u32;
	[4] SetInterruptEnable(u8);
	[5] GetInterruptEnable() -> u8;
	[6] GetInterruptStatus() -> u32;
	[7] ClearInterruptStatus();
	[8] SetValue(u32);
	[9] GetValue() -> u32;
	[10] BindInterrupt() -> KObject;
	[11] UnbindInterrupt();
	[12] SetDebounceEnabled(u8);
	[13] GetDebounceEnabled() -> u8;
	[14] SetDebounceTime(u32);
	[15] GetDebounceTime() -> u32;
	@version(4.0.0+)
	[16] SetValueForSleepState();
}

interface nn::grcsrv::IContinuousRecorder {
	[1] Unknown1();
	[2] Unknown2();
	[10] Unknown10();
	[11] Unknown11();
	[12] Unknown12();
	[13] Unknown13();
}

interface nn::grcsrv::IGameMovieTrimmer {
	[1] BeginTrim();
	[2] EndTrim();
	[10] GetNotTrimmingEvent();
	[20] SetThumbnailRgba();
}

interface nn::grcsrv::IGrcService is grc:c {
	[1] OpenContinuousRecorder();
	[2] OpenGameMovieTrimmer();
}

interface nn::hid::IActiveVibrationDeviceList {
	# Takes an input [\#VibrationDeviceHandle](http://switchbrew.org/index.php?title=HID services#VibrationDeviceHandle "wikilink"). No output.
	# 
	[0] ActivateVibrationDevice(nn::hid::VibrationDeviceHandle);
}

interface nn::hid::IHidDebugServer is hid:dbg {
	[0] DeactivateDebugPad();
	[1] SetDebugPadAutoPilotState(nn::hid::debug::DebugPadAutoPilotState);
	[2] UnsetDebugPadAutoPilotState();
	[10] DeactivateTouchScreen();
	[11] SetTouchScreenAutoPilotState(array<nn::hid::TouchState,5>);
	[12] UnsetTouchScreenAutoPilotState();
	[20] DeactivateMouse();
	[21] SetMouseAutoPilotState(nn::hid::debug::MouseAutoPilotState);
	[22] UnsetMouseAutoPilotState();
	[30] DeactivateKeyboard();
	[31] SetKeyboardAutoPilotState(nn::hid::debug::KeyboardAutoPilotState);
	[32] UnsetKeyboardAutoPilotState();
	[50] DeactivateXpad(nn::hid::BasicXpadId);
	[51] SetXpadAutoPilotState(nn::hid::BasicXpadId, align<4,nn::hid::debug::BasicXpadAutoPilotState>);
	[52] UnsetXpadAutoPilotState(nn::hid::BasicXpadId);
	[60] DeactivateJoyXpad(nn::hid::JoyXpadId);
	[91] DeactivateGesture();
	[110] DeactivateHomeButton();
	[111] SetHomeButtonAutoPilotState(nn::hid::debug::HomeButtonAutoPilotState);
	[112] UnsetHomeButtonAutoPilotState();
	[120] DeactivateSleepButton();
	[121] SetSleepButtonAutoPilotState(nn::hid::debug::SleepButtonAutoPilotState);
	[122] UnsetSleepButtonAutoPilotState();
	[123] DeactivateInputDetector();
	[130] DeactivateCaptureButton();
	[131] SetCaptureButtonAutoPilotState(nn::hid::debug::CaptureButtonAutoPilotState);
	[132] UnsetCaptureButtonAutoPilotState();
	[133] SetShiftAccelerometerCalibrationValue(nn::hid::SixAxisSensorHandle, f32, f32, nn::applet::AppletResourceUserId, pid);
	[134] GetShiftAccelerometerCalibrationValue(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid) -> (f32, f32);
	[135] SetShiftGyroscopeCalibrationValue(nn::hid::SixAxisSensorHandle, f32, f32, nn::applet::AppletResourceUserId, pid);
	[136] GetShiftGyroscopeCalibrationValue(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid) -> (f32, f32);
	[140] DeactivateConsoleSixAxisSensor();
	@version(5.0.0+)
	[141] GetConsoleSixAxisSensorSamplingFrequency();
	@version(5.0.0+)
	[142] DeactivateSevenSixAxisSensor();
	[201] ActivateFirmwareUpdate();
	[202] DeactivateFirmwareUpdate();
	[203] StartFirmwareUpdate(nn::hid::system::UniquePadId);
	[204] GetFirmwareUpdateStage() -> (i64, i64);
	[205] GetFirmwareVersion(u32, nn::hid::system::DeviceType) -> nn::hid::system::FirmwareVersion;
	[206] GetDestinationFirmwareVersion(u32, nn::hid::system::DeviceType) -> nn::hid::system::FirmwareVersion;
	[207] DiscardFirmwareInfoCacheForRevert();
	[208] StartFirmwareUpdateForRevert(nn::hid::system::UniquePadId);
	[209] GetAvailableFirmwareVersionForRevert(nn::hid::system::UniquePadId) -> nn::hid::system::FirmwareVersion;
	@version(4.0.0+)
	[210] IsFirmwareUpdatingDevice();
	[221] UpdateControllerColor(nn::util::Unorm8x4, nn::util::Unorm8x4, nn::hid::system::UniquePadId);
	@version(4.0.0+)
	[222] ConnectUsbPadsAsync();
	@version(4.0.0+)
	[223] DisconnectUsbPadsAsync();
	@version(5.0.0+)
	[224] UpdateDesignInfo();
	@version(5.0.0+)
	[225] GetUniquePadDriverState();
	@version(5.0.0+)
	[226] GetSixAxisSensorDriverStates();
	@version(5.0.0+)
	[301] GetAbstractedPadHandles();
	@version(5.0.0+)
	[302] GetAbstractedPadState();
	@version(5.0.0+)
	[303] GetAbstractedPadsState();
	@version(5.0.0+)
	[321] SetAutoPilotVirtualPadState();
	@version(5.0.0+)
	[322] UnsetAutoPilotVirtualPadState();
	@version(5.0.0+)
	[323] UnsetAllAutoPilotVirtualPadState();
	@version(5.0.0+)
	[350] AddRegisteredDevice();
}

interface nn::hid::IHidServer is hid {
	# Takes a PID and an u64 [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"). Returns an [\#IAppletResource](http://switchbrew.org/index.php?title=HID services#IAppletResource "wikilink").
	# 
	[0] CreateAppletResource(nn::applet::AppletResourceUserId, pid) -> object<nn::hid::IAppletResource>;
	[1] ActivateDebugPad(nn::applet::AppletResourceUserId, pid);
	[11] ActivateTouchScreen(nn::applet::AppletResourceUserId, pid);
	[21] ActivateMouse(nn::applet::AppletResourceUserId, pid);
	[31] ActivateKeyboard(nn::applet::AppletResourceUserId, pid);
	[40] AcquireXpadIdEventHandle(u64) -> KObject;
	[41] ReleaseXpadIdEventHandle(u64);
	[51] ActivateXpad(nn::hid::BasicXpadId, nn::applet::AppletResourceUserId, pid);
	[55] GetXpadIds() -> (i64, array<nn::hid::BasicXpadId,10>);
	[56] ActivateJoyXpad(nn::hid::JoyXpadId);
	[58] GetJoyXpadLifoHandle(nn::hid::JoyXpadId) -> KObject;
	[59] GetJoyXpadIds() -> (i64, array<nn::hid::JoyXpadId,10>);
	[60] ActivateSixAxisSensor(nn::hid::BasicXpadId);
	[61] DeactivateSixAxisSensor(nn::hid::BasicXpadId);
	[62] GetSixAxisSensorLifoHandle(nn::hid::BasicXpadId) -> KObject;
	[63] ActivateJoySixAxisSensor(nn::hid::JoyXpadId);
	[64] DeactivateJoySixAxisSensor(nn::hid::JoyXpadId);
	[65] GetJoySixAxisSensorLifoHandle(nn::hid::JoyXpadId) -> KObject;
	[66] StartSixAxisSensor(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid);
	[67] StopSixAxisSensor(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid);
	[68] IsSixAxisSensorFusionEnabled(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid) -> bool;
	[69] EnableSixAxisSensorFusion(bool, nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid);
	[70] SetSixAxisSensorFusionParameters(nn::hid::SixAxisSensorHandle, f32, f32, nn::applet::AppletResourceUserId, pid);
	[71] GetSixAxisSensorFusionParameters(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid) -> (f32, f32);
	[72] ResetSixAxisSensorFusionParameters(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid);
	[73] SetAccelerometerParameters(nn::hid::SixAxisSensorHandle, f32, f32, nn::applet::AppletResourceUserId, pid);
	[74] GetAccelerometerParameters(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid) -> (f32, f32);
	[75] ResetAccelerometerParameters(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid);
	[76] SetAccelerometerPlayMode(nn::hid::SixAxisSensorHandle, u32, nn::applet::AppletResourceUserId, pid);
	[77] GetAccelerometerPlayMode(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid) -> u32;
	[78] ResetAccelerometerPlayMode(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid);
	[79] SetGyroscopeZeroDriftMode(nn::hid::SixAxisSensorHandle, u32, nn::applet::AppletResourceUserId, pid);
	[80] GetGyroscopeZeroDriftMode(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid) -> u32;
	[81] ResetGyroscopeZeroDriftMode(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid);
	[82] IsSixAxisSensorAtRest(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid) -> bool;
	[91] ActivateGesture(i32, nn::applet::AppletResourceUserId, pid);
	[100] SetSupportedNpadStyleSet(nn::hid::NpadStyleTag, nn::applet::AppletResourceUserId, pid);
	[101] GetSupportedNpadStyleSet(nn::applet::AppletResourceUserId, pid) -> nn::hid::NpadStyleTag;
	[102] SetSupportedNpadIdType(nn::applet::AppletResourceUserId, pid, array<u32,9>);
	[103] ActivateNpad(nn::applet::AppletResourceUserId, pid);
	[104] DeactivateNpad(nn::applet::AppletResourceUserId, pid);
	[106] AcquireNpadStyleSetUpdateEventHandle(u32, nn::applet::AppletResourceUserId, u64, pid) -> KObject;
	[107] DisconnectNpad(u32, nn::applet::AppletResourceUserId, pid);
	[108] GetPlayerLedPattern(u32) -> u64;
	@version(5.0.0+)
	[109] ActivateNpadWithRevision();
	[120] SetNpadJoyHoldType(nn::applet::AppletResourceUserId, i64, pid);
	[121] GetNpadJoyHoldType(nn::applet::AppletResourceUserId, pid) -> i64;
	# Takes a PID-descriptor, an u32, and an [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"). No output.
	# 
	[122] SetNpadJoyAssignmentModeSingleByDefault(u32, nn::applet::AppletResourceUserId, pid);
	# Takes a PID-descriptor, an u32, [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"), and s64 **NpadJoyDeviceType**. No output.
	# 
	[123] SetNpadJoyAssignmentModeSingle(u32, nn::applet::AppletResourceUserId, i64, pid);
	# Takes a PID-descriptor, an u32, and an [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"). No output.
	# 
	[124] SetNpadJoyAssignmentModeDual(u32, nn::applet::AppletResourceUserId, pid);
	# Takes a PID-descriptor, two u32s, and an [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"). No output.
	# 
	[125] MergeSingleJoyAsDualJoy(u32, u32, nn::applet::AppletResourceUserId, pid);
	[126] StartLrAssignmentMode(nn::applet::AppletResourceUserId, pid);
	[127] StopLrAssignmentMode(nn::applet::AppletResourceUserId, pid);
	[128] SetNpadHandheldActivationMode(nn::applet::AppletResourceUserId, i64, pid);
	# Takes a PID and an u64 [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"). Returns an output u64. Official user-processes panic if the output u64 is not 0-2.
	# 
	[129] GetNpadHandheldActivationMode(nn::applet::AppletResourceUserId, pid) -> i64;
	[130] SwapNpadAssignment(u32, u32, nn::applet::AppletResourceUserId, pid);
	[131] IsUnintendedHomeButtonInputProtectionEnabled(u32, nn::applet::AppletResourceUserId, pid) -> bool;
	[132] EnableUnintendedHomeButtonInputProtection(bool, u32, nn::applet::AppletResourceUserId, pid);
	@version(5.0.0+)
	[133] SetNpadJoyAssignmentModeSingleWithDestination();
	# Takes a [\#VibrationDeviceHandle](http://switchbrew.org/index.php?title=HID services#VibrationDeviceHandle "wikilink"). Returns an output [\#VibrationDeviceInfo](http://switchbrew.org/index.php?title=HID services#VibrationDeviceInfo "wikilink").
	# 
	[200] GetVibrationDeviceInfo(nn::hid::VibrationDeviceHandle) -> nn::hid::VibrationDeviceInfoForIpc;
	# Takes a PID-descriptor, a [\#VibrationDeviceHandle](http://switchbrew.org/index.php?title=HID services#VibrationDeviceHandle "wikilink"), a [\#VibrationValue](http://switchbrew.org/index.php?title=HID services#VibrationValue "wikilink") immediately after that, and an u64 [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"). No output.
	# 
	[201] SendVibrationValue(nn::hid::VibrationDeviceHandle, align<4,nn::hid::VibrationValue>, nn::applet::AppletResourceUserId, pid);
	# Takes a PID-descriptor, a [\#VibrationDeviceHandle](http://switchbrew.org/index.php?title=HID services#VibrationDeviceHandle "wikilink"), and an u64 [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"). Returns an output [\#VibrationValue](http://switchbrew.org/index.php?title=HID services#VibrationValue "wikilink").
	# 
	[202] GetActualVibrationValue(nn::hid::VibrationDeviceHandle, nn::applet::AppletResourceUserId, pid) -> nn::hid::VibrationValue;
	# No input. Returns an [\#IActiveVibrationDeviceList](#nn::hid::IActiveVibrationDeviceList "wikilink").
	# 
	[203] CreateActiveVibrationDeviceList() -> object<nn::hid::IActiveVibrationDeviceList>;
	# Takes an input u8 bool. No output.
	# 
	# This affects the config displayed by System Settings.
	# 
	[204] PermitVibration(bool);
	# No input. Returns an output u8 bool.
	# 
	[205] IsVibrationPermitted() -> bool;
	# Takes an u64 [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"), and two type-0x9 input buffers containing an array of: [\#VibrationDeviceHandle](http://switchbrew.org/index.php?title=HID services#VibrationDeviceHandle "wikilink") for first buffer, and [\#VibrationValue](http://switchbrew.org/index.php?title=HID services#VibrationValue "wikilink") for the second buffer.
	# 
	# Official sw uses the same entry-count for each array.
	# 
	[206] SendVibrationValues(nn::applet::AppletResourceUserId, array<nn::hid::VibrationDeviceHandle,9>, array<nn::hid::VibrationValue,9>);
	@version(4.0.0+)
	[207] SendVibrationGcErmCommand();
	@version(4.0.0+)
	[208] GetActualVibrationGcErmCommand();
	@version(4.0.0+)
	[209] BeginPermitVibrationSession();
	@version(4.0.0+)
	[210] EndPermitVibrationSession();
	[300] ActivateConsoleSixAxisSensor(nn::applet::AppletResourceUserId, pid);
	[301] StartConsoleSixAxisSensor(nn::hid::ConsoleSixAxisSensorHandle, nn::applet::AppletResourceUserId, pid);
	[302] StopConsoleSixAxisSensor(nn::hid::ConsoleSixAxisSensorHandle, nn::applet::AppletResourceUserId, pid);
	@version(5.0.0+)
	[303] ActivateSevenSixAxisSensor();
	@version(5.0.0+)
	[304] StartSevenSixAxisSensor();
	@version(5.0.0+)
	[305] StopSevenSixAxisSensor();
	@version(5.0.0+)
	[306] InitializeSevenSixAxisSensor();
	@version(5.0.0+)
	[307] FinalizeSevenSixAxisSensor();
	@version(5.0.0+)
	[308] SetSevenSixAxisSensorFusionStrength();
	@version(5.0.0+)
	[309] GetSevenSixAxisSensorFusionStrength();
	[400] IsUsbFullKeyControllerEnabled() -> bool;
	[401] EnableUsbFullKeyController(bool);
	[402] IsUsbFullKeyControllerConnected(u32) -> bool;
	@version(4.0.0+)
	[403] HasBattery();
	@version(4.0.0+)
	[404] HasLeftRightBattery();
	@version(4.0.0+)
	[405] GetNpadInterfaceType();
	@version(4.0.0+)
	[406] GetNpadLeftRightInterfaceType();
	@version(5.0.0+)
	[500] GetPalmaConnectionHandle();
	@version(5.0.0+)
	[501] InitializePalma();
	@version(5.0.0+)
	[502] AcquirePalmaOperationCompleteEvent();
	@version(5.0.0+)
	[503] GetPalmaOperationInfo();
	@version(5.0.0+)
	[504] PlayPalmaActivity();
	@version(5.0.0+)
	[505] SetPalmaFrModeType();
	@version(5.0.0+)
	[506] ReadPalmaStep();
	@version(5.0.0+)
	[507] EnablePalmaStep();
	@version(5.0.0+)
	[508] SuspendPalmaStep();
	@version(5.0.0+)
	[509] ResetPalmaStep();
	@version(5.0.0+)
	[510] ReadPalmaApplicationSection();
	@version(5.0.0+)
	[511] WritePalmaApplicationSection();
	@version(5.0.0+)
	[512] ReadPalmaUniqueCode();
	@version(5.0.0+)
	[513] SetPalmaUniqueCodeInvalid();
	[1000] SetNpadCommunicationMode(nn::applet::AppletResourceUserId, i64, pid);
	[1001] GetNpadCommunicationMode() -> i64;
}

interface nn::hid::IHidSystemServer is hid:sys {
	[31] SendKeyboardLockKeyEvent(nn::hid::system::KeyboardLockKeyEvent);
	[101] AcquireHomeButtonEventHandle(nn::applet::AppletResourceUserId, pid) -> KObject;
	[111] ActivateHomeButton(nn::applet::AppletResourceUserId, pid);
	[121] AcquireSleepButtonEventHandle(nn::applet::AppletResourceUserId, pid) -> KObject;
	[131] ActivateSleepButton(nn::applet::AppletResourceUserId, pid);
	[141] AcquireCaptureButtonEventHandle(nn::applet::AppletResourceUserId, pid) -> KObject;
	[151] ActivateCaptureButton(nn::applet::AppletResourceUserId, pid);
	[210] AcquireNfcDeviceUpdateEventHandle() -> KObject;
	[211] GetNpadsWithNfc() -> (i64, array<u32,10>);
	[212] AcquireNfcActivateEventHandle(u32) -> KObject;
	[213] ActivateNfc(bool, u32, nn::applet::AppletResourceUserId, pid);
	@version(4.0.0+)
	[214] GetXcdHandleForNpadWithNfc();
	@version(4.0.0+)
	[215] IsNfcActivated();
	[230] AcquireIrSensorEventHandle(u32) -> KObject;
	[231] ActivateIrSensor(bool, u32, nn::applet::AppletResourceUserId, pid);
	[301] ActivateNpadSystem(u32);
	[303] ApplyNpadSystemCommonPolicy(nn::applet::AppletResourceUserId, pid);
	[304] EnableAssigningSingleOnSlSrPress(nn::applet::AppletResourceUserId, pid);
	[305] DisableAssigningSingleOnSlSrPress(nn::applet::AppletResourceUserId, pid);
	[306] GetLastActiveNpad() -> u32;
	[307] GetNpadSystemExtStyle(u32) -> (i64, i64);
	@version(5.0.0+)
	[308] ApplyNpadSystemCommonPolicyFull();
	@version(5.0.0+)
	[309] GetNpadFullKeyGripColor();
	[311] SetNpadPlayerLedBlinkingDevice(u32, nn::hid::system::DeviceType, nn::applet::AppletResourceUserId, pid);
	[321] GetUniquePadsFromNpad(u32) -> (i64, array<nn::hid::system::UniquePadId,10>);
	[322] GetIrSensorState(u32, nn::applet::AppletResourceUserId, pid) -> i64;
	[323] GetXcdHandleForNpadWithIrSensor(u32, nn::applet::AppletResourceUserId, pid) -> u64;
	[500] SetAppletResourceUserId(nn::applet::AppletResourceUserId);
	[501] RegisterAppletResourceUserId(bool, nn::applet::AppletResourceUserId);
	[502] UnregisterAppletResourceUserId(nn::applet::AppletResourceUserId);
	[503] EnableAppletToGetInput(bool, nn::applet::AppletResourceUserId);
	[504] SetAruidValidForVibration(bool, nn::applet::AppletResourceUserId);
	[505] EnableAppletToGetSixAxisSensor(bool, nn::applet::AppletResourceUserId);
	# Takes an input 32bit float.
	# 
	[510] SetVibrationMasterVolume(f32);
	[511] GetVibrationMasterVolume() -> f32;
	[512] BeginPermitVibrationSession(nn::applet::AppletResourceUserId);
	[513] EndPermitVibrationSession();
	[520] EnableHandheldHids();
	[521] DisableHandheldHids();
	[540] AcquirePlayReportControllerUsageUpdateEvent() -> KObject;
	[541] GetPlayReportControllerUsages() -> (i64, array<nn::hid::system::PlayReportControllerUsage,10>);
	[542] AcquirePlayReportRegisteredDeviceUpdateEvent() -> KObject;
	@version(1.0.0-4.1.0)
	[543] GetRegisteredDevices() -> (i64, array<nn::hid::system::RegisteredDevice,10>);
	[544] AcquireConnectionTriggerTimeoutEvent() -> KObject;
	[545] SendConnectionTrigger(nn::bluetooth::Address);
	[546] AcquireDeviceRegisteredEventForControllerSupport() -> KObject;
	[547] GetAllowedBluetoothLinksCount() -> i64;
	@version(5.0.0+)
	[548] GetRegisteredDevices();
	[700] ActivateUniquePad(nn::applet::AppletResourceUserId, nn::hid::system::UniquePadId, pid);
	[702] AcquireUniquePadConnectionEventHandle() -> KObject;
	[703] GetUniquePadIds() -> (i64, array<nn::hid::system::UniquePadId,10>);
	[751] AcquireJoyDetachOnBluetoothOffEventHandle(nn::applet::AppletResourceUserId, pid) -> KObject;
	[800] ListSixAxisSensorHandles(nn::hid::system::UniquePadId) -> (i64, array<nn::hid::system::UniqueSixAxisSensorHandle,10>);
	[801] IsSixAxisSensorUserCalibrationSupported(nn::hid::system::UniqueSixAxisSensorHandle) -> bool;
	[802] ResetSixAxisSensorCalibrationValues(nn::hid::system::UniqueSixAxisSensorHandle);
	[803] StartSixAxisSensorUserCalibration(nn::hid::system::UniqueSixAxisSensorHandle);
	[804] CancelSixAxisSensorUserCalibration(nn::hid::system::UniqueSixAxisSensorHandle);
	[805] GetUniquePadBluetoothAddress(nn::hid::system::UniquePadId) -> nn::bluetooth::Address;
	[806] DisconnectUniquePad(nn::hid::system::UniquePadId);
	@version(5.0.0+)
	[807] GetUniquePadType();
	@version(5.0.0+)
	[808] GetUniquePadInterface();
	@version(5.0.0+)
	[809] GetUniquePadSerialNumber();
	@version(5.0.0+)
	[810] GetUniquePadControllerNumber();
	@version(5.0.0+)
	[811] GetSixAxisSensorUserCalibrationStage();
	[821] StartAnalogStickManualCalibration(nn::hid::system::UniquePadId, i64);
	[822] RetryCurrentAnalogStickManualCalibrationStage(nn::hid::system::UniquePadId, i64);
	[823] CancelAnalogStickManualCalibration(nn::hid::system::UniquePadId, i64);
	[824] ResetAnalogStickManualCalibration(nn::hid::system::UniquePadId, i64);
	@version(5.0.0+)
	[825] GetAnalogStickState();
	@version(5.0.0+)
	[826] GetAnalogStickManualCalibrationStage();
	@version(5.0.0+)
	[827] IsAnalogStickButtonPressed();
	@version(5.0.0+)
	[828] IsAnalogStickInReleasePosition();
	@version(5.0.0+)
	[829] IsAnalogStickInCircumference();
	[850] IsUsbFullKeyControllerEnabled() -> bool;
	[851] EnableUsbFullKeyController(bool);
	[852] IsUsbConnected(nn::hid::system::UniquePadId) -> bool;
	[900] ActivateInputDetector(nn::applet::AppletResourceUserId, pid);
	[901] NotifyInputDetector(nn::hid::system::InputSourceId);
	[1000] InitializeFirmwareUpdate();
	[1001] GetFirmwareVersion(nn::hid::system::UniquePadId) -> nn::hid::system::FirmwareVersion;
	[1002] GetAvailableFirmwareVersion(nn::hid::system::UniquePadId) -> nn::hid::system::FirmwareVersion;
	[1003] IsFirmwareUpdateAvailable(nn::hid::system::UniquePadId) -> bool;
	[1004] CheckFirmwareUpdateRequired(nn::hid::system::UniquePadId) -> i64;
	[1005] StartFirmwareUpdate(nn::hid::system::UniquePadId) -> nn::hid::system::FirmwareUpdateDeviceHandle;
	[1006] AbortFirmwareUpdate();
	[1007] GetFirmwareUpdateState(nn::hid::system::FirmwareUpdateDeviceHandle) -> nn::hid::system::FirmwareUpdateState;
	@version(4.0.0+)
	[1008] ActivateAudioControl();
	@version(4.0.0+)
	[1009] AcquireAudioControlEventHandle();
	@version(4.0.0+)
	[1010] GetAudioControlStates();
	@version(4.0.0+)
	[1011] DeactivateAudioControl();
	@version(5.0.0+)
	[1050] IsSixAxisSensorAccurateUserCalibrationSupported();
	@version(5.0.0+)
	[1051] StartSixAxisSensorAccurateUserCalibration();
	@version(5.0.0+)
	[1052] CancelSixAxisSensorAccurateUserCalibration();
	@version(5.0.0+)
	[1053] GetSixAxisSensorAccurateUserCalibrationState();
	@version(5.0.0+)
	[1100] GetHidbusSystemServiceObject();
}

interface nn::hid::IHidTemporaryServer is hid:tmp {
	[0] GetConsoleSixAxisSensorCalibrationValues(nn::hid::ConsoleSixAxisSensorHandle, nn::applet::AppletResourceUserId, pid) -> nn::hid::tmp::ConsoleSixAxisSensorCalibrationValues;
}

interface nn::hidbus::IHidbusServer is hidbus {
	[1] GetBusHandle();
	[2] IsExternalDeviceConnected();
	[3] Initialize();
	[4] Finalize();
	[5] EnableExternalDevice();
	[6] GetExternalDeviceId();
	[7] SendCommandAsync();
	[8] GetSendCommandAsynceResult();
	[9] SetEventForSendCommandAsycResult();
	[10] GetSharedMemoryHandle();
	[11] EnableJoyPollingReceiveMode();
	[12] DisableJoyPollingReceiveMode();
	[13] GetPollingData();
}

interface nn::htc::tenv::IService {
	[0] GetVariable(bytes<64>) -> (u64, buffer<unknown,6,0>);
	[1] GetVariableLength(bytes<64>) -> u64;
	[2] WaitUntilVariableAvailable(u64);
}

interface nn::htc::tenv::IServiceManager is htc:tenv {
	[0] GetServiceInterface(u64, pid) -> object<IUnknown>;
}

interface nn::i2c::IManager is i2c:pcv, i2c {
	# Takes a raw [\#GpioPadDescriptor](http://switchbrew.org/index.php?title=Bus services#GpioPadDescriptor "wikilink") and returns a [\#IPadSession](#nn::gpio::IPadSession "wikilink") session for it.
	# 
	[0] OpenSessionForDev(u16, u32, u32, u32) -> object<IUnknown>;
	# Same thing as [\#OpenSessionForDev](#nn::gpio::IManager(0) "wikilink") except it takes a **GpioPadName** which is then converted to a [\#GpioPadDescriptor](http://switchbrew.org/index.php?title=Bus services#GpioPadDescriptor "wikilink"). Returns an [\#IPadSession](#nn::gpio::IPadSession "wikilink") session.
	# 
	[1] OpenSession(u32) -> object<IUnknown>;
	# Takes an **I2cDevice** and returns true if the device exists or false otherwise.
	# 
	[2] HasDevice(u32) -> u8;
	# Takes an u32 **port**, an u16 **addr**, an **AddressingMode** (1 for 10-bit, 0 otherwise) and a **SpeedMode** (400000 or 100000). Returns true if the device exists or false otherwise.
	# 
	[3] HasDeviceForDev(u16, u32, u32, u32) -> u8;
}

interface nn::i2c::ISession {
	[0] Send(u32, buffer<unknown,5,0>);
	[1] Receive(u32) -> buffer<unknown,6,0>;
	[2] ExecuteCommandList(buffer<unknown,9,0>) -> buffer<unknown,6,0>;
	[10] SendAuto(u32, buffer<unknown,33,0>);
	[11] ReceiveAuto(u32) -> buffer<unknown,34,0>;
	[12] ExecuteCommandListAuto(buffer<unknown,9,0>) -> buffer<unknown,34,0>;
}

interface nn::idle::detail::IPolicyManagerSystem is idle:sys {
	[0] GetAutoPowerDownEvent() -> KObject;
	@version(1.0.0-3.0.2)
	[1] Unknown1();
	@version(1.0.0-3.0.2)
	[2] Unknown2();
	@undocumented
	[3] Unknown3();
	[4] Unknown4();
	[5] Unknown5();
}

interface nn::irsensor::IIrSensorServer is irs {
	# Takes a PID-descriptor and an [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"). No output.
	# 
	[302] ActivateIrsensor(nn::applet::AppletResourceUserId, pid);
	# Takes a PID-descriptor and an [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"). No output.
	# 
	[303] DeactivateIrsensor(nn::applet::AppletResourceUserId, pid);
	# Takes a PID-descriptor and an [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"). Returns a SharedMemory handle.
	# 
	# The SharedMemory is mapped with permissions=read-only and size=0x8000.
	# 
	[304] GetIrsensorSharedMemoryHandle(nn::applet::AppletResourceUserId, pid) -> KObject;
	# Takes a PID-descriptor, an [\#IrCameraHandle](http://switchbrew.org/index.php?title=HID services#IrCameraHandle "wikilink"), and an [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"). No output.
	# 
	[305] StopImageProcessor(nn::irsensor::IrCameraHandle, nn::applet::AppletResourceUserId, pid);
	# Takes a PID-descriptor, an [\#IrCameraHandle](http://switchbrew.org/index.php?title=HID services#IrCameraHandle "wikilink"), an [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"), and a [\#PackedMomentProcessorConfig](http://switchbrew.org/index.php?title=HID services#PackedMomentProcessorConfig "wikilink"). No output.
	# 
	[306] RunMomentProcessor(nn::irsensor::IrCameraHandle, nn::applet::AppletResourceUserId, nn::irsensor::PackedMomentProcessorConfig, pid);
	# Takes a PID-descriptor, an [\#IrCameraHandle](http://switchbrew.org/index.php?title=HID services#IrCameraHandle "wikilink"), an [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"), and a [\#PackedClusteringProcessorConfig](http://switchbrew.org/index.php?title=HID services#PackedClusteringProcessorConfig "wikilink"). No output.
	# 
	[307] RunClusteringProcessor(nn::irsensor::IrCameraHandle, nn::applet::AppletResourceUserId, nn::irsensor::PackedClusteringProcessorConfig, pid);
	# Takes a PID-descriptor, an [\#IrCameraHandle](http://switchbrew.org/index.php?title=HID services#IrCameraHandle "wikilink"), an [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"), a [\#PackedImageTransferProcessorConfig](http://switchbrew.org/index.php?title=HID services#PackedImageTransferProcessorConfig "wikilink"), an u64 for the TransferMemory\_size, and a TransferMemory handle. No output.
	# 
	# Official sw creates the TransferMemory with an user-specified buffer and permissions=0.
	# 
	[308] RunImageTransferProcessor(nn::irsensor::IrCameraHandle, nn::applet::AppletResourceUserId, nn::irsensor::PackedImageTransferProcessorConfig, u64, pid, KObject);
	# Takes a PID-descriptor, a type-0x6 output buffer, an [\#IrCameraHandle](http://switchbrew.org/index.php?title=HID services#IrCameraHandle "wikilink"), and an [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"). Returns an [\#ImageTransferProcessorState](http://switchbrew.org/index.php?title=HID services#ImageTransferProcessorState "wikilink"). No output.
	# 
	[309] GetImageTransferProcessorState(nn::irsensor::IrCameraHandle, nn::applet::AppletResourceUserId, pid) -> (nn::irsensor::ImageTransferProcessorState, buffer<unknown,6,0>);
	# Takes a PID-descriptor, an [\#IrCameraHandle](http://switchbrew.org/index.php?title=HID services#IrCameraHandle "wikilink"), a [\#PackedTeraPluginProcessorConfig](http://switchbrew.org/index.php?title=HID services#PackedTeraPluginProcessorConfig "wikilink") (immediately after the previous word), and an [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"). No output.
	# 
	[310] RunTeraPluginProcessor(nn::irsensor::IrCameraHandle, align<2,nn::irsensor::PackedTeraPluginProcessorConfig>, nn::applet::AppletResourceUserId, pid);
	# Takes an input u32. Returns an output [\#IrCameraHandle](http://switchbrew.org/index.php?title=HID services#IrCameraHandle "wikilink").
	# 
	[311] GetNpadIrCameraHandle(u32) -> nn::irsensor::IrCameraHandle;
	# Takes a PID-descriptor, an [\#IrCameraHandle](http://switchbrew.org/index.php?title=HID services#IrCameraHandle "wikilink"), a [\#PackedDpdProcessorConfig](http://switchbrew.org/index.php?title=HID services#PackedDpdProcessorConfig "wikilink") (immediately after the previous word), and an [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"). No output.
	# 
	[312] RunPointingProcessor(nn::irsensor::IrCameraHandle, align<2,nn::irsensor::PackedDpdProcessorConfig>, nn::applet::AppletResourceUserId, pid);
	# Takes a PID-descriptor, an [\#IrCameraHandle](http://switchbrew.org/index.php?title=HID services#IrCameraHandle "wikilink"), and an [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"). No output.
	# 
	[313] SuspendImageProcessor(nn::irsensor::IrCameraHandle, nn::applet::AppletResourceUserId, pid);
	# Takes a PID-descriptor, an [\#IrCameraHandle](http://switchbrew.org/index.php?title=HID services#IrCameraHandle "wikilink"), a [\#PackedMcuVersion](http://switchbrew.org/index.php?title=HID services#PackedMcuVersion "wikilink"), and an [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"). No output.
	# 
	@version(3.0.0+)
	[314] CheckFirmwareVersion(nn::irsensor::IrCameraHandle, nn::irsensor::PackedMcuVersion, nn::applet::AppletResourceUserId, pid);
	@version(5.0.0+)
	[315] SetFunctionLevel();
	@version(5.0.0+)
	[316] RunImageTransferExProcessor();
	@version(5.0.0+)
	[317] RunIrLedProcessor();
	@version(5.0.0+)
	[318] StopImageProcessorAsync();
	@version(5.0.0+)
	[319] ActivateIrsensorWithFunctionLevel();
}

interface nn::irsensor::IIrSensorSystemServer is irs:sys {
	[500] SetAppletResourceUserId(nn::applet::AppletResourceUserId);
	[501] RegisterAppletResourceUserId(bool, nn::applet::AppletResourceUserId);
	[502] UnregisterAppletResourceUserId(nn::applet::AppletResourceUserId);
	[503] EnableAppletToGetInput(bool, nn::applet::AppletResourceUserId);
}

interface nn::jitsrv::IJitEnvironment {
	[0] Control();
	[1] GenerateCode();
	[1000] LoadPlugin();
	[1001] GetCodeAddress();
}

interface nn::jitsrv::IJitService is jit:u {
	[0] CreateJitEnvironment();
}

interface nn::lbl::detail::ILblController is lbl {
	[0] Unknown0();
	[1] Unknown1();
	[2] Unknown2(u32);
	[3] Unknown3() -> u32;
	[4] Unknown4();
	[5] Unknown5() -> u32;
	[6] TurnOnBacklight(u64);
	[7] TurnOffBacklight(u64);
	[8] GetBacklightStatus() -> u32;
	[9] Unknown9();
	[10] Unknown10();
	[11] Unknown11() -> u8;
	[12] Unknown12();
	[13] Unknown13();
	[14] Unknown14() -> u8;
	[15] Unknown15(u32);
	[16] ReadRawLightSensor() -> u32;
	[17] Unknown17(u32, u32);
	[18] Unknown18(u32) -> u32;
	[19] Unknown19(bytes<12>);
	[20] Unknown20() -> bytes<12>;
	[21] Unknown21(bytes<12>);
	[22] Unknown22() -> bytes<12>;
	@version(3.0.0+)
	[23] Unknown23() -> u8;
	@version(3.0.0+)
	[24] Unknown24(u32);
	@version(3.0.0+)
	[25] Unknown25() -> u32;
	# No input/output. Used by [AM\_services\#SetVrModeEnabled](http://switchbrew.org/index.php?title=AM_services#SetVrModeEnabled "wikilink").
	# 
	# Sets a global state field to 0x1.
	# 
	@version(3.0.0+)
	[26] EnableVrMode();
	# No input/output. Used by [AM\_services\#SetVrModeEnabled](http://switchbrew.org/index.php?title=AM_services#SetVrModeEnabled "wikilink").
	# 
	# Sets the global state field used by [\#EnableVrMode](#nn::lbl::detail::ILblController(26) "wikilink") to 0x0.
	# 
	@version(3.0.0+)
	[27] DisableVrMode();
	# No input. Returns an output u8 bool set by the above commands.
	# 
	# [Category:Services](http://switchbrew.org/index.php?title=Category:Services "wikilink")
	# 
	@version(3.0.0+)
	[28] GetVrMode() -> u8;
}

interface nn::ldn::detail::IMonitorService {
	[0] GetStateForMonitor() -> u32;
	[1] GetNetworkInfoForMonitor() -> buffer<unknown,26,1152>;
	[2] GetIpv4AddressForMonitor() -> (u32, u32);
	[3] GetDisconnectReasonForMonitor() -> u16;
	[4] GetSecurityParameterForMonitor() -> bytes<32>;
	[5] GetNetworkConfigForMonitor() -> bytes<32>;
	[100] InitializeMonitor();
	[101] FinalizeMonitor();
}

interface nn::ldn::detail::IMonitorServiceCreator is ldn:m {
	# Returns an [\#IMonitorService](#nn::ldn::detail::IMonitorService "wikilink").
	# 
	[0] CreateMonitorService() -> object<IUnknown>;
}

interface nn::ldn::detail::ISystemLocalCommunicationService {
	[0] GetState() -> u32;
	[1] GetNetworkInfo() -> buffer<unknown,26,1152>;
	[2] GetIpv4Address() -> (u32, u32);
	[3] GetDisconnectReason() -> u16;
	[4] GetSecurityParameter() -> bytes<32>;
	[5] GetNetworkConfig() -> bytes<32>;
	[100] AttachStateChangeEvent() -> KObject;
	[101] GetNetworkInfoLatestUpdate() -> (buffer<unknown,26,1152>, buffer<unknown,10,0>);
	[102] Scan(u16, bytes<96>) -> (u16, buffer<unknown,34,0>);
	[103] ScanPrivate(u16, bytes<96>) -> (u16, buffer<unknown,34,0>);
	[200] OpenAccessPoint();
	[201] CloseAccessPoint();
	[202] CreateNetwork(bytes<68>, align<1,bytes<48>>, bytes<32>);
	[203] CreateNetworkPrivate(bytes<68>, align<1,bytes<32>>, align<1,bytes<48>>, bytes<32>, buffer<unknown,9,0>);
	[204] DestroyNetwork();
	[205] Reject(u32);
	[206] SetAdvertiseData(buffer<unknown,33,0>);
	[207] SetStationAcceptPolicy(u8);
	[208] AddAcceptFilterEntry(bytes<6>);
	[209] ClearAcceptFilter();
	[300] OpenStation();
	[301] CloseStation();
	[302] Connect(bytes<68>, align<1,bytes<48>>, u32, u32, buffer<unknown,25,1152>);
	[303] ConnectPrivate(bytes<68>, align<1,bytes<32>>, align<1,bytes<48>>, u32, u32, bytes<32>);
	[304] Disconnect();
	[400] InitializeSystem(u64, pid);
	[401] FinalizeSystem();
}

interface nn::ldn::detail::ISystemServiceCreator is ldn:s {
	# Returns an [\#ISystemLocalCommunicationService](#nn::ldn::detail::ISystemLocalCommunicationService "wikilink").
	# 
	[0] CreateSystemLocalCommunicationService() -> object<IUnknown>;
}

interface nn::ldn::detail::IUserLocalCommunicationService {
	[0] GetState() -> u32;
	[1] GetNetworkInfo() -> buffer<unknown,26,1152>;
	[2] GetIpv4Address() -> (u32, u32);
	[3] GetDisconnectReason() -> u16;
	[4] GetSecurityParameter() -> bytes<32>;
	[5] GetNetworkConfig() -> bytes<32>;
	[100] AttachStateChangeEvent() -> KObject;
	[101] GetNetworkInfoLatestUpdate() -> (buffer<unknown,26,1152>, buffer<unknown,10,0>);
	[102] Scan(u16, bytes<96>) -> (u16, buffer<unknown,34,0>);
	[103] ScanPrivate(u16, bytes<96>) -> (u16, buffer<unknown,34,0>);
	[200] OpenAccessPoint();
	[201] CloseAccessPoint();
	[202] CreateNetwork(bytes<68>, align<1,bytes<48>>, bytes<32>);
	[203] CreateNetworkPrivate(bytes<68>, align<1,bytes<32>>, align<1,bytes<48>>, bytes<32>, buffer<unknown,9,0>);
	[204] DestroyNetwork();
	[205] Reject(u32);
	[206] SetAdvertiseData(buffer<unknown,33,0>);
	[207] SetStationAcceptPolicy(u8);
	[208] AddAcceptFilterEntry(bytes<6>);
	[209] ClearAcceptFilter();
	[300] OpenStation();
	[301] CloseStation();
	[302] Connect(bytes<68>, align<1,bytes<48>>, u32, u32, buffer<unknown,25,1152>);
	[303] ConnectPrivate(bytes<68>, align<1,bytes<32>>, align<1,bytes<48>>, u32, u32, bytes<32>);
	[304] Disconnect();
	[400] Initialize(u64, pid);
	[401] Finalize();
}

interface nn::ldn::detail::IUserServiceCreator is ldn:u {
	# Returns an [\#IUserLocalCommunicationService](#nn::ldn::detail::IUserLocalCommunicationService "wikilink").
	# 
	[0] CreateUserLocalCommunicationService() -> object<IUnknown>;
}

interface nn::ldr::detail::IDebugMonitorInterface is ldr:dmnt {
	# Same as [AddProcessToLaunchQueue](http://switchbrew.org/index.php?title=Loader_services#AddProcessToLaunchQueue "wikilink") but for processes marked as debug.
	# 
	[0] AddProcessToDebugLaunchQueue();
	# Same as [ClearLaunchQueue](http://switchbrew.org/index.php?title=Loader_services#ClearLaunchQueue "wikilink").
	# 
	[1] ClearDebugLaunchQueue();
	# Takes in a u64 ProcessID, and a C descriptor. Returns the number of NsoInfos copied to output.
	# 
	# NsoInfo has the following layout:
	# 
	# | Offset | Size | Description                       |
	# |--------|------|-----------------------------------|
	# | 0x0    | 0x20 | Build ID, from NSO header+0x40. |
	# | 0x20   | 0x8  | Mapped address for this NSO       |
	# | 0x28   | 0x8  | Mapped size for this NSO          |
	# |        |      |                                   |
	# 
	[2] GetNsoInfos();
}

interface nn::ldr::detail::IProcessManagerInterface is ldr:pm {
	[0] CreateProcess();
	# Takes a TitleId + StorageId, parses the NPDM, and writes output to a C descriptor buffer as follows:
	# 
	# | Offset   | Size     | Description                                       |                                      |
	# |----------|----------|---------------------------------------------------|--------------------------------------|
	# | 0x0      | 0x1      | MainThreadPrio. Arg1 to svcStartProcess           |                                      |
	# | 0x1      | 0x1      | DefaultCpuId. Arg2 to svcStartProcess             |                                      |
	# | 0x2      | 0x1      | ApplicationType, see \[\[Process Manager services | here\]\].                            |
	# | 0x3      | 0x1      | Padding                                           |                                      |
	# | 0x4      | 0x4      | MainThreadStackSize. Arg3 to svcStartProcess      |                                      |
	# | 0x8      | 0x8      | TitleIdRange\_Min                                 |                                      |
	# | 0x10     | 0x4      | ACID \[\[NPDM\#Service Access Control             | Service Access Control\]\] list size |
	# | 0x14     | 0x4      | ACI0 \[\[NPDM\#Service Access Control             | Service Access Control\]\] list size |
	# | 0x18     | 0x4      | ACID \[\[NPDM\#FS Access Control                  | FS Access Control\]\] buffer size    |
	# | 0x1C     | 0x4      | ACI0 \[\[NPDM\#FS Access Control                  | FS Access Control\]\] buffer size    |
	# | 0x20     | <Varies> | ACID \[\[NPDM\#Service Access Control             | Service Access Control\]\] list      |
	# | <Varies> | <Varies> | ACI0 \[\[NPDM\#Service Access Control             | Service Access Control\]\] list      |
	# | <Varies> | <Varies> | ACID \[\[NPDM\#FS Access Control                  | FS Access Control\]\] buffer         |
	# | <Varies> | <Varies> | ACI0 \[\[NPDM\#FS Access Control                  | FS Access Control\]\]                |
	# 
	[1] GetProgramInfo();
	# Takes a TitleId + StorageId, returns an index.
	# 
	[2] RegisterTitle();
	# Takes the index from [\#RegisterTitle](#nn::ldr::detail::IProcessManagerInterface(2) "wikilink").
	# 
	[3] UnregisterTitle();
}

interface nn::ldr::detail::IRoInterface is ldr:ro {
	# | Word | Value                    |
	# |------|--------------------------|
	# | 0    | 0x00000004               |
	# | 1    | 0x80000012               |
	# | 2    | 0x00000001               |
	# | 0-1  | Pid                      |
	# | 0    | SCFI                   |
	# | 1    | 0x00000000               |
	# | 2    | Always 0.                |
	# | 3    | Nro heap address         |
	# | 4    | Nro size                 |
	# | 5    | Bss backing heap address |
	# | 6    | Bss size                 |
	# 
	[0] LoadNro();
	[1] UnloadNro();
	# | Word | Value       |
	# |------|-------------|
	# | 0    | 0x00000004  |
	# | 1    | 0x8000000E  |
	# | 2    | 0x00000001  |
	# |      |             |
	# | 0-1  | Pid         |
	# | 0    | SFCI      |
	# | 1    | 0x00000002  |
	# | 2    | Always 0.   |
	# | 3    | Nrr address |
	# | 4    | Nrr size    |
	# 
	[2] LoadNrr();
	[3] UnloadNrr();
	# | Word | Value                       |
	# |------|-----------------------------|
	# | 0    | 0x00000004                  |
	# | 1    | 0x8000000A                  |
	# | 2    | 0x00000003                  |
	# | 0-1  | Pid                         |
	# | 2    | Process handle (0xFFFF8001) |
	# | 0    | SFCI                      |
	# | 1    | 0x00000004                  |
	# | 2    | Always 0.                   |
	# 
	# [Category:Services](http://switchbrew.org/index.php?title=Category:Services "wikilink")
	# 
	[4] Initialize();
}

interface nn::ldr::detail::IShellInterface is ldr:shel {
	# Takes a type-0x19 input buffer with launch arguments (as string), an u32 (size of arguments string), and an input title-id.
	# 
	# Loads a process for the specified title-id and passes along the supplied arguments. Loaded processes are kept in a queue waiting for PM to launch them. The maximum number of waiting processes in this list is 10.
	# 
	@undocumented
	[0] AddProcessToLaunchQueue();
	# Clears the loaded processes waiting queue.
	# 
	[1] ClearLaunchQueue();
}

interface nn::lm::ILogGetter is lm:get {
	[0] StartLogging();
	[1] StopLogging();
	[2] GetLog();
}

interface nn::lm::ILogService is lm {
	[0] OpenLogger(u64, pid) -> object<IUnknown>;
}

interface nn::lm::ILogger {
	[0] Initialize(buffer<unknown,33,0>);
	@version(3.0.0+)
	[1] SetDestination(u32);
}

interface nn::lr::IAddOnContentLocationResolver {
	@undocumented
	[0] ResolveAddOnContentPath();
	[1] RegisterAddOnContentStorage(u8, u64);
	[2] UnregisterAllAddOnContentPath();
}

interface nn::lr::ILocationResolver {
	# Takes an u64 **TitleID** and a C descriptor. Used for [NCA-type1](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type1 "wikilink").
	# 
	@undocumented
	[0] ResolveProgramPath();
	# Takes an u64 **TitleID** and a X descriptor with a [ContentPath](http://switchbrew.org/index.php?title=Filesystem_services#ContentPath "wikilink"). Used for [NCA-type1](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type1 "wikilink").
	# 
	# Inserts a new [entry](http://switchbrew.org/index.php?title=NCM services#Location_List_Entry "wikilink") with **flag** set to 0.
	# 
	@undocumented
	[1] RedirectProgramPath();
	# Takes an u64 **TitleID** and a C descriptor. Used for [NCA-type3](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type3 "wikilink").
	# 
	@undocumented
	[2] ResolveApplicationControlPath();
	# Takes an u64 **TitleID** and a C descriptor. Used for [NCA-type4](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type4 "wikilink").
	# 
	@undocumented
	[3] ResolveApplicationHtmlDocumentPath();
	# Takes an u64 **TitleID** and a C descriptor. Used for [NCA-type3](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type3 "wikilink").
	# 
	@undocumented
	[4] ResolveDataPath();
	# Takes an u64 **TitleID** and a X descriptor with a [ContentPath](http://switchbrew.org/index.php?title=Filesystem_services#ContentPath "wikilink"). Used for [NCA-type3](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type3 "wikilink").
	# 
	# Inserts a new [entry](http://switchbrew.org/index.php?title=NCM services#Location_List_Entry "wikilink") with **flag** set to 1.
	# 
	@undocumented
	[5] RedirectApplicationControlPath();
	# Takes an u64 **TitleID** and a X descriptor with a [ContentPath](http://switchbrew.org/index.php?title=Filesystem_services#ContentPath "wikilink"). Used for [NCA-type4](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type4 "wikilink").
	# 
	# Inserts a new [entry](http://switchbrew.org/index.php?title=NCM services#Location_List_Entry "wikilink") with **flag** set to 1.
	# 
	@undocumented
	[6] RedirectApplicationHtmlDocumentPath();
	# Takes an u64 **TitleID** and a C descriptor. Used for [NCA-type5](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type5 "wikilink").
	# 
	@undocumented
	[7] ResolveApplicationLegalInformationPath();
	# Takes an u64 **TitleID** and a X descriptor with a [ContentPath](http://switchbrew.org/index.php?title=Filesystem_services#ContentPath "wikilink"). Used for [NCA-type5](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type5 "wikilink").
	# 
	# Inserts a new [entry](http://switchbrew.org/index.php?title=NCM services#Location_List_Entry "wikilink") with **flag** set to 1.
	# 
	@undocumented
	[8] RedirectApplicationLegalInformationPath();
	# Takes no input. Frees all linked-lists' entries that have **flag** set to 0.
	# 
	[9] Refresh();
	# Same as [SetProgramNcaPath](http://switchbrew.org/index.php?title=NCM services#SetProgramNcaPath "wikilink"), but inserts a new [entry](http://switchbrew.org/index.php?title=NCM services#Location_List_Entry "wikilink") with **flag** set to 1.
	# 
	@version(5.0.0+)
	[10] SetProgramNcaPath2();
	# Takes no input. Frees all linked-lists' entries that have **flag** set to 1.
	# 
	@version(5.0.0+)
	[11] ClearLocationResolver2();
	# Takes an u64 **TitleID**. Used for [NCA-type1](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type1 "wikilink").
	# 
	# Removes the [entry](http://switchbrew.org/index.php?title=NCM services#Location_List_Entry "wikilink") that matches the input TitleID.
	# 
	@version(5.0.0+)
	[12] DeleteProgramNcaPath();
	# Takes an u64 **TitleID**. Used for [NCA-type3](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type3 "wikilink").
	# 
	# Removes the [entry](http://switchbrew.org/index.php?title=NCM services#Location_List_Entry "wikilink") that matches the input TitleID.
	# 
	@version(5.0.0+)
	[13] DeleteControlNcaPath();
	# Takes an u64 **TitleID**. Used for [NCA-type4](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type4 "wikilink").
	# 
	# Removes the [entry](http://switchbrew.org/index.php?title=NCM services#Location_List_Entry "wikilink") that matches the input TitleID.
	# 
	@version(5.0.0+)
	[14] DeleteDocHtmlNcaPath();
	# Takes an u64 **TitleID**. Used for [NCA-type5](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type5 "wikilink").
	# 
	# Removes the [entry](http://switchbrew.org/index.php?title=NCM services#Location_List_Entry "wikilink") that matches the input TitleID.
	# 
	@version(5.0.0+)
	[15] DeleteInfoHtmlNcaPath();
}

interface nn::lr::ILocationResolverManager is lr {
	@undocumented
	[0] OpenLocationResolver();
	[1] OpenRegisteredLocationResolver() -> object<IUnknown>;
	[2] RefreshLocationResolver(u8);
	@version(2.0.0+)
	[3] OpenAddOnContentLocationResolver() -> object<IUnknown>;
}

interface nn::lr::IRegisteredLocationResolver {
	@undocumented
	[0] ResolveProgramPath();
	@undocumented
	[1] RegisterProgramPath();
	[2] UnregisterProgramPath(u64);
	@undocumented
	[3] RedirectProgramPath();
	@version(2.0.0+)
	@undocumented
	[4] ResolveHtmlDocumentPath();
	@version(2.0.0+)
	@undocumented
	[5] RegisterHtmlDocumentPath();
	@version(2.0.0+)
	[6] UnregisterHtmlDocumentPath(u64);
	@version(2.0.0+)
	@undocumented
	[7] RedirectHtmlDocumentPath();
}

interface nn::migration::user::IAsyncContext {
	[0] GetSystemEvent();
	[1] Cancel();
	[2] HasDone();
	[3] GetResult();
}

interface nn::migration::user::IClient {
	[0] GetClientProfile();
	[10] CreateLoginSession();
	[11] GetNetworkServiceAccountId();
	[12] GetUserNickname();
	[13] GetUserProfileImage();
	[100] PrepareAsync();
	[101] GetConnectionRequirement();
	[200] ScanServersAsync();
	[201] ListServers();
	[210] ConnectByServerIdAsync();
	[300] GetStorageShortfall();
	[301] GetTotalTransferInfo();
	[302] GetImmigrantUid();
	[310] GetCurrentTransferInfo();
	[311] GetCurrentRelatedApplications();
	[320] TransferNextAsync();
	[350] SuspendAsync();
	[400] CompleteAsync();
	[500] Abort();
	[999] DebugSynchronizeStateInFinalizationAsync();
}

interface nn::migration::user::IServer {
	[0] GetUid();
	[1] GetServerProfile();
	[100] PrepareAsync();
	[101] GetConnectionRequirement();
	[200] WaitConnectionAsync();
	[201] GetClientProfile();
	[202] AcceptConnectionAsync();
	[203] DeclineConnectionAsync();
	[300] ProcessTransferAsync();
	[400] CompleteAsync();
	[500] Abort();
}

interface nn::migration::user::IService is mig:usr {
	[10] TryGetLastMigrationInfo();
	[100] CreateServer();
	[101] ResumeServer();
	[200] CreateClient();
	[201] ResumeClient();
}

interface nn::mii::detail::IDatabaseService {
	[0] IsUpdated(i32) -> bool;
	[1] IsFullDatabase() -> bool;
	[2] GetCount(i32) -> i32;
	[3] Get(i32) -> (i32, array<nn::mii::CharInfoElement,6>);
	[4] Get1(i32) -> (i32, array<nn::mii::CharInfo,6>);
	[5] UpdateLatest(nn::mii::CharInfo, i32) -> nn::mii::CharInfo;
	[6] BuildRandom(i32, i32, i32) -> nn::mii::CharInfo;
	[7] BuildDefault(i32) -> nn::mii::CharInfo;
	[8] Get2(i32) -> (i32, array<nn::mii::StoreDataElement,6>);
	[9] Get3(i32) -> (i32, array<nn::mii::StoreData,6>);
	[10] UpdateLatest1(nn::mii::StoreData, i32) -> nn::mii::StoreData;
	[11] FindIndex(nn::mii::CreateId, bool) -> i32;
	[12] Move(nn::mii::CreateId, i32);
	[13] AddOrReplace(nn::mii::StoreData);
	[14] Delete(nn::mii::CreateId);
	[15] DestroyFile();
	[16] DeleteFile();
	[17] Format();
	[18] Import(buffer<unknown,5,0>);
	[19] Export() -> buffer<unknown,6,0>;
	[20] IsBrokenDatabaseWithClearFlag() -> bool;
	[21] GetIndex(nn::mii::CharInfo) -> i32;
	@version(5.0.0+)
	[22] SetInterfaceVersion();
	@version(5.0.0+)
	[23] Convert();
}

interface nn::mii::detail::IImageDatabaseService is miiimg {
	[0] Initialize();
	[10] Reload();
	[11] GetCount();
	[12] IsEmpty();
	[13] IsFull();
	[14] GetAttribute();
	[15] LoadImage();
	[16] AddOrUpdateImage();
	[17] DeleteImages();
	[100] DeleteFile();
	[101] DestroyFile();
	[102] ImportFile();
	[103] ExportFile();
	[104] ForceInitialize();
}

interface nn::mii::detail::IStaticService is mii:e, mii:u {
	[0] GetDatabaseService(i32) -> object<nn::mii::detail::IDatabaseService>;
}

interface nn::mmnv::IRequest is mm:u {
	[0] InitializeOld(u32, u32, u32);
	[1] FinalizeOld(u32);
	[2] SetAndWaitOld(u32, u32, u32);
	[3] GetOld(u32) -> u32;
	@undocumented
	[4] Initialize();
	[5] Finalize(u32);
	[6] SetAndWait(u32, u32, u32);
	[7] Get(u32) -> u32;
}

interface nn::ncm::IContentManager is ncm {
	[0] CreateContentStorage(u8);
	[1] CreateContentMetaDatabase(u8);
	[2] VerifyContentStorage(u8);
	[3] VerifyContentMetaDatabase(u8);
	@undocumented
	[4] OpenContentStorage();
	@undocumented
	[5] OpenContentMetaDatabase();
	@version(1.0.0)
	[6] CloseContentStorageForcibly();
	@version(1.0.0)
	[7] CloseContentMetaDatabaseForcibly();
	[8] CleanupContentMetaDatabase(u8);
	@version(2.0.0+)
	[9] OpenContentStorage2(u8);
	@version(2.0.0+)
	[10] CloseContentStorage(u8);
	@version(2.0.0+)
	[11] OpenContentMetaDatabase2(u8);
	@version(2.0.0+)
	[12] CloseContentMetaDatabase(u8);
}

interface nn::ncm::IContentMetaDatabase {
	@undocumented
	[0] Set();
	@undocumented
	[1] Get();
	@undocumented
	[2] Remove();
	@undocumented
	[3] GetContentIdByType();
	@undocumented
	[4] ListContentInfo();
	@undocumented
	[5] List();
	@undocumented
	[6] GetLatestContentMetaKey();
	# Each 24-byte entry (officially ApplicationContentMetaKey) is as follows:
	# 
	# ``[`meta_record`](http://switchbrew.org/index.php?title=NCA#Meta_records "wikilink")`meta_record;`
	# `u64base_title_id;`
	# 
	# This function takes in a type 6 buffer to write entries to, and a u8 filter [type](http://switchbrew.org/index.php?title=NCM services#Title_Types "wikilink"). If filter is zero, all update records will be copied to to the output buffer (space permitting). Otherwise, only titles with type == filter\_type will be copied to the output buffer.
	# 
	# This func returns a u32 num\_entries\_total, and a u32 num\_entries\_written.
	# 
	@undocumented
	[7] ListApplication();
	@undocumented
	[8] Has();
	@undocumented
	[9] HasAll();
	@undocumented
	[10] GetSize();
	@undocumented
	[11] GetRequiredSystemVersion();
	@undocumented
	[12] GetPatchId();
	[13] DisableForcibly();
	# Takes a type-6 byte buffer, and a type-5 buffer containing [\#NcaIDs](http://switchbrew.org/index.php?title=NCM services#NcaID "wikilink").
	# 
	# This function was stubbed to return 0xDC05 in [2.0.0](http://switchbrew.org/index.php?title=2.0.0 "wikilink").
	# 
	# On 1.0.0: Initialized the output buffer to all 1s. Then, for each [\#NcaID](http://switchbrew.org/index.php?title=NCM services#NcaID "wikilink") in the input buffer, it checks if that NcaID is present anywhere in the database, and if so writes 0 to the corresponding output byte.
	# 
	# In pseudocode, the function basically does the following:
	# 
	# for i in range(len(out\_buf)):
	# 
	# `out_buf[i]=1`
	# 
	# for i, NcaID in NcaIDs:
	# 
	# `ifis_present_in_database(NcaID):`
	# `out_buf[i]=0`
	# 
	@undocumented
	[14] LookupOrphanContent();
	[15] Commit();
	@undocumented
	[16] HasContent();
	@undocumented
	[17] ListContentMetaInfo();
	@undocumented
	[18] GetAttributes();
	@version(2.0.0+)
	@undocumented
	[19] GetRequiredApplicationVersion();
	@version(5.0.0+)
	[20] Unknown20();
}

interface nn::ncm::IContentStorage {
	# Generates a random [\#NcaID](http://switchbrew.org/index.php?title=NCM services#NcaID "wikilink") for use as a placeholder.
	# 
	# Calls nn::util::GenerateUuid(), which internally calls nn::os::GenerateRandomBytes(16);
	# 
	[0] GeneratePlaceHolderId() -> u128;
	@undocumented
	[1] CreatePlaceHolder();
	[2] DeletePlaceHolder(u128);
	@undocumented
	[3] HasPlaceHolder();
	@undocumented
	[4] WritePlaceHolder();
	@undocumented
	[5] Register();
	[6] Delete(u128);
	@undocumented
	[7] Has();
	@undocumented
	[8] GetPath();
	@undocumented
	[9] GetPlaceHolderPath();
	[10] CleanupAllPlaceHolder();
	[11] ListPlaceHolder() -> (u32, buffer<unknown,6,0>);
	# Writes the total number of entries which can be read by GetEntries, to cmdreply <SFCO_offset>+0x10.
	# 
	[12] GetContentCount() -> u32;
	# Takes an output buffer, u32 offset and gets all entries starting at that offset. Returns number of entries read.
	# 
	# Each entry is a [\#NcaID](http://switchbrew.org/index.php?title=NCM services#NcaID "wikilink").
	# 
	# The total read entries is exactly the same as the number of <hex>.nca directories in the storage FS(or at least under the registered directory?).
	# 
	@undocumented
	[13] ListContentId();
	# Takes a [\#NcaID](http://switchbrew.org/index.php?title=NCM services#NcaID "wikilink") as input.
	# 
	# Returns the total size readable by ReadEntryRaw. This is the same as the size-field in the [NAX0](http://switchbrew.org/index.php?title=NAX0 "wikilink") <NcaID>.nca/00 file.
	# 
	@undocumented
	[14] GetSize();
	[15] DisableForcibly();
	@version(2.0.0+)
	@undocumented
	[16] RevertToPlaceHolder();
	@version(2.0.0+)
	@undocumented
	[17] SetPlaceHolderSize();
	# Takes an output buffer, a [\#NcaID](http://switchbrew.org/index.php?title=NCM services#NcaID "wikilink") as input, and a u64 file offset.
	# 
	# Reads plaintext NCA file contents from the Registered path for the NcaID.
	# 
	@version(2.0.0+)
	@undocumented
	[18] ReadContentIdFile();
	@version(2.0.0+)
	@undocumented
	[19] GetRightsIdFromPlaceHolderId();
	@version(2.0.0+)
	@undocumented
	[20] GetRightsIdFromContentId();
	@version(2.0.0+)
	@undocumented
	[21] WriteContentForDebug();
	@version(2.0.0+)
	[22] GetFreeSpaceSize() -> u64;
	@version(2.0.0+)
	[23] GetTotalSpaceSize() -> u64;
	@version(3.0.0+)
	[24] FlushStorage();
	@version(4.0.0+)
	[25] Unknown25();
	@version(4.0.0+)
	[26] Unknown26();
}

interface nn::news::detail::ipc::IServiceCreator is news:a, news:c, news:m, news:p, news:v {
	[0] Unknown0() -> object<IUnknown>;
	[1] Unknown1() -> object<IUnknown>;
	[2] Unknown2() -> object<IUnknown>;
	[3] Unknown3() -> object<IUnknown>;
	[4] Unknown4() -> object<IUnknown>;
}

interface nn::nfc::am::detail::IAm {
	[0] Initialize();
	[1] Finalize();
	[2] NotifyForegroundApplet(u64);
}

interface nn::nfc::am::detail::IAmManager is nfc:am {
	[0] CreateAmInterface() -> object<IUnknown>;
}

interface nn::nfc::detail::ISystem {
	[0] Initialize(u64, u64, pid, buffer<unknown,5,0>);
	[1] Finalize();
	[2] GetState() -> u32;
	[3] IsNfcEnabled() -> u8;
	[100] SetNfcEnabled(u8);
	@version(4.0.0+)
	[400] InitializeSystem();
	@version(4.0.0+)
	[401] FinalizeSystem();
	@version(4.0.0+)
	[402] GetState();
	@version(4.0.0+)
	[403] IsNfcEnabled();
	@version(4.0.0+)
	[404] ListDevices();
	@version(4.0.0+)
	[405] GetDeviceState();
	@version(4.0.0+)
	[406] GetNpadId();
	@version(4.0.0+)
	[407] AttachAvailabilityChangeEvent();
	@version(4.0.0+)
	[408] StartDetection();
	@version(4.0.0+)
	[409] StopDetection();
	@version(4.0.0+)
	[410] GetTagInfo();
	@version(4.0.0+)
	[411] AttachActivateEvent();
	@version(4.0.0+)
	[412] AttachDeactivateEvent();
	@version(4.0.0+)
	[500] SetNfcEnabled();
	@version(4.0.0+)
	[1000] ReadMifare();
	@version(4.0.0+)
	[1001] WriteMifare();
	@version(4.0.0+)
	[1300] SendCommandByPassThrough();
	@version(4.0.0+)
	[1301] KeepPassThroughSession();
	@version(4.0.0+)
	[1302] ReleasePassThroughSession();
}

interface nn::nfc::detail::ISystemManager is nfc:sys {
	[0] CreateSystemInterface() -> object<IUnknown>;
}

interface nn::nfc::detail::IUser {
	[0] Initialize(u64, u64, pid, buffer<unknown,5,0>);
	[1] Finalize();
	[2] GetState() -> u32;
	[3] IsNfcEnabled() -> u8;
	@version(4.0.0+)
	[400] Initialize();
	@version(4.0.0+)
	[401] Finalize();
	@version(4.0.0+)
	[402] GetState();
	@version(4.0.0+)
	[403] IsNfcEnabled();
	@version(4.0.0+)
	[404] ListDevices();
	@version(4.0.0+)
	[405] GetDeviceState();
	@version(4.0.0+)
	[406] GetNpadId();
	@version(4.0.0+)
	[407] AttachAvailabilityChangeEvent();
	@version(4.0.0+)
	[408] StartDetection();
	@version(4.0.0+)
	[409] StopDetection();
	@version(4.0.0+)
	[410] GetTagInfo();
	@version(4.0.0+)
	[411] AttachActivateEvent();
	@version(4.0.0+)
	[412] AttachDeactivateEvent();
	@version(4.0.0+)
	[1000] ReadMifare();
	@version(4.0.0+)
	[1001] WriteMifare();
	@version(4.0.0+)
	[1300] SendCommandByPassThrough();
	@version(4.0.0+)
	[1301] KeepPassThroughSession();
	@version(4.0.0+)
	[1302] ReleasePassThroughSession();
}

interface nn::nfc::detail::IUserManager is nfc:user {
	[0] CreateUserInterface() -> object<IUnknown>;
}

interface nn::nfc::mifare::detail::IUser {
	[0] Initialize(u64, u64, pid, buffer<unknown,5,0>);
	[1] Finalize();
	[2] ListDevices() -> (u32, buffer<unknown,10,0>);
	[3] StartDetection(u64);
	[4] StopDetection(u64);
	[5] Read(u64, buffer<unknown,5,0>) -> buffer<unknown,6,0>;
	[6] Write(u64, buffer<unknown,5,0>);
	[7] GetTagInfo(u64) -> buffer<unknown,26,88>;
	[8] GetActivateEventHandle(u64) -> KObject;
	[9] GetDeactivateEventHandle(u64) -> KObject;
	[10] GetState() -> u32;
	[11] GetDeviceState(u64) -> u32;
	[12] GetNpadId(u64) -> u32;
	[13] GetAvailabilityChangeEventHandle() -> KObject;
}

interface nn::nfc::mifare::detail::IUserManager is nfc:mf:u {
	[0] CreateUserInterface() -> object<IUnknown>;
}

interface nn::nfp::detail::IDebug {
	[0] InitializeDebug(u64, u64, pid, buffer<unknown,5,0>);
	[1] FinalizeDebug();
	[2] ListDevices() -> (u32, buffer<unknown,10,0>);
	[3] StartDetection(u64);
	[4] StopDetection(u64);
	[5] Mount(u64, u32, u32);
	[6] Unmount(u64);
	[7] OpenApplicationArea(u64, u32);
	[8] GetApplicationArea(u64) -> (u32, buffer<unknown,6,0>);
	[9] SetApplicationArea(u64, buffer<unknown,5,0>);
	[10] Flush(u64);
	[11] Restore(u64);
	[12] CreateApplicationArea(u64, u32, buffer<unknown,5,0>);
	[13] GetTagInfo(u64) -> buffer<unknown,26,88>;
	[14] GetRegisterInfo(u64) -> buffer<unknown,26,256>;
	[15] GetCommonInfo(u64) -> buffer<unknown,26,64>;
	[16] GetModelInfo(u64) -> buffer<unknown,26,64>;
	[17] AttachActivateEvent(u64) -> KObject;
	[18] AttachDeactivateEvent(u64) -> KObject;
	[19] GetState() -> u32;
	[20] GetDeviceState(u64) -> u32;
	[21] GetNpadId(u64) -> u32;
	[22] GetApplicationArea2(u64) -> u32;
	[23] AttachAvailabilityChangeEvent() -> KObject;
	[24] RecreateApplicationArea(u64, u32, buffer<unknown,5,0>);
	[100] Format(u64);
	[101] GetAdminInfo(u64) -> buffer<unknown,26,64>;
	[102] GetRegisterInfo2(u64) -> buffer<unknown,26,256>;
	[103] SetRegisterInfo(u64, buffer<unknown,25,256>);
	[104] DeleteRegisterInfo(u64);
	[105] DeleteApplicationArea(u64);
	[106] ExistsApplicationArea(u64) -> u8;
	[200] GetAll(u64) -> buffer<unknown,26,664>;
	[201] SetAll(u64, buffer<unknown,25,664>);
	[202] FlushDebug(u64);
	[203] BreakTag(u64, u32);
	[204] ReadBackupData() -> (u32, buffer<unknown,6,0>);
	[205] WriteBackupData(buffer<unknown,5,0>);
	[206] WriteNtf(u64, u32, buffer<unknown,5,0>);
	@version(1.0.0-3.0.2)
	[300] Unknown300(u64, u64, pid, buffer<unknown,5,0>);
	@version(1.0.0-3.0.2)
	[301] Unknown301();
	@version(1.0.0-3.0.2)
	[302] Unknown302() -> (u32, buffer<unknown,10,0>);
	@version(1.0.0-3.0.2)
	[303] Unknown303(u64, u32);
	@version(1.0.0-3.0.2)
	[304] Unknown304(u64);
	@version(1.0.0-3.0.2)
	[305] Unknown305(u64, u64, buffer<unknown,5,0>) -> (u32, buffer<unknown,6,0>);
	@version(1.0.0-3.0.2)
	[306] Unknown306(u64) -> buffer<unknown,26,88>;
	@version(1.0.0-3.0.2)
	[307] Unknown307(u64) -> KObject;
	@version(1.0.0-3.0.2)
	[308] Unknown308(u64) -> KObject;
	@version(1.0.0-3.0.2)
	[309] Unknown309() -> u32;
	@version(1.0.0-3.0.2)
	[310] Unknown310(u64) -> u32;
	@version(1.0.0-3.0.2)
	[311] Unknown311(u64) -> u32;
	@version(1.0.0-3.0.2)
	[312] Unknown312(u64);
	@version(1.0.0-3.0.2)
	[313] Unknown313(u64);
	@version(1.0.0-3.0.2)
	[314] Unknown314() -> KObject;
}

interface nn::nfp::detail::IDebugManager is nfp:dbg {
	[0] CreateDebugInterface() -> object<IUnknown>;
}

interface nn::nfp::detail::ISystem {
	[0] InitializeSystem(u64, u64, pid, buffer<unknown,5,0>);
	[1] FinalizeSystem();
	[2] ListDevices() -> (u32, buffer<unknown,10,0>);
	[3] StartDetection(u64);
	[4] StopDetection(u64);
	[5] Mount(u64, u32, u32);
	[6] Unmount(u64);
	[10] Flush(u64);
	[11] Restore(u64);
	[13] GetTagInfo(u64) -> buffer<unknown,26,88>;
	[14] GetRegisterInfo(u64) -> buffer<unknown,26,256>;
	[15] GetCommonInfo(u64) -> buffer<unknown,26,64>;
	[16] GetModelInfo(u64) -> buffer<unknown,26,64>;
	[17] AttachActivateEvent(u64) -> KObject;
	[18] AttachDeactivateEvent(u64) -> KObject;
	[19] GetState() -> u32;
	[20] GetDeviceState(u64) -> u32;
	[21] GetNpadId(u64) -> u32;
	[23] AttachAvailabilityChangeEvent() -> KObject;
	[100] Format(u64);
	[101] GetAdminInfo(u64) -> buffer<unknown,26,64>;
	[102] GetRegisterInfo2(u64) -> buffer<unknown,26,256>;
	[103] SetRegisterInfo(u64, buffer<unknown,25,256>);
	[104] DeleteRegisterInfo(u64);
	[105] DeleteApplicationArea(u64);
	[106] ExistsApplicationArea(u64) -> u8;
}

interface nn::nfp::detail::ISystemManager is nfp:sys {
	[0] CreateSystemInterface() -> object<IUnknown>;
}

interface nn::nfp::detail::IUser {
	[0] Initialize(u64, u64, pid, buffer<unknown,5,0>);
	[1] Finalize();
	[2] ListDevices() -> (u32, buffer<unknown,10,0>);
	[3] StartDetection(u64);
	[4] StopDetection(u64);
	[5] Mount(u64, u32, u32);
	[6] Unmount(u64);
	[7] OpenApplicationArea(u64, u32);
	[8] GetApplicationArea(u64) -> (u32, buffer<unknown,6,0>);
	[9] SetApplicationArea(u64, buffer<unknown,5,0>);
	[10] Flush(u64);
	[11] Restore(u64);
	[12] CreateApplicationArea(u64, u32, buffer<unknown,5,0>);
	[13] GetTagInfo(u64) -> buffer<unknown,26,88>;
	[14] GetRegisterInfo(u64) -> buffer<unknown,26,256>;
	[15] GetCommonInfo(u64) -> buffer<unknown,26,64>;
	[16] GetModelInfo(u64) -> buffer<unknown,26,64>;
	[17] AttachActivateEvent(u64) -> KObject;
	[18] AttachDeactivateEvent(u64) -> KObject;
	[19] GetState() -> u32;
	[20] GetDeviceState(u64) -> u32;
	[21] GetNpadId(u64) -> u32;
	[22] GetApplicationArea2(u64) -> u32;
	[23] AttachAvailabilityChangeEvent() -> KObject;
	[24] RecreateApplicationArea(u64, u32, buffer<unknown,5,0>);
}

interface nn::nfp::detail::IUserManager is nfp:user {
	[0] CreateUserInterface() -> object<IUnknown>;
}

interface nn::nifm::detail::IGeneralService {
	[1] GetClientId() -> buffer<nn::nifm::ClientId,26,4>;
	[2] CreateScanRequest() -> object<nn::nifm::detail::IScanRequest>;
	[4] CreateRequest(i32) -> object<nn::nifm::detail::IRequest>;
	[5] GetCurrentNetworkProfile() -> buffer<nn::nifm::detail::sf::NetworkProfileData,26,380>;
	[6] EnumerateNetworkInterfaces(u32) -> (i32, array<nn::nifm::detail::sf::NetworkInterfaceInfo,10>);
	[7] EnumerateNetworkProfiles(u8) -> (i32, array<nn::nifm::detail::sf::NetworkProfileBasicInfo,6>);
	[8] GetNetworkProfile(nn::util::Uuid) -> buffer<nn::nifm::detail::sf::NetworkProfileData,26,380>;
	[9] SetNetworkProfile(buffer<nn::nifm::detail::sf::NetworkProfileData,25,380>) -> nn::util::Uuid;
	[10] RemoveNetworkProfile(nn::util::Uuid);
	@version(1.0.0-3.0.2)
	[11] GetScanData() -> (i32, array<nn::nifm::detail::sf::AccessPointData,6>);
	[12] GetCurrentIpAddress() -> nn::nifm::IpV4Address;
	@version(1.0.0-3.0.2)
	[13] GetCurrentAccessPoint() -> buffer<nn::nifm::detail::sf::AccessPointData,26,52>;
	[14] CreateTemporaryNetworkProfile(buffer<nn::nifm::detail::sf::NetworkProfileData,25,380>) -> (nn::util::Uuid, object<nn::nifm::detail::INetworkProfile>);
	[15] GetCurrentIpConfigInfo() -> (nn::nifm::IpAddressSetting, align<1,nn::nifm::DnsSetting>);
	[16] SetWirelessCommunicationEnabled(bool);
	[17] IsWirelessCommunicationEnabled() -> bool;
	[18] GetInternetConnectionStatus() -> nn::nifm::detail::sf::InternetConnectionStatus;
	[19] SetEthernetCommunicationEnabled(bool);
	[20] IsEthernetCommunicationEnabled() -> bool;
	[21] IsAnyInternetRequestAccepted(buffer<nn::nifm::ClientId,25,4>) -> bool;
	[22] IsAnyForegroundRequestAccepted() -> bool;
	[23] PutToSleep();
	[24] WakeUp();
	[25] GetSsidListVersion() -> nn::nifm::SsidListVersion;
	[26] SetExclusiveClient(buffer<nn::nifm::ClientId,25,4>);
	[27] GetDefaultIpSetting() -> buffer<nn::nifm::IpSettingData,26,194>;
	[28] SetDefaultIpSetting(buffer<nn::nifm::IpSettingData,25,194>);
	[29] SetWirelessCommunicationEnabledForTest(bool);
	[30] SetEthernetCommunicationEnabledForTest(bool);
	@version(2.0.0+)
	[31] GetTelemetorySystemEventReadableHandle() -> KObject;
	@version(2.0.0+)
	[32] GetTelemetryInfo() -> buffer<nn::nifm::TelemetryInfo,22,524>;
	@version(2.0.0+)
	[33] ConfirmSystemAvailability();
	@version(4.0.0+)
	[34] SetBackgroundRequestEnabled();
	@version(4.0.0+)
	[35] GetScanData();
	@version(4.0.0+)
	[36] GetCurrentAccessPoint();
	@version(4.0.0+)
	[37] Shutdown();
}

interface nn::nifm::detail::INetworkProfile {
	[0] Update(buffer<nn::nifm::detail::sf::NetworkProfileData,25,380>) -> nn::util::Uuid;
	@version(1.0.0-2.3.0)
	[1] Persist(nn::util::Uuid) -> nn::util::Uuid;
	@version(3.0.0+)
	[2] Persist() -> nn::util::Uuid;
}

interface nn::nifm::detail::IRequest {
	[0] GetRequestState() -> i32;
	[1] GetResult();
	[2] GetSystemEventReadableHandles() -> (KObject, KObject);
	[3] Cancel();
	[4] Submit();
	[5] SetRequirement(nn::nifm::Requirement);
	[6] SetRequirementPreset(i32);
	[8] SetPriority(u8);
	[9] SetNetworkProfileId(nn::util::Uuid);
	[10] SetRejectable(bool);
	[11] SetConnectionConfirmationOption(i8);
	[12] SetPersistent(bool);
	[13] SetInstant(bool);
	[14] SetSustainable(bool, u8);
	[15] SetRawPriority(u8);
	[16] SetGreedy(bool);
	[17] SetSharable(bool);
	[18] SetRequirementByRevision(u32);
	[19] GetRequirement() -> nn::nifm::Requirement;
	[20] GetRevision() -> u32;
	[21] GetAppletInfo(u32) -> (u32, u32, u32, buffer<unknown,6,0>);
	[22] GetAdditionalInfo() -> (u32, buffer<nn::nifm::AdditionalInfo,22,1040>);
	[23] SetKeptInSleep(bool);
	[24] RegisterSocketDescriptor(i32);
	[25] UnregisterSocketDescriptor(i32);
}

interface nn::nifm::detail::IScanRequest {
	[0] Submit();
	[1] IsProcessing() -> bool;
	[2] GetResult();
	[3] GetSystemEventReadableHandle() -> KObject;
}

interface nn::nifm::detail::IStaticService is nifm:a, nifm:s, nifm:u {
	@version(1.0.0-2.3.0)
	[4] CreateGeneralService() -> object<nn::nifm::detail::IGeneralService>;
	@version(3.0.0+)
	[5] CreateGeneralService(u64, pid) -> object<nn::nifm::detail::IGeneralService>;
}

interface nn::nim::detail::INetworkInstallManager is nim {
	@undocumented
	[0] CreateSystemUpdateTask();
	# Takes a 0x10-byte input struct, from the output of ListSystemUpdateTask.
	# 
	[1] DestroySystemUpdateTask(u128);
	# Takes a type-0x6 output buffer, for an array of 0x10-byte entries. Returns an u32 for total output entries.
	# 
	# Doesn't return anything on a v2.1 system where sysupdate domains are blocked.
	# 
	[2] ListSystemUpdateTask() -> (u32, buffer<unknown,6,0>);
	@undocumented
	[3] RequestSystemUpdateTaskRun();
	@undocumented
	[4] GetSystemUpdateTaskInfo();
	[5] CommitSystemUpdateTask(u128);
	@undocumented
	[6] CreateNetworkInstallTask();
	[7] DestroyNetworkInstallTask(u128);
	[8] ListNetworkInstallTask() -> (u32, buffer<unknown,6,0>);
	@undocumented
	[9] RequestNetworkInstallTaskRun();
	@undocumented
	[10] GetNetworkInstallTaskInfo();
	[11] CommitNetworkInstallTask(u128);
	@undocumented
	[12] RequestLatestSystemUpdateMeta();
	@undocumented
	[14] ListApplicationNetworkInstallTask();
	@undocumented
	[15] ListNetworkInstallTaskContentMeta();
	@undocumented
	[16] RequestLatestVersion();
	@undocumented
	[17] SetNetworkInstallTaskAttribute();
	@undocumented
	[18] AddNetworkInstallTaskContentMeta();
	@undocumented
	[19] GetDownloadedSystemDataPath();
	@undocumented
	[20] CalculateNetworkInstallTaskRequiredSize();
	@undocumented
	[21] IsExFatDriverIncluded();
	[22] GetBackgroundDownloadStressTaskInfo() -> u128;
	@version(2.0.0+)
	@undocumented
	[23] RequestDeviceAuthenticationToken();
	@version(2.0.0+)
	@undocumented
	[24] RequestGameCardRegistrationStatus();
	@version(2.0.0+)
	@undocumented
	[25] RequestRegisterGameCard();
	@version(2.0.0+)
	@undocumented
	[26] RequestRegisterNotificationToken();
	@version(2.0.0+)
	@undocumented
	[27] RequestDownloadTaskList();
	@version(2.0.0+)
	@undocumented
	[28] RequestApplicationControl();
	@version(2.0.0+)
	@undocumented
	[29] RequestLatestApplicationControl();
	@version(2.0.0+)
	@undocumented
	[30] RequestVersionList();
	@version(2.0.0+)
	@undocumented
	[31] CreateApplyDeltaTask();
	@version(2.0.0+)
	[32] DestroyApplyDeltaTask(u128);
	@version(2.0.0+)
	@undocumented
	[33] ListApplicationApplyDeltaTask();
	@version(2.0.0+)
	@undocumented
	[34] RequestApplyDeltaTaskRun();
	@version(2.0.0+)
	@undocumented
	[35] GetApplyDeltaTaskInfo();
	@version(2.0.0+)
	@undocumented
	[36] ListApplyDeltaTask();
	@version(2.0.0+)
	[37] CommitApplyDeltaTask(u128);
	@version(2.0.0+)
	@undocumented
	[38] CalculateApplyDeltaTaskRequiredSize();
	@version(2.0.0+)
	[39] PrepareShutdown();
	@version(2.0.0+)
	[40] ListApplyDeltaTask() -> (u32, buffer<unknown,6,0>);
	@version(2.0.0+)
	[41] ClearNotEnoughSpaceStateOfApplyDeltaTask(u128);
	@version(3.0.0+)
	@undocumented
	[42] Unknown42();
	@version(3.0.0+)
	[43] Unknown43() -> u128;
	@version(3.0.0+)
	@undocumented
	[44] Unknown44();
	@version(3.0.0+)
	@undocumented
	[45] Unknown45();
	@version(3.0.0+)
	[46] Unknown46();
}

interface nn::nim::detail::IShopServiceManager is nim:shp {
	@undocumented
	[0] RequestDeviceAuthenticationToken();
	@undocumented
	[1] RequestCachedDeviceAuthenticationToken();
	@undocumented
	[100] RequestRegisterDeviceAccount();
	@undocumented
	[101] RequestUnregisterDeviceAccount();
	@undocumented
	[102] RequestDeviceAccountStatus();
	[103] GetDeviceAccountInfo() -> bytes<32>;
	@undocumented
	[104] RequestDeviceRegistrationInfo();
	@undocumented
	[105] RequestTransferDeviceAccount();
	@undocumented
	[106] RequestSyncRegistration();
	[107] IsOwnDeviceId(u64) -> u8;
	@undocumented
	[200] RequestRegisterNotificationToken();
	@undocumented
	[300] RequestUnlinkDevice();
	@undocumented
	[301] RequestUnlinkDeviceIntegrated();
	@undocumented
	[302] RequestLinkDevice();
	@undocumented
	[303] HasDeviceLink();
	[304] RequestUnlinkDeviceAll();
	[305] RequestCreateVirtualAccount();
	[306] RequestDeviceLinkStatus();
	@undocumented
	[400] GetAccountByVirtualAccount();
	@undocumented
	[500] RequestSyncTicket();
	@undocumented
	[501] RequestDownloadTicket();
	@version(4.0.0+)
	[502] RequestDownloadTicketForPrepurchasedContents();
}

interface nn::npns::INpnsSystem is npns:s {
	[1] Unknown1();
	[2] Unknown2(u64);
	@undocumented
	[3] Unknown3();
	@undocumented
	[4] Unknown4();
	[5] Unknown5() -> KObject;
	[6] Unknown6();
	[7] Unknown7() -> KObject;
	@undocumented
	[11] Unknown11();
	@undocumented
	[12] Unknown12();
	@undocumented
	[13] Unknown13();
	@undocumented
	[21] Unknown21();
	@undocumented
	[22] Unknown22();
	@undocumented
	[23] Unknown23();
	@undocumented
	[24] Unknown24();
	@undocumented
	[25] Unknown25();
	@undocumented
	[31] Unknown31();
	@undocumented
	[32] Unknown32();
	[101] Unknown101();
	[102] Unknown102();
	[103] Unknown103() -> u32;
	[104] Unknown104() -> buffer<unknown,6,0>;
	[105] Unknown105() -> KObject;
	@undocumented
	[111] Unknown111();
	[112] Unknown112();
	[113] Unknown113();
	@undocumented
	[114] Unknown114();
	@undocumented
	[115] Unknown115();
	@undocumented
	[201] Unknown201();
	[202] Unknown202(u32);
}

interface nn::npns::INpnsUser is npns:u {
	[1] Unknown1();
	[2] Unknown2(u64);
	@undocumented
	[3] Unknown3();
	@undocumented
	[4] Unknown4();
	[5] Unknown5() -> KObject;
	[7] Unknown7() -> KObject;
	@undocumented
	[21] Unknown21();
	@undocumented
	[23] Unknown23();
	@undocumented
	[25] Unknown25();
	[101] Unknown101();
	[102] Unknown102();
	[103] Unknown103() -> u32;
	[104] Unknown104() -> buffer<unknown,6,0>;
	@undocumented
	[111] Unknown111();
}

interface nn::ns::detail::IAccountProxyInterface {
	@undocumented
	[0] CreateUserAccount();
}

interface nn::ns::detail::IApplicationManagerInterface is ns:am {
	# Takes a type-6 output buffer and an u64.
	# 
	# Returns an array of title-info entries using the specified offset and size. No input titleID is passed to this.
	# 
	@undocumented
	[0] ListApplicationRecord();
	[1] GenerateApplicationRecordCount() -> u64;
	[2] GetApplicationRecordUpdateSystemEvent() -> KObject;
	@undocumented
	[3] GetApplicationViewDeprecated();
	[4] DeleteApplicationEntity(u64);
	[5] DeleteApplicationCompletely(u64);
	[6] IsAnyApplicationEntityRedundant() -> u8;
	[7] DeleteRedundantApplicationEntity();
	@undocumented
	[8] IsApplicationEntityMovable();
	[9] MoveApplicationEntity(u8, u64);
	@undocumented
	[11] CalculateApplicationOccupiedSize();
	@undocumented
	[16] PushApplicationRecord();
	@undocumented
	[17] ListApplicationRecordContentMeta();
	# Takes an input u64 titleID, returns an output u64 PID.
	# 
	# Launches an application title which is registered with NS.
	# 
	[19] LaunchApplication(u64) -> u64;
	# Takes a 0x16-type output buffer, an u8 [type](http://switchbrew.org/index.php?title=NCA "wikilink"), and an u64 titleID.
	# 
	# The input titleID is used with the application-title table like various other cmds, anything not in that table can't be used with this.
	# 
	# Returns a string path for the specified type of patch content with this titleID, otherwise returns regular-application paths when update-title not installed. Returns an error when the specified type of content doesn't exist for this title. Starts with @{SdCardContent,UserContent}:// and ends in .nca.
	# 
	# For gamecard content, the output path is: @GcSXXXXXXXX:/<NcaId>.nca. NCA-type0 with gamecard returns 0 with an empty output string.
	# 
	# The output string is then used by the user-process with [FS](http://switchbrew.org/index.php?title=Filesystem_services "wikilink") to mount the content.
	# 
	@undocumented
	[21] GetApplicationContentPath();
	[22] TerminateApplication(u64);
	[23] ResolveApplicationContentPath(u8, u64);
	@undocumented
	[26] BeginInstallApplication();
	[27] DeleteApplicationRecord(u64);
	@undocumented
	[30] RequestApplicationUpdateInfo();
	[32] CancelApplicationDownload(u64);
	[33] ResumeApplicationDownload(u64);
	[35] UpdateVersionList(buffer<unknown,5,0>);
	[36] PushLaunchVersion(u32, u64);
	[37] ListRequiredVersion() -> (u32, buffer<unknown,6,0>);
	[38] CheckApplicationLaunchVersion(u64);
	[39] CheckApplicationLaunchRights(u64);
	@undocumented
	[40] GetApplicationLogoData();
	@undocumented
	[41] CalculateApplicationDownloadRequiredSize();
	[42] CleanupSdCard();
	[43] CheckSdCardMountStatus();
	[44] GetSdCardMountStatusChangedEvent() -> KObject;
	[45] GetGameCardAttachmentEvent() -> KObject;
	[46] GetGameCardAttachmentInfo() -> u128;
	# Takes an input media-id that must be 5.
	# 
	# Returns the u64 from [Content\_Manager\_services\#IContentStorage](http://switchbrew.org/index.php?title=Content_Manager_services#IContentStorage "wikilink") cmd22.
	# 
	@undocumented
	[47] GetTotalSpaceSize();
	# Takes an input media-id that must be 5.
	# 
	# Returns the u64 from [Content\_Manager\_services\#IContentStorage](http://switchbrew.org/index.php?title=Content_Manager_services#IContentStorage "wikilink") cmd23.
	# 
	@undocumented
	[48] GetFreeSpaceSize();
	[49] GetSdCardRemovedEvent() -> KObject;
	[52] GetGameCardUpdateDetectionEvent() -> KObject;
	[53] DisableApplicationAutoDelete(u64);
	[54] EnableApplicationAutoDelete(u64);
	[55] GetApplicationDesiredLanguage(u32) -> u8;
	[56] SetApplicationTerminateResult(u32, u64);
	[57] ClearApplicationTerminateResult(u64);
	[58] GetLastSdCardMountUnexpectedResult();
	@undocumented
	[59] ConvertApplicationLanguageToLanguageCode();
	# Takes an input u8 pointer for the resulting Id to be written to and a string represented as a u64 (i.e 0x53552D6E65 for 'en-US').
	# 
	# Returns 0 if an ID was successfully found, otherwise returns 0x25810.
	# 
	@undocumented
	[60] ConvertLanguageCodeToApplicationLanguage();
	[61] GetBackgroundDownloadStressTaskInfo() -> u128;
	[62] GetGameCardStopper() -> object<IUnknown>;
	[63] IsSystemProgramInstalled(u64) -> u8;
	[64] StartApplyDeltaTask(u64);
	[65] GetRequestServerStopper() -> object<IUnknown>;
	[66] GetBackgroundApplyDeltaStressTaskInfo() -> u128;
	[67] CancelApplicationApplyDelta(u64);
	[68] ResumeApplicationApplyDelta(u64);
	@undocumented
	[69] CalculateApplicationApplyDeltaRequiredSize();
	[70] ResumeAll();
	@undocumented
	[71] GetStorageSize();
	@undocumented
	[80] RequestDownloadApplication();
	@undocumented
	[81] RequestDownloadAddOnContent();
	@undocumented
	[82] DownloadApplication();
	[83] CheckApplicationResumeRights();
	[84] GetDynamicCommitEvent();
	[85] RequestUpdateApplication2();
	[86] EnableApplicationCrashReport();
	[87] IsApplicationCrashReportEnabled();
	[90] BoostSystemMemoryResourceLimit();
	[100] ResetToFactorySettings();
	[101] ResetToFactorySettingsWithoutUserSaveData();
	[102] ResetToFactorySettingsForRefurbishment();
	@undocumented
	[200] CalculateUserSaveDataStatistics();
	@undocumented
	[201] DeleteUserSaveDataAll();
	@undocumented
	[210] DeleteUserSystemSaveData();
	@undocumented
	[220] UnregisterNetworkServiceAccount();
	[300] GetApplicationShellEvent() -> KObject;
	[301] PopApplicationShellEventInfo() -> (u32, buffer<unknown,6,0>);
	[302] LaunchLibraryApplet(u64) -> u64;
	[303] TerminateLibraryApplet(u64);
	[304] LaunchSystemApplet() -> u64;
	[305] TerminateSystemApplet(u64);
	[306] LaunchOverlayApplet() -> u64;
	[307] TerminateOverlayApplet(u64);
	@undocumented
	[400] GetApplicationControlData();
	[401] InvalidateAllApplicationControlCache();
	@undocumented
	[402] RequestDownloadApplicationControlData();
	[403] GetMaxApplicationControlCacheCount() -> u32;
	[404] InvalidateApplicationControlCache(u64);
	[405] ListApplicationControlCacheEntryInfo() -> (u32, buffer<unknown,6,0>);
	@undocumented
	[502] RequestCheckGameCardRegistration();
	@undocumented
	[503] RequestGameCardRegistrationGoldPoint();
	@undocumented
	[504] RequestRegisterGameCard();
	[505] GetGameCardMountFailureEvent() -> KObject;
	[506] IsGameCardInserted() -> u8;
	[507] EnsureGameCardAccess();
	[508] GetLastGameCardMountFailureResult();
	[509] ListApplicationIdOnGameCard();
	[600] CountApplicationContentMeta(u64) -> u32;
	# Returns 0x10-byte entries using the specified titleID starting at the specified u32 entryindex. Can only return game titles. The second entry if any is the update-title usually. When the input entryindex is &gt;= totalentries, this will return 0 with out\_entrycount=0.
	# 
	# Entry structure:
	# 
	# | Offset | Size | Description                                                                |                                            |
	# |--------|------|----------------------------------------------------------------------------|--------------------------------------------|
	# | 0x0    | 0x1  | u8 type. \[\[Content\_Manager\_services                                  | Title type\]\] (String is from web-applet) |
	# | 0x1    | 0x1  | u8 installedStorage / \[\[Filesystem\_services                           | StorageId\]\] (String is from web-applet)  |
	# | 0x2    | 0x1  | Unknown. Non-zero with output from cmd 605, differs for app/update titles. |                                            |
	# | 0x3    | 0x1  | Padding                                                                    |                                            |
	# | 0x4    | 0x4  | u32 Title-version                                                          |                                            |
	# | 0x8    | 0x8  | u64 titleID                                                                |                                            |
	# 
	@undocumented
	[601] ListApplicationContentMetaStatus();
	@undocumented
	[602] ListAvailableAddOnContent();
	@undocumented
	[603] GetOwnedApplicationContentMetaStatus();
	[604] RegisterContentsExternalKey(u64, u64);
	@undocumented
	[605] ListApplicationContentMetaStatusWithRightsCheck();
	@undocumented
	[606] GetContentMetaStorage();
	[700] PushDownloadTaskList(buffer<unknown,5,0>);
	[701] ClearTaskStatusList();
	[702] RequestDownloadTaskList();
	@undocumented
	[703] RequestEnsureDownloadTask();
	[704] ListDownloadTaskStatus() -> (u32, buffer<unknown,6,0>);
	@undocumented
	[705] RequestDownloadTaskListData();
	[800] RequestVersionList();
	[801] ListVersionList() -> (u32, buffer<unknown,6,0>);
	@undocumented
	[802] RequestVersionListData();
	@undocumented
	[900] GetApplicationRecord();
	@undocumented
	[901] GetApplicationRecordProperty();
	[902] EnableApplicationAutoUpdate(u64);
	[903] DisableApplicationAutoUpdate(u64);
	[904] TouchApplication(u64);
	[905] RequestApplicationUpdate(u32, u64);
	@undocumented
	[906] IsApplicationUpdateRequested();
	[907] WithdrawApplicationUpdateRequest(u64);
	@undocumented
	[908] ListApplicationRecordInstalledContentMeta();
	[909] WithdrawCleanupAddOnContentsWithNoRightsRecommendation(u64);
	@undocumented
	[1000] RequestVerifyApplicationDeprecated();
	@undocumented
	[1001] CorruptApplicationForDebug();
	@undocumented
	[1002] RequestVerifyAddOnContentsRights();
	[1003] RequestVerifyApplication();
	[1004] CorruptContentForDebug();
	[1200] NeedsUpdateVulnerability() -> u8;
	[1300] IsAnyApplicationEntityInstalled(u64) -> u8;
	@undocumented
	[1301] DeleteApplicationContentEntities();
	[1302] CleanupUnrecordedApplicationEntity(u64);
	[1303] CleanupAddOnContentsWithNoRights(u64);
	@undocumented
	[1304] DeleteApplicationContentEntity();
	[1305] TryDeleteRunningApplicationEntity();
	[1306] TryDeleteRunningApplicationCompletely();
	[1307] TryDeleteRunningApplicationContentEntities();
	[1400] PrepareShutdown();
	[1500] FormatSdCard();
	[1501] NeedsSystemUpdateToFormatSdCard() -> u8;
	[1502] GetLastSdCardFormatUnexpectedResult();
	[1504] InsertSdCard();
	[1505] RemoveSdCard();
	[1600] GetSystemSeedForPseudoDeviceId() -> bytes<32>;
	[1601] ResetSystemSeedForPseudoDeviceId();
	@undocumented
	[1700] ListApplicationDownloadingContentMeta();
	@undocumented
	[1701] GetApplicationView();
	[1702] GetApplicationDownloadTaskStatus(u64) -> u8;
	[1703] GetApplicationViewDownloadErrorContext();
	[1800] IsNotificationSetupCompleted() -> u8;
	[1801] GetLastNotificationInfoCount() -> u64;
	[1802] ListLastNotificationInfo() -> (u32, buffer<unknown,6,0>);
	[1803] ListNotificationTask() -> (u32, buffer<unknown,6,0>);
	[1900] IsActiveAccount(u32) -> u8;
	[1901] RequestDownloadApplicationPrepurchasedRights();
	[1902] GetApplicationTicketInfo();
	[2000] GetSystemDeliveryInfo();
	[2001] SelectLatestSystemDeliveryInfo();
	[2002] VerifyDeliveryProtocolVersion();
	[2003] GetApplicationDeliveryInfo();
	[2004] HasAllContentsToDeliver();
	[2005] CompareApplicationDeliveryInfo();
	[2006] CanDeliverApplication();
	[2007] ListContentMetaKeyToDeliverApplication();
	[2008] NeedsSystemUpdateToDeliverApplication();
	[2009] EstimateRequiredSize();
	[2010] RequestReceiveApplication();
	[2011] CommitReceiveApplication();
	[2012] GetReceiveApplicationProgress();
	[2013] RequestSendApplication();
	[2014] GetSendApplicationProgress();
	[2015] CompareSystemDeliveryInfo();
	[2016] ListNotCommittedContentMeta();
	[2017] CreateDownloadTask();
}

interface nn::ns::detail::IContentManagementInterface {
	@undocumented
	[11] CalculateApplicationOccupiedSize();
	[43] CheckSdCardMountStatus();
	@undocumented
	[47] GetTotalSpaceSize();
	@undocumented
	[48] GetFreeSpaceSize();
	[600] CountApplicationContentMeta(u64) -> u32;
	@undocumented
	[601] ListApplicationContentMetaStatus();
	@undocumented
	[605] ListApplicationContentMetaStatusWithRightsCheck();
	[607] IsAnyApplicationRunning() -> u8;
}

interface nn::ns::detail::IDevelopInterface is ns:dev {
	# Wrapper for pm:shell [LaunchProcess](http://switchbrew.org/index.php?title=Process_Manager_services#LaunchProcess "wikilink").
	# 
	@undocumented
	[0] LaunchProgram();
	# Wrapper for pm:shell [TerminateTitleByPid](http://switchbrew.org/index.php?title=Process_Manager_services#TerminateTitleByPid "wikilink").
	# 
	@undocumented
	[1] TerminateProcess();
	# Wrapper for pm:shell [TerminateTitleByTitleId](http://switchbrew.org/index.php?title=Process_Manager_services#TerminateTitleByTitleId "wikilink").
	# 
	@undocumented
	[2] TerminateProgram();
	# Wrapper for pm:shell [GetProcessEventWaiter](http://switchbrew.org/index.php?title=Process_Manager_services#GetProcessEventWaiter "wikilink").
	# 
	[3] GetShellEventHandle();
	# Wrapper for pm:shell [GetProcessEventType](http://switchbrew.org/index.php?title=Process_Manager_services#GetProcessEventType "wikilink").
	# 
	@undocumented
	[4] GetShellEventInfo();
	# Calls pm:shell [GetCrashingProcessPid](http://switchbrew.org/index.php?title=Process_Manager_services#GetCrashingProcessPid "wikilink") and sends PID to [TerminateTitleByPid](http://switchbrew.org/index.php?title=Process_Manager_services#TerminateTitleByPid "wikilink").
	# 
	@undocumented
	[5] TerminateApplication();
	# Calls [IPathResolverForStorage](http://switchbrew.org/index.php?title=NCM_services#IPathResolverForStorage "wikilink") Set...NcaPath functions.
	# 
	# [Category:Services](http://switchbrew.org/index.php?title=Category:Services "wikilink")
	# 
	[6] PrepareLaunchProgramFromHost();
	@undocumented
	[7] LaunchApplication();
	@undocumented
	[8] LaunchApplicationWithStorageId();
}

interface nn::ns::detail::IDocumentInterface {
	@undocumented
	[21] GetApplicationContentPath();
	[23] ResolveApplicationContentPath(u8, u64);
}

interface nn::ns::detail::IDownloadTaskInterface {
	[701] ClearTaskStatusList();
	[702] RequestDownloadTaskList();
	@undocumented
	[703] RequestEnsureDownloadTask();
	[704] ListDownloadTaskStatus() -> (u32, buffer<unknown,6,0>);
	@undocumented
	[705] RequestDownloadTaskListData();
	[706] TryCommitCurrentApplicationDownloadTask();
	[707] EnableAutoCommit();
	[708] DisableAutoCommit();
	[709] TriggerDynamicCommitEvent();
}

interface nn::ns::detail::IFactoryResetInterface {
	[100] ResetToFactorySettings();
	[101] ResetToFactorySettingsWithoutUserSaveData();
	[102] ResetToFactorySettingsForRefurbishment();
}

interface nn::ns::detail::IServiceGetterInterface is ns:rid, ns:web, ns:ec, ns:am2, ns:rt {
	[7992] GetECommerceInterface();
	[7993] GetApplicationVersionInterface();
	[7994] GetFactoryResetInterface() -> object<IUnknown>;
	[7995] GetAccountProxyInterface() -> object<IUnknown>;
	[7996] GetApplicationManagerInterface() -> object<IUnknown>;
	[7997] GetDownloadTaskInterface() -> object<IUnknown>;
	[7998] GetContentManagementInterface() -> object<IUnknown>;
	[7999] GetDocumentInterface() -> object<IUnknown>;
}

interface nn::ns::detail::ISystemUpdateInterface is ns:su {
	[0] GetBackgroundNetworkUpdateState() -> u8;
	[1] OpenSystemUpdateControl() -> object<IUnknown>;
	[2] NotifyExFatDriverRequired();
	[3] ClearExFatDriverStatusForDebug();
	[4] RequestBackgroundNetworkUpdate();
	@undocumented
	[5] NotifyBackgroundNetworkUpdate();
	[6] NotifyExFatDriverDownloadedForDebug();
	[9] GetSystemUpdateNotificationEventForContentDelivery() -> KObject;
	[10] NotifySystemUpdateForContentDelivery();
	[11] PrepareShutdown();
	[16] DestroySystemUpdateTask();
	[17] RequestSendSystemUpdate();
	[18] GetSendSystemUpdateProgress();
}

interface nn::ns::detail::IVulnerabilityManagerInterface is ns:vm {
	@version(3.0.0+)
	[1200] NeedsUpdateVulnerability() -> u8;
	@version(4.0.0+)
	[1201] UpdateSafeSystemVersionForDebug();
	@version(4.0.0+)
	[1202] GetSafeSystemVersion();
}

interface nn::nsd::detail::IManager is nsd:a, nsd:u {
	[10] GetSettingName() -> buffer<unknown,22,256>;
	# Takes a type-0x16 buffer with size 8. Returns a string.
	# 
	# The output string is used by [NIM](http://switchbrew.org/index.php?title=NIM_services "wikilink") for the eid:%s in the User-Agent strings.
	# 
	# This is the lp1 string also used in domains.
	# 
	[11] GetEnvironmentIdentifier() -> buffer<unknown,22,8>;
	[12] GetDeviceId() -> u128;
	[13] DeleteSettings(u32);
	[14] ImportSettings(u32, buffer<unknown,5,0>) -> buffer<unknown,6,0>;
	[20] Resolve(buffer<unknown,21,256>) -> buffer<unknown,22,256>;
	[21] ResolveEx(buffer<unknown,21,256>) -> (u32, buffer<unknown,22,256>);
	[30] GetNasServiceSetting(buffer<unknown,21,16>) -> buffer<unknown,22,264>;
	[31] GetNasServiceSettingEx(buffer<unknown,21,16>) -> (u32, buffer<unknown,22,264>);
	[40] GetNasRequestFqdn() -> buffer<unknown,22,256>;
	[41] GetNasRequestFqdnEx() -> (u32, buffer<unknown,22,256>);
	[42] GetNasApiFqdn() -> buffer<unknown,22,256>;
	[43] GetNasApiFqdnEx() -> (u32, buffer<unknown,22,256>);
	[50] GetCurrentSetting() -> buffer<unknown,22,76784>;
	# Requires the `nsd!test_mode` setting to be equal to 1.
	# 
	# Mounts the system save data for bsdsockets as `nsdsave` and reads from `nsd:/file` to the specified buffer, at the specified size and offset with no checks whatsoever. `nsdsave` is then unmounted.
	# 
	[60] ReadSaveDataFromFsForTest() -> buffer<unknown,22,76784>;
	# Requires the `nsd!test_mode` setting to be equal to 1.
	# 
	# Mounts the system save data for bsdsockets as `nsdsave` and writes to `nsd:/file` (appending is allowed) using the specified buffer, at the specified size and offset, with no checks whatsoever. `nsdsave` is then commited and unmounted.
	# 
	[61] WriteSaveDataToFsForTest(buffer<unknown,21,76784>);
	# Requires the `nsd!test_mode` setting to be equal to 1.
	# 
	# Deletes the system save data for bsdsockets.
	# 
	# [Category:Services](http://switchbrew.org/index.php?title=Category:Services "wikilink")
	# 
	[62] DeleteSaveDataOfFsForTest();
}

interface nn::ntc::detail::service::IEnsureNetworkClockAvailabilityService {
	[0] StartTask();
	[1] GetFinishNotificationEvent() -> KObject;
	[2] GetResult();
	[3] Cancel();
	[4] IsProcessing() -> u8;
	[5] GetServerTime() -> u64;
}

interface nn::ntc::detail::service::IStaticService is ntc {
	[0] OpenEnsureNetworkClockAvailabilityService(u32, u32) -> object<IUnknown>;
	[100] SuspendAutonomicTimeCorrection();
	[101] ResumeAutonomicTimeCorrection();
}

interface nn::omm::detail::IOperationModeManager is omm {
	[0] GetOperationMode() -> u8;
	[1] GetOperationModeChangeEvent() -> KObject;
	[2] EnableAudioVisual();
	[3] DisableAudioVisual();
	@undocumented
	[4] EnterSleepAndWait();
	[5] GetCradleStatus() -> u8;
	[6] FadeInDisplay();
	[7] FadeOutDisplay();
	@version(2.0.0+)
	@undocumented
	[8] Unknown8();
	@version(2.0.0+)
	[9] Unknown9();
	@version(3.0.0+)
	[10] Unknown10(u8);
	@version(3.0.0+)
	@undocumented
	[11] Unknown11();
	@version(3.0.0+)
	[12] Unknown12() -> KObject;
	@version(3.0.0+)
	[13] Unknown13();
	@version(3.0.0+)
	[14] Unknown14() -> u8;
	@version(4.0.0+)
	[15] Unknown15();
	@version(4.0.0+)
	[16] Unknown16();
	@version(4.0.0+)
	[17] Unknown17();
	@version(4.0.0+)
	[18] Unknown18();
	@version(4.0.0+)
	[19] Unknown19();
	@version(4.0.0+)
	[20] Unknown20();
	@version(4.0.0+)
	[21] Unknown21();
	@version(4.0.0+)
	[22] Unknown22();
	@version(4.0.0+)
	[23] Unknown23();
}

interface nn::pcie::detail::IManager is pcie {
	# Takes the current process handle (0xFFFF8001).
	# 
	# Returns an event handle and session handle to a [\#ISession](#nn::pcie::detail::ISession "wikilink").
	# 
	@undocumented
	[0] RegisterClassDriver();
	# Takes a type-6 buffer.
	# 
	# Returns a list of connected PCIe endpoint devices.
	# 
	@undocumented
	[1] QueryFunctionsUnregistered();
}

interface nn::pcie::detail::ISession {
	@undocumented
	[0] QueryFunctions();
	@undocumented
	[1] AcquireFunction();
	[2] ReleaseFunction(u32);
	@undocumented
	[3] GetFunctionState();
	@undocumented
	[4] GetBarProfile();
	@undocumented
	[5] ReadConfig();
	@undocumented
	[6] WriteConfig();
	@undocumented
	[7] ReadBarRegion();
	@undocumented
	[8] WriteBarRegion();
	@undocumented
	[9] FindCapability();
	@undocumented
	[10] FindExtendedCapability();
	@undocumented
	[11] MapDma();
	@undocumented
	[12] UnmapDma();
	@undocumented
	[13] UnmapDmaBusAddress();
	@undocumented
	[14] GetDmaBusAddress();
	@undocumented
	[15] GetDmaBusAddressRange();
	[16] SetDmaEnable(u8, u32);
	@undocumented
	[17] AcquireIrq();
	[18] ReleaseIrq(u32);
	@undocumented
	[19] SetIrqEnable();
	[20] SetAspmEnable(u8, u32);
}

interface nn::pctl::detail::ipc::IParentalControlService {
	@version(4.0.0+)
	[1] Initialize();
	[1001] CheckFreeCommunicationPermission();
	[1002] ConfirmLaunchApplicationPermission(bool, nn::ncm::ApplicationId, array<i8,9>);
	[1003] ConfirmResumeApplicationPermission(bool, nn::ncm::ApplicationId, array<i8,9>);
	[1004] ConfirmSnsPostPermission();
	[1005] ConfirmSystemSettingsPermission();
	[1006] IsRestrictionTemporaryUnlocked() -> bool;
	[1007] RevertRestrictionTemporaryUnlocked();
	[1008] EnterRestrictedSystemSettings();
	[1009] LeaveRestrictedSystemSettings();
	[1010] IsRestrictedSystemSettingsEntered() -> bool;
	[1011] RevertRestrictedSystemSettingsEntered();
	[1012] GetRestrictedFeatures() -> i32;
	@version(4.0.0+)
	[1013] ConfirmStereoVisionPermission();
	@version(5.0.0+)
	[1014] ConfirmPlayableApplicationVideoOld();
	@version(5.0.0+)
	[1015] ConfirmPlayableApplicationVideo();
	[1031] IsRestrictionEnabled() -> bool;
	[1032] GetSafetyLevel() -> i32;
	[1033] SetSafetyLevel(i32);
	[1034] GetSafetyLevelSettings(i32) -> nn::pctl::SafetyLevelSettings;
	[1035] GetCurrentSettings() -> nn::pctl::SafetyLevelSettings;
	[1036] SetCustomSafetyLevelSettings(nn::pctl::SafetyLevelSettings);
	[1037] GetDefaultRatingOrganization() -> i32;
	[1038] SetDefaultRatingOrganization(i32);
	[1039] GetFreeCommunicationApplicationListCount() -> i32;
	[1042] AddToFreeCommunicationApplicationList(nn::ncm::ApplicationId);
	[1043] DeleteSettings();
	[1044] GetFreeCommunicationApplicationList(i32) -> (i32, array<nn::pctl::FreeCommunicationApplicationInfo,6>);
	[1045] UpdateFreeCommunicationApplicationList(array<nn::pctl::FreeCommunicationApplicationInfo,5>);
	[1046] DisableFeaturesForReset();
	[1047] NotifyApplicationDownloadStarted(nn::ncm::ApplicationId);
	@version(4.0.0+)
	[1061] ConfirmStereoVisionRestrictionConfigurable();
	@version(4.0.0+)
	[1062] GetStereoVisionRestriction();
	@version(4.0.0+)
	[1063] SetStereoVisionRestriction();
	@version(5.0.0+)
	[1064] ResetConfirmedStereoVisionPermission();
	@version(5.0.0+)
	[1065] IsStereoVisionPermitted();
	[1201] UnlockRestrictionTemporarily(array<i8,9>);
	[1202] UnlockSystemSettingsRestriction(array<i8,9>);
	[1203] SetPinCode(array<i8,9>);
	# This cmd takes no input, and produces 0x20 bytes of raw output containing snprintf(%02d%08llu, 10, \[inquiry\_rnd\]) on &lt;= [3.0.0](http://switchbrew.org/index.php?title=3.0.0 "wikilink"). This changed on [3.0.1](http://switchbrew.org/index.php?title=3.0.1 "wikilink") to produce 11(...) instead of 10(...).
	# 
	# The random number generation relies on TinyMT.
	# 
	[1204] GenerateInquiryCode() -> nn::pctl::InquiryCode;
	# This cmd takes the 0x20 bytes produced by GenerateInquiryCode, and an 0x20 byte X descriptor containing snprintf(%08llu, master\_key), and returns a bool 00 if the master key is not valid, and 01 if it is.
	# 
	# Master Keys are validated as follows on &lt;= [3.0.0](http://switchbrew.org/index.php?title=3.0.0 "wikilink"): first, svcSleepThread(1000000000LL) is called to introduce a delay to prevent brute force attacks. Then, strlen(master\_key) is called -- if this is not 8, 0 is returned. Next, the inquiry code is regenerated and snprintf(%02d%08llu, 10, generated\_inquiry\_rnd) is compared to the inquiry data passed in as an argument. If this doesn't match, 0 is returned. Then, hmac-sha256(snprintf(%02d%08llu, 10, generated\_inquiry\_rnd)) is called using hardcoded keydata, and the master key argument is compared to snprintf(%08llu, (hmac\_result & 0xFFFFFFFFFFFF) % 100000000). If this matches, 1 is returned, otherwise 0 is returned.
	# 
	# On [3.0.1](http://switchbrew.org/index.php?title=3.0.1 "wikilink") this was changed to use different hardcoded keydata, and to pass 11 as the snprintf argument instead of 10.
	# 
	# [Category:Services](http://switchbrew.org/index.php?title=Category:Services "wikilink")
	# 
	[1205] CheckMasterKey(nn::pctl::InquiryCode, array<i8,9>) -> bool;
	[1206] GetPinCodeLength() -> i32;
	[1207] GetPinCodeChangedEvent() -> KObject;
	@version(4.0.0+)
	[1208] GetPinCode();
	[1403] IsPairingActive() -> bool;
	[1406] GetSettingsLastUpdated() -> nn::time::PosixTime;
	[1411] GetPairingAccountInfo(nn::pctl::detail::PairingInfoBase) -> nn::pctl::detail::PairingAccountInfoBase;
	[1421] GetAccountNickname(nn::pctl::detail::PairingAccountInfoBase) -> (u32, array<i8,10>);
	[1424] GetAccountState(nn::pctl::detail::PairingAccountInfoBase) -> i32;
	[1432] GetSynchronizationEvent() -> KObject;
	[1451] StartPlayTimer();
	[1452] StopPlayTimer();
	[1453] IsPlayTimerEnabled() -> bool;
	[1454] GetPlayTimerRemainingTime() -> nn::TimeSpanType;
	[1455] IsRestrictedByPlayTimer() -> bool;
	[1456] GetPlayTimerSettings() -> nn::pctl::PlayTimerSettings;
	[1457] GetPlayTimerEventToRequestSuspension() -> KObject;
	@version(4.0.0+)
	[1458] IsPlayTimerAlarmDisabled();
	[1471] NotifyWrongPinCodeInputManyTimes();
	[1472] CancelNetworkRequest();
	[1473] GetUnlinkedEvent() -> KObject;
	[1474] ClearUnlinkedEvent();
	[1601] DisableAllFeatures() -> bool;
	[1602] PostEnableAllFeatures() -> bool;
	[1603] IsAllFeaturesDisabled() -> (bool, bool);
	[1901] DeleteFromFreeCommunicationApplicationListForDebug(nn::ncm::ApplicationId);
	[1902] ClearFreeCommunicationApplicationListForDebug();
	@version(5.0.0+)
	[1903] GetExemptApplicationListCountForDebug();
	@version(5.0.0+)
	[1904] GetExemptApplicationListForDebug();
	@version(5.0.0+)
	[1905] UpdateExemptApplicationListForDebug();
	@version(5.0.0+)
	[1906] AddToExemptApplicationListForDebug();
	@version(5.0.0+)
	[1907] DeleteFromExemptApplicationListForDebug();
	@version(5.0.0+)
	[1908] ClearExemptApplicationListForDebug();
	[1941] DeletePairing();
	[1951] SetPlayTimerSettingsForDebug(nn::pctl::PlayTimerSettings);
	[1952] GetPlayTimerSpentTimeForTest() -> nn::TimeSpanType;
	@version(4.0.0+)
	[1953] SetPlayTimerAlarmDisabledForDebug();
	[2001] RequestPairingAsync(array<i8,9>) -> (nn::pctl::detail::AsyncData, KObject);
	[2002] FinishRequestPairing(nn::pctl::detail::AsyncData) -> nn::pctl::detail::PairingInfoBase;
	[2003] AuthorizePairingAsync(nn::pctl::detail::PairingInfoBase) -> (nn::pctl::detail::AsyncData, KObject);
	[2004] FinishAuthorizePairing(nn::pctl::detail::AsyncData) -> nn::pctl::detail::PairingInfoBase;
	[2005] RetrievePairingInfoAsync() -> (nn::pctl::detail::AsyncData, KObject);
	[2006] FinishRetrievePairingInfo(nn::pctl::detail::AsyncData) -> nn::pctl::detail::PairingInfoBase;
	[2007] UnlinkPairingAsync(bool) -> (nn::pctl::detail::AsyncData, KObject);
	[2008] FinishUnlinkPairing(bool, align<4,nn::pctl::detail::AsyncData>);
	[2009] GetAccountMiiImageAsync(nn::pctl::detail::PairingAccountInfoBase) -> (nn::pctl::detail::AsyncData, u32, KObject, buffer<unknown,6,0>);
	[2010] FinishGetAccountMiiImage(nn::pctl::detail::AsyncData) -> (u32, buffer<unknown,6,0>);
	[2011] GetAccountMiiImageContentTypeAsync(nn::pctl::detail::PairingAccountInfoBase) -> (nn::pctl::detail::AsyncData, u32, KObject, array<i8,10>);
	[2012] FinishGetAccountMiiImageContentType(nn::pctl::detail::AsyncData) -> (u32, array<i8,10>);
	[2013] SynchronizeParentalControlSettingsAsync() -> (nn::pctl::detail::AsyncData, KObject);
	[2014] FinishSynchronizeParentalControlSettings(nn::pctl::detail::AsyncData);
	[2015] FinishSynchronizeParentalControlSettingsWithLastUpdated(nn::pctl::detail::AsyncData) -> nn::time::PosixTime;
	@version(5.0.0+)
	[2016] RequestUpdateExemptionListAsync();
}

interface nn::pctl::detail::ipc::IParentalControlServiceFactory is pctl:s, pctl:r, pctl:a, pctl {
	[0] CreateService(u64, pid) -> object<nn::pctl::detail::ipc::IParentalControlService>;
	@version(4.0.0+)
	[1] CreateServiceWithoutInitialize();
}

interface nn::pcv::IArbitrationManager is pcv:arb {
	[0] ReleaseControl(i32);
}

interface nn::pcv::IImmediateManager is pcv:imm {
	[0] SetClockRate(i32, u32);
}

interface nn::pcv::detail::IPcvService is pcv {
	[0] SetPowerEnabled(bool, i32);
	[1] SetClockEnabled(bool, i32);
	[2] SetClockRate(i32, u32);
	[3] GetClockRate(i32) -> u32;
	[4] GetState(i32) -> nn::pcv::ModuleState;
	[5] GetPossibleClockRates(i32, i32) -> (i32, i32, array<u32,10>);
	[6] SetMinVClockRate(i32, u32);
	[7] SetReset(bool, i32);
	[8] SetVoltageEnabled(bool, i32);
	[9] GetVoltageEnabled(i32) -> bool;
	[10] GetVoltageRange(i32) -> (i32, i32, i32);
	[11] SetVoltageValue(i32, i32);
	[12] GetVoltageValue(i32) -> i32;
	[13] GetTemperatureThresholds(i32) -> (i32, array<nn::pcv::TemperatureThreshold,10>);
	[14] SetTemperature(i32);
	[15] Initialize();
	[16] IsInitialized() -> bool;
	[17] Finalize();
	[18] PowerOn(nn::pcv::PowerControlTarget, i32);
	[19] PowerOff(nn::pcv::PowerControlTarget);
	[20] ChangeVoltage(nn::pcv::PowerControlTarget, i32);
	[21] GetPowerClockInfoEvent() -> KObject;
	[22] GetOscillatorClock() -> u32;
	[23] GetDvfsTable(i32, i32) -> (i32, array<u32,10>, array<i32,10>);
	[24] GetModuleStateTable(i32) -> (i32, array<nn::pcv::ModuleState,10>);
	[25] GetPowerDomainStateTable(i32) -> (i32, array<nn::pcv::PowerDomainState,10>);
	[26] GetFuseInfo(i32) -> (i32, array<u32,10>);
}

interface nn::pinmux::IManager is pinmux {
	[0] OpenSession(u32) -> object<IUnknown>;
}

interface nn::pinmux::ISession {
	[0] SetPinAssignment(u32);
	[1] GetPinAssignment() -> u32;
	[2] SetPinAssignmentForHardwareTest(u32);
}

interface nn::pl::detail::ISharedFontManager is pl:u {
	# Takes a [\#SharedFontType](http://switchbrew.org/index.php?title=Shared Database services#SharedFontType "wikilink") (uint32), no output.
	# 
	[0] RequestLoad(u32);
	# Takes a [\#SharedFontType](http://switchbrew.org/index.php?title=Shared Database services#SharedFontType "wikilink") (uint32), returns the [\#LoadState](http://switchbrew.org/index.php?title=Shared Database services#LoadState "wikilink") (uint32).
	# 
	[1] GetLoadState(u32) -> u32;
	# Takes a [\#SharedFontType](http://switchbrew.org/index.php?title=Shared Database services#SharedFontType "wikilink") (uint32), returns the Font Size (uint32).
	# 
	[2] GetSize(u32) -> u32;
	# Takes a [\#SharedFontType](http://switchbrew.org/index.php?title=Shared Database services#SharedFontType "wikilink") (uint32), returns the offset (uint32) to the Font Address.
	# 
	[3] GetSharedMemoryAddressOffset(u32) -> u32;
	# No input, returns an output SharedMemory handle.
	# 
	# User-processes map this SharedMemory with size=0x1100000 and permissions=R--.
	# 
	# Font data is TTF, located at the offset returned by [\#GetSharedMemoryAddressOffset](#nn::pl::detail::ISharedFontManager(3) "wikilink").
	# 
	[4] GetSharedMemoryNativeHandle() -> KObject;
	# Takes an input u64 [LanguageCode](http://switchbrew.org/index.php?title=Settings_services#LanguageCode "wikilink") and 3 type-0x6 output buffers, returns an output u8 and u32. The u8 is a bool to specify if the fonts are loaded or not and the u32 is the font count. The first buffer contains a list of [Shared font types](http://switchbrew.org/index.php?title=Shared Database services#SharedFontType "wikilink"), the second buffer contains the font offsets and the final buffer contains the font sizes. The buffers are an array of u32s which specify information about a specific font. Buffer1\[n\] is related to Buffer2\[n\] and Buffer3\[n\]. Example: Font index 0s offset is at Buffer2\[0\], size is at Buffer3\[0\]. The fonts are relative to the shared memory created by [\#GetSharedMemoryNativeHandle](#nn::pl::detail::ISharedFontManager(4) "wikilink")
	# 
	[5] GetSharedFontInOrderOfPriority(u64) -> (u8, u32, buffer<unknown,6,0>, buffer<unknown,6,0>, buffer<unknown,6,0>);
}

interface nn::pm::detail::IBootModeInterface is pm:bm {
	[0] GetBootMode() -> u32;
	[1] SetMaintenanceBoot();
}

interface nn::pm::detail::IDebugMonitorInterface is pm:dmnt {
	# Always returns u32 0 on retail.
	# 
	# \[2.0.0+\] Additional check on input that can return 0xC0F. The meaning is probably useless because function is somewhat nopped on non-dev builds anyway.
	# 
	[0] IsDebugMode();
	# Returns an array of pids of all processes that have mask 4 set in process flags.
	# 
	# \[2.0.0+\] Additional check on input that can return 0xC0F. The meaning is probably useless because function is somewhat nopped on non-dev builds anyway.
	# 
	[1] GetDebugProcesses();
	# Takes a pid. Last process event must be ProcessEvent\_Created or ProcessEvent\_DebugAttached.
	# 
	# Then it uses svcStartProcess(process\_handle, u8, u8, u32) with args coming from ldr:pm GetProgramInfo.
	# 
	# After that, it sets last process state to ProcessEvent\_DebugDetached.
	# 
	[2] StartDebugProcess();
	# Takes a title-id and returns the pid.
	# 
	[3] GetTitlePid();
	# Takes a title-id of the program to debug. Sets this to a global field.
	# 
	# Next time it gets launched it will be handled differently.
	# 
	# Returns an event handle that is signaled when the requested title is about to be launched.
	# 
	[4] EnableDebugForTitleId();
	# Returns the pid of the application process.
	# 
	[5] GetApplicationPid();
	# Does \*not\* take a specific title-id as input.
	# 
	# Returns an event handle that is triggered for application titles.
	# 
	[6] EnableDebugForApplication();
}

interface nn::pm::detail::IInformationInterface is pm:info {
	# Takes a pid and returns the title-id associated with the process.
	# 
	[0] GetTitleId(u64) -> u64;
}

interface nn::pm::detail::IShellInterface is pm:shell {
	# Takes launch\_flags, title-id, and storageID. See [\#Process launch](http://switchbrew.org/index.php?title=Process Manager services#Process_launch "wikilink").
	# 
	# Returns the u64 title PID.
	# 
	@undocumented
	[0] LaunchProcess();
	[1] TerminateProcessByPid(u64);
	[2] TerminateProcessByTitleId(u64);
	[3] GetProcessEventWaiter() -> KObject;
	# Returns 1 if flags has mask 2 set.
	# 
	# Returns 2 if flags has mask 1 set and state is 6.
	# 
	# Returns 3 if flags has mask 0x10 set and not 0x20.
	# 
	# Returns 4 if flags has mask 0x30 set.
	# 
	# \[2.0.0+\] returns 5 if state &gt;= 2 and flags has mask 0x100 set.
	# 
	# Returns 0 if process is not found.
	# 
	[4] GetProcessEventType() -> u128;
	# Takes a pid as input. If the process with pid has the state dead, it unregisters the pid in fsp:pr, sm:m, and ldr:pm.
	# 
	# Then it removes the process from PMs internal linked-list of active processes.
	# 
	# \[5.0.0+\] This command was removed.
	# 
	@version(1.0.0-4.1.0)
	[5] FinalizeDeadProcess(u64);
	# This launches the [boot2](http://switchbrew.org/index.php?title=boot2 "wikilink") title.
	# 
	# \[4.0.0+\] When booting from SafeMode Firmware, instead of [boot2](http://switchbrew.org/index.php?title=boot2 "wikilink"), this launches the following titles in order:
	# 
	# -   0100000000000009 (settings)
	# -   0100000000000006 (usb)
	# -   010000000000001D (pcie)
	# -   0100000000000007 (tma)
	# -   010000000000001F (ns)
	# -   0100000000000015 (lm)
	# -   0100000000000010 (ptm)
	# -   0100000000000016 (wlan)
	# -   0100000000000012 (bsdsockets)
	# -   010000000000000F (nifm)
	# -   0100000000000024 (ssl)
	# -   0100000000000025 (nim)
	# -   0100000000000031 (glue)
	# -   010000000000003D (safemode)
	# 
	@version(5.0.0+)
	[5] NotifyBootFinished(u64);
	# Takes a pid as input. Clears 0x10 from process flags.
	# 
	# \[5.0.0+\] This command was removed.
	# 
	@version(1.0.0-4.1.0)
	[6] ClearProcessNotificationFlag(u64);
	# Returns the pid of the application process.
	# 
	@version(5.0.0+)
	[6] GetApplicationPid(u64);
	# This launches the [boot2](http://switchbrew.org/index.php?title=boot2 "wikilink") title.
	# 
	# \[4.0.0+\] When booting from SafeMode Firmware, instead of [boot2](http://switchbrew.org/index.php?title=boot2 "wikilink"), this launches the following titles in order:
	# 
	# -   0100000000000009 (settings)
	# -   0100000000000006 (usb)
	# -   010000000000001D (pcie)
	# -   0100000000000007 (tma)
	# -   010000000000001F (ns)
	# -   0100000000000015 (lm)
	# -   0100000000000010 (ptm)
	# -   0100000000000016 (wlan)
	# -   0100000000000012 (bsdsockets)
	# -   010000000000000F (nifm)
	# -   0100000000000024 (ssl)
	# -   0100000000000025 (nim)
	# -   0100000000000031 (glue)
	# -   010000000000003D (safemode)
	# 
	@version(1.0.0-4.1.0)
	[7] NotifyBootFinished();
	# Takes an u64 **mem\_size** as input. If the desired memory size doesn't exceed an internal limit (imposed by PM by looking at the [MemoryArrange](http://switchbrew.org/index.php?title=SPL_services#MemoryArrange "wikilink") ConfigItem), PM calls svcSetResourceLimitLimitValue to set the new [LimitableResource\_Memory](http://switchbrew.org/index.php?title=SVC#LimitableResource "wikilink") value.
	# 
	# This is used directly by [ns:am2 BoostSystemMemoryResourceLimit](http://switchbrew.org/index.php?title=NS_Services#IApplicationManagerInterface "wikilink").
	# 
	# [Category:Services](http://switchbrew.org/index.php?title=Category:Services "wikilink")
	# 
	@version(5.0.0+)
	[7] BoostSystemMemoryResourceLimit();
	# Returns the pid of the application process.
	# 
	@version(1.0.0-4.1.0)
	[8] GetApplicationPid() -> u64;
	# Takes an u64 **mem\_size** as input. If the desired memory size doesn't exceed an internal limit (imposed by PM by looking at the [MemoryArrange](http://switchbrew.org/index.php?title=SPL_services#MemoryArrange "wikilink") ConfigItem), PM calls svcSetResourceLimitLimitValue to set the new [LimitableResource\_Memory](http://switchbrew.org/index.php?title=SVC#LimitableResource "wikilink") value.
	# 
	# This is used directly by [ns:am2 BoostSystemMemoryResourceLimit](http://switchbrew.org/index.php?title=NS_Services#IApplicationManagerInterface "wikilink").
	# 
	# [Category:Services](http://switchbrew.org/index.php?title=Category:Services "wikilink")
	# 
	@version(4.0.0-4.1.0)
	[9] BoostSystemMemoryResourceLimit();
}

interface nn::prepo::detail::ipc::IPrepoService is prepo:a, prepo:m, prepo:u, prepo:s {
	[10100] SaveReport(u64, pid, array<i8,9>, buffer<unknown,5,0>);
	[10101] SaveReportWithUser(nn::account::Uid, u64, pid, array<i8,9>, buffer<unknown,5,0>);
	[10200] RequestImmediateTransmission();
	[10300] GetTransmissionStatus() -> i32;
	[20100] SaveSystemReport(nn::ApplicationId, array<i8,9>, buffer<unknown,5,0>);
	[20101] SaveSystemReportWithUser(nn::account::Uid, nn::ApplicationId, array<i8,9>, buffer<unknown,5,0>);
	@version(4.0.0+)
	[20200] SetOperationMode();
	[30100] ClearStorage();
	[40100] IsUserAgreementCheckEnabled() -> bool;
	[40101] SetUserAgreementCheckEnabled(bool);
	[90100] GetStorageUsage() -> (i64, i64);
	@version(5.0.0+)
	[90200] GetStatistics();
	@version(5.0.0+)
	[90201] GetThroughputHistory();
	@version(5.0.0+)
	[90300] GetLastUploadError();
}

interface nn::profiler::IProfiler is banana {
	[0] GetSystemEvent();
	[1] StartSignalingEvent();
	[2] StopSignalingEvent();
}

interface nn::psc::sf::IPmControl is psc:c {
	[0] Unknown0() -> KObject;
	[1] Unknown1(u32, u32, u32);
	[2] Unknown2();
	[3] Unknown3() -> u32;
	[4] Unknown4();
	[5] Unknown5();
	@undocumented
	[6] Unknown6();
}

interface nn::psc::sf::IPmModule {
	@undocumented
	[0] Initialize();
	@undocumented
	[1] GetRequest();
	[2] Acknowledge();
	[3] Unknown3();
}

interface nn::psc::sf::IPmService is psc:m {
	[0] GetPmModule() -> object<IUnknown>;
}

interface nn::psm::IPsmServer is psm {
	[0] GetBatteryChargePercentage() -> u32;
	[1] GetChargerType() -> u32;
	[2] EnableBatteryCharging();
	[3] DisableBatteryCharging();
	[4] IsBatteryChargingEnabled() -> u8;
	[5] AcquireControllerPowerSupply();
	[6] ReleaseControllerPowerSupply();
	[7] OpenSession() -> object<IUnknown>;
	[8] EnableEnoughPowerChargeEmulation();
	[9] DisableEnoughPowerChargeEmulation();
	[10] EnableFastBatteryCharging();
	[11] DisableFastBatteryCharging();
	[12] GetBatteryVoltageState() -> u32;
	[13] GetRawBatteryChargePercentage() -> u64;
	[14] IsEnoughPowerSupplied() -> u8;
	[15] GetBatteryAgePercentage() -> u64;
	[16] GetBatteryChargeInfoEvent() -> KObject;
	@undocumented
	[17] GetBatteryChargeInfoFields();
}

interface nn::psm::IPsmSession {
	[0] BindStateChangeEvent() -> KObject;
	[1] UnbindStateChangeEvent();
	[2] SetChargerTypeChangeEventEnabled(u8);
	[3] SetPowerSupplyChangeEventEnabled(u8);
	[4] SetBatteryVoltageStateChangeEventEnabled(u8);
}

interface nn::pwm::IChannelSession {
	[0] SetPeriod(u64);
	[1] GetPeriod() -> u64;
	[2] SetDuty(u32);
	[3] GetDuty() -> u32;
	[4] SetEnabled(u8);
	[5] GetEnabled() -> u8;
}

interface nn::pwm::IManager is pwm {
	[0] OpenSessionForDev(u32) -> object<IUnknown>;
	[1] OpenSession(u32) -> object<IUnknown>;
}

interface nn::sasbus::IManager is sasbus {
	[0] OpenSession(u32) -> object<IUnknown>;
}

interface nn::sasbus::ISession {
	@undocumented
	[0] Unknown0();
	@undocumented
	[1] Unknown1();
	@undocumented
	[2] Unknown2();
	[3] Unknown3();
}

interface nn::settings::IFactorySettingsServer is set:cal {
	[0] GetBluetoothBdAddress() -> nn::settings::factory::BdAddress;
	[1] GetConfigurationId1() -> nn::settings::factory::ConfigurationId1;
	[2] GetAccelerometerOffset() -> nn::settings::factory::AccelerometerOffset;
	[3] GetAccelerometerScale() -> nn::settings::factory::AccelerometerScale;
	[4] GetGyroscopeOffset() -> nn::settings::factory::GyroscopeOffset;
	[5] GetGyroscopeScale() -> nn::settings::factory::GyroscopeScale;
	[6] GetWirelessLanMacAddress() -> nn::settings::factory::MacAddress;
	[7] GetWirelessLanCountryCodeCount() -> i32;
	[8] GetWirelessLanCountryCodes() -> (i32, array<nn::settings::factory::CountryCode,10>);
	[9] GetSerialNumber() -> nn::settings::factory::SerialNumber;
	[10] SetInitialSystemAppletProgramId(nn::ncm::ProgramId);
	[11] SetOverlayDispProgramId(nn::ncm::ProgramId);
	[12] GetBatteryLot() -> nn::settings::factory::BatteryLot;
	# Takes a type-0x16 output buffer with fixed size 0x180.
	# 
	# Returns the device certificate (ECC signed). This is identical to 3DS DeviceCert/CTCert besides the strings. NIM loads the DeviceId from this.
	# 
	[14] GetEciDeviceCertificate() -> buffer<nn::settings::factory::EccB233DeviceCertificate,22,384>;
	# Takes a type-0x16 output buffer with fixed size 0x240.
	# 
	# Returns the ETicket certificate (RSA signed).
	# 
	[15] GetEticketDeviceCertificate() -> buffer<nn::settings::factory::Rsa2048DeviceCertificate,22,576>;
	# Takes a type-0x16 output buffer with fixed size 0x134.
	# 
	# Returns the extended SSL key (0x130 bytes) from [CAL0](http://switchbrew.org/index.php?title=Calibration#CAL0 "wikilink"). If the extended key is not programmed then it falls back to the normal SSL key (0x110 bytes).
	# 
	# Used by SSL-sysmodule, see [here](http://switchbrew.org/index.php?title=SSL_services "wikilink").
	# 
	[16] GetSslKey() -> buffer<nn::settings::factory::SslKey,22,308>;
	# Takes a type-0x16 output buffer with fixed size 0x804.
	# 
	# Returns a [container](http://switchbrew.org/index.php?title=Settings_services#setcal_Container_Structure "wikilink") with the plaintext SSL certificate.
	# 
	# Used by SSL-sysmodule, see [here](http://switchbrew.org/index.php?title=SSL_services "wikilink").
	# 
	[17] GetSslCertificate() -> buffer<nn::settings::factory::SslCertificate,22,2052>;
	# Takes a type-0x16 output buffer with fixed size 0x134.
	# 
	# Returns the extended GameCard key (0x130 bytes) from [CAL0](http://switchbrew.org/index.php?title=Calibration#CAL0 "wikilink"). If the extended key is not programmed then it falls back to the normal GameCard key (0x110 bytes).
	# 
	[18] GetGameCardKey() -> buffer<nn::settings::factory::GameCardKey,22,308>;
	# Takes a type-0x16 output buffer with fixed size 0x404.
	# 
	# Returns a [container](http://switchbrew.org/index.php?title=Settings_services#setcal_Container_Structure "wikilink") with the GameCard certificate.
	# 
	[19] GetGameCardCertificate() -> buffer<nn::settings::factory::GameCardCertificate,22,1024>;
	# Returns the extended device ECC-B233 key (0x50 bytes) from [CAL0](http://switchbrew.org/index.php?title=Calibration#CAL0 "wikilink"). If the extended key is not programmed then it falls back to the normal device ECC-B233 key (0x30 bytes).
	# 
	[20] GetEciDeviceKey() -> nn::settings::factory::EccB233DeviceKey;
	# Takes a type-0x16 output buffer with fixed size 0x244.
	# 
	# Returns the extended ETicket RSA-2048 key (0x240 bytes) from [CAL0](http://switchbrew.org/index.php?title=Calibration#CAL0 "wikilink"). If the extended key is not programmed then it falls back to the normal ETicket RSA-2048 key (0x220 bytes).
	# 
	[21] GetEticketDeviceKey() -> buffer<nn::settings::factory::Rsa2048DeviceKey,22,580>;
	[22] GetSpeakerParameter() -> nn::settings::factory::SpeakerParameter;
	@version(4.0.0+)
	[23] GetLcdVendorId();
	@version(5.0.0+)
	[24] GetEciDeviceCertificate2();
	@version(5.0.0+)
	[25] GetEciDeviceKey2();
	@version(5.0.0+)
	[26] GetAmiiboKey();
	@version(5.0.0+)
	[27] GetAmiiboEcqvCertificate();
	@version(5.0.0+)
	[28] GetAmiiboEcdsaCertificate();
	@version(5.0.0+)
	[29] GetAmiiboEcqvBlsKey();
	@version(5.0.0+)
	[30] GetAmiiboEcqvBlsCertificate();
	@version(5.0.0+)
	[31] GetAmiiboEcqvBlsRootCertificate();
	@version(5.0.0+)
	[32] GetUnknownId();
}

interface nn::settings::IFirmwareDebugSettingsServer is set:fd {
	[2] SetSettingsItemValue(buffer<nn::settings::SettingsName,25,72>, buffer<nn::settings::SettingsItemKey,25,72>, buffer<unknown,5,0>);
	[3] ResetSettingsItemValue(buffer<nn::settings::SettingsName,25,72>, buffer<nn::settings::SettingsItemKey,25,72>);
	[4] CreateSettingsItemKeyIterator(buffer<nn::settings::SettingsName,25,72>) -> object<nn::settings::ISettingsItemKeyIterator>;
	@version(4.0.0+)
	[10] ReadSettings();
	@version(4.0.0+)
	[11] ResetSettings();
	@version(4.0.0+)
	[20] SetWebInspectorFlag();
	@version(4.0.0+)
	[21] SetAllowedSslHosts();
	@version(4.0.0+)
	[22] SetHostFsMountPoint();
}

interface nn::settings::ISettingsServer is set {
	[0] GetLanguageCode() -> nn::settings::LanguageCode;
	[1] GetAvailableLanguageCodes() -> (i32, array<nn::settings::LanguageCode,10>);
	@version(4.0.0+)
	[2] MakeLanguageCode();
	[3] GetAvailableLanguageCodeCount() -> i32;
	[4] GetRegionCode() -> i32;
	@version(4.0.0+)
	[5] GetAvailableLanguageCodes2();
	@version(4.0.0+)
	[6] GetAvailableLanguageCodeCount2();
	@version(4.0.0+)
	[7] GetKeyCodeMap();
	@version(5.0.0+)
	[8] GetQuestFlag();
}

interface nn::settings::ISystemSettingsServer is set:sys {
	[0] SetLanguageCode(nn::settings::LanguageCode);
	[1] SetNetworkSettings(array<nn::settings::system::NetworkSettings,5>);
	[2] GetNetworkSettings() -> (i32, array<nn::settings::system::NetworkSettings,6>);
	# Takes a type-0x1A output buffer. User-processes use hard-coded size 0x100.
	# 
	# If needed, reads the content of the [System\_Version\_Title](http://switchbrew.org/index.php?title=System_Version_Title "wikilink") /file into state. This is only done once.
	# 
	# Then the above 0x100-byte data is copied to the output buffer.
	# 
	[3] GetFirmwareVersion() -> buffer<nn::settings::system::FirmwareVersion,26,256>;
	@version(3.0.0+)
	[4] GetFirmwareVersion2() -> buffer<nn::settings::system::FirmwareVersion,26,256>;
	@version(5.0.0+)
	[5] GetFirmwareVersionDigest();
	[7] GetLockScreenFlag() -> bool;
	[8] SetLockScreenFlag(bool);
	[9] GetBacklightSettings() -> nn::settings::system::BacklightSettings;
	[10] SetBacklightSettings(nn::settings::system::BacklightSettings);
	[11] SetBluetoothDevicesSettings(array<nn::settings::system::BluetoothDevicesSettings,5>);
	[12] GetBluetoothDevicesSettings() -> (i32, array<nn::settings::system::BluetoothDevicesSettings,6>);
	[13] GetExternalSteadyClockSourceId() -> nn::util::Uuid;
	[14] SetExternalSteadyClockSourceId(nn::util::Uuid);
	[15] GetUserSystemClockContext() -> nn::time::SystemClockContext;
	[16] SetUserSystemClockContext(nn::time::SystemClockContext);
	[17] GetAccountSettings() -> nn::settings::system::AccountSettings;
	[18] SetAccountSettings(nn::settings::system::AccountSettings);
	[19] GetAudioVolume(i32) -> nn::settings::system::AudioVolume;
	[20] SetAudioVolume(nn::settings::system::AudioVolume, i32);
	[21] GetEulaVersions() -> (i32, array<nn::settings::system::EulaVersion,6>);
	[22] SetEulaVersions(array<nn::settings::system::EulaVersion,5>);
	# No input, returns an output s32.
	# 
	# This is the current Theme set by System Settings.
	# 
	# -   0: Basic White
	# -   1: Basic Black
	# 
	[23] GetColorSetId() -> i32;
	# Takes an input s32, no output.
	# 
	[24] SetColorSetId(i32);
	[25] GetConsoleInformationUploadFlag() -> bool;
	[26] SetConsoleInformationUploadFlag(bool);
	[27] GetAutomaticApplicationDownloadFlag() -> bool;
	[28] SetAutomaticApplicationDownloadFlag(bool);
	[29] GetNotificationSettings() -> nn::settings::system::NotificationSettings;
	[30] SetNotificationSettings(nn::settings::system::NotificationSettings);
	[31] GetAccountNotificationSettings() -> (i32, array<nn::settings::system::AccountNotificationSettings,6>);
	[32] SetAccountNotificationSettings(array<nn::settings::system::AccountNotificationSettings,5>);
	[35] GetVibrationMasterVolume() -> f32;
	[36] SetVibrationMasterVolume(f32);
	[37] GetSettingsItemValueSize(buffer<nn::settings::SettingsName,25,72>, buffer<nn::settings::SettingsItemKey,25,72>) -> u64;
	# Takes two type-0x19 input buffers and a type-0x6 output buffer. Returns an output u64 for the actual size written to the outbuf.
	# 
	# The outbuf\_size is compared with the config\_size. When config\_size is larger than outbuf\_size, outbuf\_size is used for the memcpy, otherwise config\_size is used. Afterwards the size used for the memcpy is written to output(see above).
	# 
	# If loading from main config fails, it will also attempt to load config from various state if the input strings match hard-coded strings.
	# 
	[38] GetSettingsItemValue(buffer<nn::settings::SettingsName,25,72>, buffer<nn::settings::SettingsItemKey,25,72>) -> (u64, buffer<unknown,6,0>);
	[39] GetTvSettings() -> nn::settings::system::TvSettings;
	[40] SetTvSettings(nn::settings::system::TvSettings);
	[41] GetEdid() -> buffer<nn::settings::system::Edid,26,256>;
	[42] SetEdid(buffer<nn::settings::system::Edid,25,256>);
	[43] GetAudioOutputMode(i32) -> i32;
	[44] SetAudioOutputMode(i32, i32);
	[45] IsForceMuteOnHeadphoneRemoved() -> bool;
	[46] SetForceMuteOnHeadphoneRemoved(bool);
	# Gets a flag determining whether the console is a kiosk unit (codenamed Quest). Used by qlaunch to determine whether to launch Retail Interactive Display Menu.
	# 
	[47] GetQuestFlag() -> bool;
	[48] SetQuestFlag(bool);
	[49] GetDataDeletionSettings() -> nn::settings::system::DataDeletionSettings;
	[50] SetDataDeletionSettings(nn::settings::system::DataDeletionSettings);
	[51] GetInitialSystemAppletProgramId() -> nn::ncm::ProgramId;
	[52] GetOverlayDispProgramId() -> nn::ncm::ProgramId;
	[53] GetDeviceTimeZoneLocationName() -> nn::time::LocationName;
	[54] SetDeviceTimeZoneLocationName(nn::time::LocationName);
	[55] GetWirelessCertificationFileSize() -> u64;
	[56] GetWirelessCertificationFile() -> (u64, buffer<unknown,6,0>);
	[57] SetRegionCode(i32);
	[58] GetNetworkSystemClockContext() -> nn::time::SystemClockContext;
	[59] SetNetworkSystemClockContext(nn::time::SystemClockContext);
	[60] IsUserSystemClockAutomaticCorrectionEnabled() -> bool;
	[61] SetUserSystemClockAutomaticCorrectionEnabled(bool);
	# Returns an output u8.
	# 
	# Loads the 1-byte config for &lt;settings\_debug, is\_debug\_mode\_enabled&gt;. If that fails, value 0x1 is written to output. This uses the same func as ReadSetting internally.
	# 
	# Returned retval is always 0.
	# 
	[62] GetDebugModeFlag() -> bool;
	[63] GetPrimaryAlbumStorage() -> i32;
	[64] SetPrimaryAlbumStorage(i32);
	[65] GetUsb30EnableFlag() -> bool;
	[66] SetUsb30EnableFlag(bool);
	[67] GetBatteryLot() -> nn::settings::system::BatteryLot;
	# Returns the 0x18-byte SerialNumber string.
	# 
	[68] GetSerialNumber() -> nn::settings::system::SerialNumber;
	[69] GetNfcEnableFlag() -> bool;
	[70] SetNfcEnableFlag(bool);
	[71] GetSleepSettings() -> nn::settings::system::SleepSettings;
	[72] SetSleepSettings(nn::settings::system::SleepSettings);
	[73] GetWirelessLanEnableFlag() -> bool;
	[74] SetWirelessLanEnableFlag(bool);
	[75] GetInitialLaunchSettings() -> nn::settings::system::InitialLaunchSettings;
	[76] SetInitialLaunchSettings(nn::settings::system::InitialLaunchSettings);
	[77] GetDeviceNickName() -> buffer<nn::settings::system::DeviceNickName,22,128>;
	[78] SetDeviceNickName(buffer<nn::settings::system::DeviceNickName,21,128>);
	[79] GetProductModel() -> i32;
	[80] GetLdnChannel() -> i32;
	[81] SetLdnChannel(i32);
	[82] AcquireTelemetryDirtyFlagEventHandle() -> KObject;
	[83] GetTelemetryDirtyFlags() -> nn::settings::system::TelemetryDirtyFlag;
	[84] GetPtmBatteryLot() -> nn::settings::factory::BatteryLot;
	[85] SetPtmBatteryLot(nn::settings::factory::BatteryLot);
	[86] GetPtmFuelGaugeParameter() -> nn::settings::system::PtmFuelGaugeParameter;
	[87] SetPtmFuelGaugeParameter(nn::settings::system::PtmFuelGaugeParameter);
	[88] GetBluetoothEnableFlag() -> bool;
	[89] SetBluetoothEnableFlag(bool);
	[90] GetMiiAuthorId() -> nn::util::Uuid;
	[91] SetShutdownRtcValue(i64);
	[92] GetShutdownRtcValue() -> i64;
	[93] AcquireFatalDirtyFlagEventHandle() -> KObject;
	[94] GetFatalDirtyFlags() -> nn::settings::system::FatalDirtyFlag;
	@version(2.0.0+)
	[95] GetAutoUpdateEnableFlag() -> bool;
	@version(2.0.0+)
	[96] SetAutoUpdateEnableFlag(bool);
	@version(2.0.0+)
	[97] GetNxControllerSettings() -> (i32, array<nn::settings::system::NxControllerSettings,6>);
	@version(2.0.0+)
	[98] SetNxControllerSettings(array<nn::settings::system::NxControllerSettings,5>);
	@version(2.0.0+)
	[99] GetBatteryPercentageFlag() -> bool;
	@version(2.0.0+)
	[100] SetBatteryPercentageFlag(bool);
	@version(2.0.0+)
	[101] GetExternalRtcResetFlag() -> bool;
	@version(2.0.0+)
	[102] SetExternalRtcResetFlag(bool);
	@version(3.0.0+)
	[103] GetUsbFullKeyEnableFlag() -> bool;
	@version(3.0.0+)
	[104] SetUsbFullKeyEnableFlag(bool);
	@version(3.0.0+)
	[105] SetExternalSteadyClockInternalOffset(i64);
	@version(3.0.0+)
	[106] GetExternalSteadyClockInternalOffset() -> i64;
	@version(3.0.0+)
	[107] GetBacklightSettingsEx() -> nn::settings::system::BacklightSettingsEx;
	@version(3.0.0+)
	[108] SetBacklightSettingsEx(nn::settings::system::BacklightSettingsEx);
	@version(3.0.0+)
	[109] GetHeadphoneVolumeWarningCount() -> i32;
	@version(3.0.0+)
	[110] SetHeadphoneVolumeWarningCount(i32);
	@version(3.0.0+)
	[111] GetBluetoothAfhEnableFlag() -> bool;
	@version(3.0.0+)
	[112] SetBluetoothAfhEnableFlag(bool);
	@version(3.0.0+)
	[113] GetBluetoothBoostEnableFlag() -> bool;
	@version(3.0.0+)
	[114] SetBluetoothBoostEnableFlag(bool);
	@version(3.0.0+)
	[115] GetInRepairProcessEnableFlag() -> bool;
	@version(3.0.0+)
	[116] SetInRepairProcessEnableFlag(bool);
	@version(3.0.0+)
	[117] GetHeadphoneVolumeUpdateFlag() -> bool;
	@version(3.0.0+)
	[118] SetHeadphoneVolumeUpdateFlag(bool);
	@version(3.0.0+)
	[119] NeedsToUpdateHeadphoneVolume(bool) -> (bool, bool, i8);
	@version(3.0.0+)
	[120] GetPushNotificationActivityModeOnSleep() -> i32;
	@version(3.0.0+)
	[121] SetPushNotificationActivityModeOnSleep(i32);
	# Returns 0x01 if [safemode](http://switchbrew.org/index.php?title=Safemode "wikilink") needs to be launched.
	# 
	@version(4.0.0+)
	[122] GetServiceDiscoveryControlSettings();
	@version(4.0.0+)
	[123] SetServiceDiscoveryControlSettings();
	@version(4.0.0+)
	[124] GetErrorReportSharePermission();
	@version(4.0.0+)
	[125] SetErrorReportSharePermission();
	@version(4.0.0+)
	[126] GetAppletLaunchFlags();
	@version(4.0.0+)
	[127] SetAppletLaunchFlags();
	@version(4.0.0+)
	[128] GetConsoleSixAxisSensorAccelerationBias();
	@version(4.0.0+)
	[129] SetConsoleSixAxisSensorAccelerationBias();
	@version(4.0.0+)
	[130] GetConsoleSixAxisSensorAngularVelocityBias();
	@version(4.0.0+)
	[131] SetConsoleSixAxisSensorAngularVelocityBias();
	@version(4.0.0+)
	[132] GetConsoleSixAxisSensorAccelerationGain();
	@version(4.0.0+)
	[133] SetConsoleSixAxisSensorAccelerationGain();
	@version(4.0.0+)
	[134] GetConsoleSixAxisSensorAngularVelocityGain();
	@version(4.0.0+)
	[135] SetConsoleSixAxisSensorAngularVelocityGain();
	@version(4.0.0+)
	[136] GetKeyboardLayout();
	@version(4.0.0+)
	[137] SetKeyboardLayout();
	@version(4.0.0+)
	[138] GetWebInspectorFlag();
	# Takes a type-0x6 output buffer, returns an output s32. This buffer contains an array of 0x8-byte nn::settings::system::AllowedSslHost entries.
	# 
	@version(4.0.0+)
	[139] GetAllowedSslHosts();
	@version(4.0.0+)
	[140] GetHostFsMountPoint();
	@version(5.0.0+)
	[141] GetRequiresRunRepairTimeReviser();
	@version(5.0.0+)
	[142] SetRequiresRunRepairTimeReviser();
	@version(5.0.0+)
	[143] SetBlePairingSettings();
	@version(5.0.0+)
	[144] GetBlePairingSettings();
	@version(5.0.0+)
	[145] GetConsoleSixAxisSensorAngularVelocityTimeBias();
	@version(5.0.0+)
	[146] SetConsoleSixAxisSensorAngularVelocityTimeBias();
	@version(5.0.0+)
	[147] GetConsoleSixAxisSensorAngularAcceleration();
	@version(5.0.0+)
	[148] SetConsoleSixAxisSensorAngularAcceleration();
	@version(5.0.0+)
	[149] GetRebootlessSystemUpdateVersion();
}

interface nn::sm::detail::IManagerInterface is sm:m {
	# Takes a pid and two A descriptors with the ACID and ACI0 service lists. That data originates from [NPDM](http://switchbrew.org/index.php?title=NPDM "wikilink").
	# 
	[0] RegisterProcess(u64, buffer<unknown,5,0>, buffer<unknown,5,0>);
	# Takes a pid.
	# 
	[1] UnregisterProcess(u64);
}

interface nn::sm::detail::IUserInterface is sm: {
	# Takes a pid descriptor and a reserved input u64.
	# 
	[0] Initialize(u64, pid);
	# Takes a zero-padded service name encoded as an u64 integer. Returns a handle.
	# 
	[1] GetService(u64) -> KObject;
	# Takes a zero-padded service name encoded as an u64 integer, an u8 bool, and an u32 (session count) at the next word. Returns a handle.
	# 
	[2] RegisterService(u64, u8, u32) -> KObject;
	# Takes a zero-padded service name encoded as an u64 integer.
	# 
	[3] UnregisterService(u64);
}

interface nn::socket::resolver::IResolver is sfdnsres {
	# Stubbed, returns 0x7FE03
	[0] SetDnsAddressPrivate(u32, buffer<unknown,5,0>);
	# Stubbed, returns 0x7FE03
	[1] GetDnsAddressPrivate(u32) -> buffer<unknown,6,0>;
	[2] GetHostByName(u8, u32, u64, pid, buffer<unknown,5,0>) -> (u32, u32, u32, buffer<unknown,6,0>);
	[3] GetHostByAddr(u32, u32, u32, u64, pid, buffer<unknown,5,0>) -> (u32, u32, u32, buffer<unknown,6,0>);
	[4] GetHostStringError(u32) -> buffer<unknown,6,0>;
	[5] GetGaiStringError(u32) -> buffer<unknown,6,0>;
	# Takes three type 5 buffers (host, port, and hints), and a type 6 buffer (the output addrinfos). Also takes a u8 (padded to 4 bytes so the next raw parameter can align), a u32, and a u64. The u8 is a boolean for whether to enable nsd resolve (1) or not (0). Not sure what the u32 is. It seems to either come from a parameter to `GetAddrInfo` or be zero. The u64 is most likely a placeholder for the server to copy the PID into and should be zero. Both hints and the output buffer contain serialized addrinfo chains. The hints buffer is sized 0x400 bytes long by default, and the output buffer 0x1000 bytes.
	# 
	[6] GetAddrInfo(u8, u32, u64, pid, buffer<unknown,5,0>, buffer<unknown,5,0>, buffer<unknown,5,0>) -> (u32, u32, u32, buffer<unknown,6,0>);
	[7] GetNameInfo(u32, u32, u64, pid, buffer<unknown,5,0>) -> (u32, u32, buffer<unknown,6,0>, buffer<unknown,6,0>);
	[8] RequestCancelHandle(u64, pid) -> u32;
	[9] CancelSocketCall(u32, u64, pid);
	[10] Unknown10();
	# This function clears `nn::socket::resolver::g_DnsIpServerAddressArray`, setting its length to 0 as well. The array initially contains IPs filled by `bsdconfig`, a privileged service handling DHCP and such.
	# 
	# Takes no arguments, doesn't return anything, never fails.
	# 
	[11] ClearDnsIpServerAddressArray();
}

interface nn::socket::sf::IClient is bsd:u, bsd:s {
	[0] Initialize(bytes<32>, u64, u64, pid, KObject) -> u32;
	[1] StartMonitoring(u64, pid);
	# FreeBSD's `socket` command. `bsd:u` disallows the usage of the `SOCK_SEQPACKET` and `SOCK_RAW` types, with the exception of `(AF_INET, SOCK_RAW, IPPROTO_ICMP)` (IPv4 `ping`), `bsd:s` needs to be used for those.
	# 
	# The only registered domains are `AF_INET` and `AF_ROUTE`.
	# 
	# SocketExempt: same as socket but the socket is immediately shutdown (disconnected) on creation.
	# 
	[2] Socket(u32, u32, u32) -> (u32, u32);
	[3] SocketExempt(u32, u32, u32) -> (u32, u32);
	# FreeBSD's `open` command, limited to opening `/dev/bpf`. This can be used, for example, to enable promiscuous mode, see FreeBSD's `/dev/bpf` for more details.
	# 
	[4] Open(u32, buffer<unknown,33,0>) -> (u32, u32);
	[5] Select(u32, bytes<24>, buffer<unknown,33,0>, buffer<unknown,33,0>, buffer<unknown,33,0>) -> (u32, u32, buffer<unknown,34,0>, buffer<unknown,34,0>, buffer<unknown,34,0>);
	[6] Poll(u32, u32, buffer<unknown,33,0>) -> (u32, u32, buffer<unknown,34,0>);
	# FreeBSD's `sysctl` command. Privileged operations are reserved for `bsd:s`. `CTL_NET`, `CTL_VM`, `CTL_KERN` and `CTL_DEBUG` commands are implemented (?).
	# 
	[7] Sysctl(buffer<unknown,33,0>, buffer<unknown,33,0>) -> (u32, u32, u32, buffer<unknown,34,0>);
	[8] Recv(u32, u32) -> (u32, u32, buffer<unknown,34,0>);
	[9] RecvFrom(u32, u32) -> (u32, u32, u32, buffer<unknown,34,0>, buffer<unknown,34,0>);
	[10] Send(u32, u32, buffer<unknown,33,0>) -> (u32, u32);
	[11] SendTo(u32, u32, buffer<unknown,33,0>, buffer<unknown,33,0>) -> (u32, u32);
	[12] Accept(u32) -> (u32, u32, u32, buffer<unknown,34,0>);
	[13] Bind(u32, buffer<unknown,33,0>) -> (u32, u32);
	[14] Connect(u32, buffer<unknown,33,0>) -> (u32, u32);
	[15] GetPeerName(u32) -> (u32, u32, u32, buffer<unknown,34,0>);
	[16] GetSockName(u32) -> (u32, u32, u32, buffer<unknown,34,0>);
	[17] GetSockOpt(u32, u32, u32) -> (u32, u32, u32, buffer<unknown,34,0>);
	[18] Listen(u32, u32) -> (u32, u32);
	# FreeBSD's `ioctl` function. The following ioctls are whitelisted, refer to FreeBSD's headers for more details: SIOCATMARK, BIOCGBLEN, BIOCSETF BIOCIMMEDIATE, BIOCSETIF, BIOCVERSION, FIONSPACE, FIONWRITE, FIONREAD, SIOCGETSGCNT, SIOCGIFMETRIC, SIOCSIFMETRIC, SIOCDIFADDR, SIOCGIFINDEX, SIOCGIFADDR, SIOCGIFCONF, SIOCGIFNETMASK, SIOCAIFADDR, SIOCGIFMTU, SIOCSIFMTU, SIOCGIFMEDIA, SIOCSIFLLADDR and SIOCGIFXMEDIA.
	# 
	# Nintendo use the following definition (hence changing all ioctls using this structure):
	# 
	# `structbpf_program{`
	# `u_intbf_len;`
	# `structbpf_insnbf_insns[BPF_MAXINSNS];//[512].Thisisapointerintheofficialstructure`
	# `};`
	# 
	[19] Ioctl(u32, u32, u32, buffer<unknown,33,0>, buffer<unknown,33,0>, buffer<unknown,33,0>, buffer<unknown,33,0>) -> (u32, u32, buffer<unknown,34,0>, buffer<unknown,34,0>, buffer<unknown,34,0>, buffer<unknown,34,0>);
	# FreeBSD's `fcntl`, limited to `F_GETFL` and `F_SETFL` with `O_NONBLOCK`.
	# 
	[20] Fcntl(u32, u32, u32) -> (u32, u32);
	[21] SetSockOpt(u32, u32, u32, buffer<unknown,33,0>) -> (u32, u32);
	[22] Shutdown(u32, u32) -> (u32, u32);
	[23] ShutdownAllSockets(u32) -> (u32, u32);
	[24] Write(u32, buffer<unknown,33,0>) -> (u32, u32);
	[25] Read(u32) -> (u32, u32, buffer<unknown,34,0>);
	[26] Close(u32) -> (u32, u32);
	# Takes a socket file descriptor and an unused u64. Duplicates the socket (FreeBSD's `dup`). Reserved to `bsd:s`.
	# 
	[27] DuplicateSocket(u32, u64) -> (u32, u32);
	[28] GetResourceStatistics(u64, pid) -> (u32, u32, buffer<unknown,34,0>);
	@version(3.0.0+)
	[29] RecvMMsg(u32, u32, u32, u128) -> (u32, u32, buffer<unknown,34,0>);
	@version(3.0.0+)
	[30] SendMMsg(u32, u32, u32, buffer<unknown,33,0>, buffer<unknown,33,0>) -> (u32, u32);
}

interface nn::spl::detail::IGeneralInterface is spl: {
	# Wrapper for [GetConfig SMC](http://switchbrew.org/index.php?title=SMC#GetConfig "wikilink").
	# 
	# Takes a u32 (**ConfigItem**), and returns one or more u64s (**ConfigVal**).
	# 
	# | ConfigItem | Name                                                                                                                     |
	# |------------|--------------------------------------------------------------------------------------------------------------------------|
	# | 1          | [\#DisableProgramVerification](http://switchbrew.org/index.php?title=SPL services#DisableProgramVerification "wikilink") |
	# | 2          | [\#DramId](http://switchbrew.org/index.php?title=SPL services#DramId "wikilink")                                         |
	# | 3          | [\#SecurityEngineIrqNumber](http://switchbrew.org/index.php?title=SPL services#SecurityEngineIrqNumber "wikilink")       |
	# | 4          | [\#Version](http://switchbrew.org/index.php?title=SPL services#Version "wikilink")                                       |
	# | 5          | [\#HardwareType](http://switchbrew.org/index.php?title=SPL services#HardwareType "wikilink")                             |
	# | 6          | [\#IsRetail](http://switchbrew.org/index.php?title=SPL services#IsRetail "wikilink")                                     |
	# | 7          | [\#IsRecoveryBoot](http://switchbrew.org/index.php?title=SPL services#IsRecoveryBoot "wikilink")                         |
	# | 8          | [\#DeviceId](http://switchbrew.org/index.php?title=SPL services#DeviceId "wikilink")                                     |
	# | 9          | \[1.0.0-4.0.0\] [\#BootReason](http://switchbrew.org/index.php?title=SPL services#BootReason "wikilink")                 |
	# | 10         | [\#MemoryArrange](http://switchbrew.org/index.php?title=SPL services#MemoryArrange "wikilink")                           |
	# | 11         | [\#IsDebugMode](http://switchbrew.org/index.php?title=SPL services#IsDebugMode "wikilink")                               |
	# | 12         | [\#KernelMemoryConfiguration](http://switchbrew.org/index.php?title=SPL services#KernelMemoryConfiguration "wikilink")   |
	# | 13         | [\#IsChargerHiZModeEnabled](http://switchbrew.org/index.php?title=SPL services#IsChargerHiZModeEnabled "wikilink")       |
	# | 14         | \[4.0.0+\] [\#IsKiosk](http://switchbrew.org/index.php?title=SPL services#IsKiosk "wikilink")                            |
	# | 15         | \[5.0.0+\] [\#NewHardwareType](http://switchbrew.org/index.php?title=SPL services#NewHardwareType "wikilink")            |
	# | 16         | \[5.0.0+\] [\#NewKeyGeneration](http://switchbrew.org/index.php?title=SPL services#NewKeyGeneration "wikilink")          |
	# | 17         | \[5.0.0+\] [\#Package2Hash](http://switchbrew.org/index.php?title=SPL services#Package2Hash "wikilink")                  |
	# 
	[0] GetConfig(u32) -> u64;
	# Wrapper for [ExpMod SMC](http://switchbrew.org/index.php?title=SMC#ExpMod "wikilink").
	# 
	# Takes one type-10 (C descriptor) buffer (**data\_out\_buf**) and 3 type-9 (X descriptor) buffers (**data\_in\_buf**, **exp\_in\_buf** and **mod\_in\_buf**).
	# 
	# Performs asymmetric crypto with user supplied modulus and exponent.
	# 
	@undocumented
	[1] UserExpMod();
	# Wrapper for [GenerateAesKek SMC](http://switchbrew.org/index.php?title=SMC#GenerateAesKek "wikilink").
	# 
	# Takes a 16-byte EKS (**Encryption Key Source**) and two words (**KeyGeneration** and **option**) as input.
	# 
	# Returns a scrambled sealed KEK (**Key Encryption Key** used as **key\_x**).
	# 
	@undocumented
	[2] GenerateAesKek();
	# Wrapper for [LoadAesKey SMC](http://switchbrew.org/index.php?title=SMC#LoadAesKey "wikilink").
	# 
	# Takes a u32 (**keyslot**) and two 16-byte keys (**key\_x** and **key\_y**).
	# 
	# Sets the specified **keyslot** with a key generated from **key\_x** and **key\_y**.
	# 
	# \[2.0.0+\] Now verifies that the engine in use (0..3) is locked/owned by the current spl session, otherwise errors with 0xD21A. Previously engine was hardcoded to 0.
	# 
	@undocumented
	[3] LoadAesKey();
	# Takes a 16-byte KEK (**key\_x**) and a 16-byte encrypted key (**enc\_key**).
	# 
	# Generates a new key by decrypting (AES-ECB) **enc\_key** with a key generated from the supplied **key\_x** and a fixed **key\_y** set with [LoadAesKey SMC](http://switchbrew.org/index.php?title=SMC#LoadAesKey "wikilink").
	# 
	# \[2.0.0+\] Previously, it always used engine 0. Now it tries to allocate an engine to be used and returns 0xD01A if they're all busy. When the command is done, the engine is released.
	# 
	@undocumented
	[4] GenerateAesKey();
	# Wrapper for [SetConfig SMC](http://switchbrew.org/index.php?title=SMC#SetConfig "wikilink").
	# 
	# Takes a u32 (**ConfigItem**) and a u64 (**ConfigVal**).
	# 
	# | ConfigItem | Name           |
	# |------------|----------------|
	# | 13         | BatteryProfile |
	# 
	# Any other **ConfigItem**, besides 13, can't be set.
	# 
	@undocumented
	[5] SetConfig();
	# Takes a type-6 buffer and fills it with random data from [GetRandomBytes SMC](http://switchbrew.org/index.php?title=SMC#GetRandomBytes "wikilink"). Same command for spl: and csrng services.
	# 
	@undocumented
	[7] GetRandomBytes();
	# Wrapper for [LoadSecureExpModKey SMC](http://switchbrew.org/index.php?title=SMC#LoadSecureExpModKey "wikilink").
	# 
	# Takes one type-9 (X descriptor) buffer (**enc\_privk\_in\_buf**), a 16-byte KEK (**key\_x**), a 16-byte key (**key\_y**) and a u32 (**version**). **version** is 0 for normal keys or 1 for extended keys.
	# 
	# Decrypts **enc\_privk\_in\_buf** with a key generated from **key\_x** and **key\_y** and imports it for later usage.
	# 
	# \[5.0.0+\] This now calls [EncryptRsaKeyForImport SMC](http://switchbrew.org/index.php?title=SMC#EncryptRsaKeyForImport "wikilink") instead.
	# 
	@undocumented
	[9] LoadSecureExpModKey();
	# Takes 3 type-9 (X descriptor) buffers (**data\_in\_buf**, **mod\_in\_buf** and **param0\_in\_buf**).
	# 
	# Uses [SecureExpMod SMC](http://switchbrew.org/index.php?title=SMC#SecureExpMod "wikilink") to decrypt **data\_in\_buf** using the private key imported with [\#LoadSecureExpModKey](#nn::spl::detail::IGeneralInterface(9) "wikilink") and the supplied **mod\_in\_buf** and **param0\_in\_buf**.
	# 
	# Generates and returns a 16-byte sealed titlekey.
	# 
	@undocumented
	[10] SecureExpMod();
	# No input params.
	# 
	# Uses [\#GetConfig](#nn::spl::detail::IGeneralInterface(0) "wikilink") internally with id=6. Returns true if output from that is 0, or if the SMC returned error 2.
	# 
	# Returns an u8 flag for whether the system is devunit. Output flag is 0 on retail.
	# 
	[11] IsDevelopment() -> u8;
	# Wrapper for [GenerateSpecificAesKey SMC](http://switchbrew.org/index.php?title=SMC#GenerateSpecificAesKey "wikilink").
	# 
	# Takes a 16-byte seed (**key\_seed**) and two words (**KeyGeneration** and **option**) as input.
	# 
	# Returns a scrambled key (**key\_a**).
	# 
	@undocumented
	[12] GenerateSpecificAesKey();
	# Wrapper for [DecryptRsaPrivateKey SMC](http://switchbrew.org/index.php?title=SMC#DecryptRsaPrivateKey "wikilink").
	# 
	# Takes one type-10 (C descriptor) buffer (**dec\_privk\_out\_buf**), one type-9 (X descriptor) buffer (**enc\_privk\_in\_buf**), a 16-byte KEK (**key\_x**), a 16-byte key (**key\_y**) and a u32 (**version**). **version** is 0 for normal keys or 1 for extended keys.
	# 
	# Decrypts **enc\_privk\_in\_buf** into **dec\_privk\_out\_buf** with a key generated from **key\_x** and **key\_y**.
	# 
	# Used by [SSL](http://switchbrew.org/index.php?title=SSL_services "wikilink")-sysmodule for TLS client-privk.
	# 
	# \[5.0.0+\] This now calls [DecryptOrImportRsaKey SMC](http://switchbrew.org/index.php?title=SMC#DecryptOrImportRsaKey "wikilink") instead.
	# 
	@undocumented
	[13] DecryptRsaPrivateKey();
	# Takes a 16-byte encrypted key (**enc\_key**) and two words (**KeyGeneration** and **option**) as input.
	# 
	# Decrypts (AES-ECB) **enc\_key** with a key generated from fixed **key\_x** and **key\_y** set with [LoadAesKey SMC](http://switchbrew.org/index.php?title=SMC#LoadAesKey "wikilink") and returns a 16-byte decrypted key (**dec\_key**).
	# 
	# \[2.0.0+\] Introduced same engine allocation code as for [\#GenerateAesKey](#nn::spl::detail::IGeneralInterface(4) "wikilink").
	# 
	@undocumented
	[14] DecryptAesKey();
	# Takes a type-0x46 (B descriptor) buffer (**data\_out\_buf**), a u32 (**keyslot**), a type-0x45 (A descriptor) buffer (**data\_in\_buf**) and a 16-byte CTR (**aes\_ctr**).
	# 
	# Uses [CryptAes SMC](http://switchbrew.org/index.php?title=SMC#CryptAes "wikilink") to decrypt **data\_in\_buf** into **data\_out\_buf**, using the key set in the specified **keyslot**.
	# 
	# \[2.0.0+\] Verifies the engine is locked by current session.
	# 
	@undocumented
	[15] DecryptAesCtr();
	# Wrapper for [ComputeCmac SMC](http://switchbrew.org/index.php?title=SMC#ComputeCmac "wikilink").
	# 
	# Takes one type-9 (X descriptor) buffer (**data\_in\_buf**) and a u32 (**type?**).
	# 
	# Returns a 16-byte CMAC calculated over **data\_in\_buf**.
	# 
	# \[2.0.0+\] Verifies the engine is locked by current session.
	# 
	@undocumented
	[16] ComputeCmac();
	# Wrapper for [LoadRsaOaepKey SMC](http://switchbrew.org/index.php?title=SMC#LoadRsaOaepKey "wikilink").
	# 
	# Takes one type-9 (X descriptor) buffer (enc\_privk\_in\_buf), a 16-byte KEK (key\_x), a 16-byte key (key\_y) and a u32 (version). version is 0 for normal keys or 1 for extended keys.
	# 
	# Decrypts enc\_privk\_in\_buf with a key generated from key\_x and key\_y and imports it for later usage.
	# 
	@undocumented
	[17] LoadRsaOaepKey();
	# Wrapper for [UnwrapRsaOaepWrappedTitleKey SMC](http://switchbrew.org/index.php?title=SMC#UnwrapRsaOaepWrappedTitleKey "wikilink").
	# 
	# Takes one type-10 (C descriptor) buffer (**data\_out\_buf**) and 3 type-9 (X descriptor) buffers (**data\_in\_buf**, **mod\_in\_buf** and **label\_hash\_in\_buf**).
	# 
	# Decrypts **data\_in\_buf** into **data\_out\_buf** using the private key imported with [\#LoadRsaOaepKey](#nn::spl::detail::IGeneralInterface(17) "wikilink") and the supplied **mod\_in\_buf**. Afterwards, verifies RSA-OAEP encoding using **label\_hash\_in\_buf**.
	# 
	# Returns an u32 (**dec\_data\_size**).
	# 
	@undocumented
	[18] UnwrapRsaOaepWrappedTitleKey();
	# Wrapper for [LoadTitleKey SMC](http://switchbrew.org/index.php?title=SMC#LoadTitleKey "wikilink").
	# 
	# Takes a u32 (**keyslot**) and a 16-byte sealed titlekey.
	# 
	# Sets the specified **keyslot** with the titlekey.
	# 
	# \[2.0.0+\] Verifies the engine is locked by current session.
	# 
	@undocumented
	[19] LoadTitleKey();
	# Wrapper for [UnwrapAesWrappedTitleKey SMC](http://switchbrew.org/index.php?title=SMC#UnwrapAesWrappedTitleKey "wikilink").
	# 
	# Takes a 16-byte EKS (**Encryption Key Source**).
	# 
	# Returns a sealed titlekey.
	# 
	@version(2.0.0+)
	@undocumented
	[20] UnwrapAesWrappedTitleKey();
	# Returns the id of the engine that was locked, or 0xD01A if all engines are busy. You need to lock an engine before using AES functions.
	# 
	@version(2.0.0+)
	[21] LockAesEngine() -> u32;
	# Takes a single u32 and unlocks the engine with that id. It must be owned by current session otherwise 0xD21A will be returned.
	# 
	@version(2.0.0+)
	[22] UnlockAesEngine(u32);
	# Returns an event handle for synchronizing with the locked AES engine.
	# 
	@version(2.0.0+)
	[23] GetSplWaitEvent() -> KObject;
	# Sets a static dword in spl .bss to the user input u32.
	# 
	# \[4.0.0+\] returns 0xD41A if a value has been previously set without being [gotten](#nn::spl::detail::IGeneralInterface(25) "wikilink").
	# 
	@version(3.0.0+)
	@undocumented
	[24] SetSharedData();
	# Returns the static dword in spl .bss that can be set via [\#SetSharedData](#nn::spl::detail::IGeneralInterface(24) "wikilink").
	# 
	# \[4.0.0+\] returns 0xD61A if a value has not previously been set, and unsets the value after getting it.
	# 
	# [Category:Services](http://switchbrew.org/index.php?title=Category:Services "wikilink")
	# 
	@version(3.0.0+)
	@undocumented
	[25] GetSharedData();
	@version(5.0.0+)
	[26] ImportSslRsaKey();
	@version(5.0.0+)
	[27] SecureExpModWithSslKey();
	@version(5.0.0+)
	[28] ImportEsRsaKey();
	@version(5.0.0+)
	[29] SecureExpModWithEsKey();
	@version(5.0.0+)
	[30] EncryptManuRsaKeyForImport();
	@version(5.0.0+)
	[31] GetPackage2Hash();
}

interface nn::spl::detail::IRandomInterface is csrng {
	# Takes a type-6 buffer and fills it with random data from [GetRandomBytes SMC](http://switchbrew.org/index.php?title=SMC#GetRandomBytes "wikilink"). Same command for spl: and csrng services.
	# 
	[0] GetRandomBytes() -> buffer<unknown,6,0>;
}

interface nn::spsm::detail::IPowerStateInterface is spsm {
	[0] GetState() -> u32;
	[1] SleepSystemAndWaitAwake() -> KObject;
	[2] Unknown2() -> u32;
	[3] Unknown3(u8);
	[4] GetNotificationMessageEventHandle() -> KObject;
	[5] Unknown5() -> u32;
	@undocumented
	[6] Unknown6();
	[7] Unknown7();
	[8] AnalyzePerformanceLogForLastSleepWakeSequence() -> buffer<unknown,6,0>;
	[9] ChangeHomeButtonLongPressingTime(u64);
	[10] Unknown10();
	@version(1.0.0-3.0.2)
	[11] Unknown11(u64);
}

interface nn::srepo::detail::ipc::ISrepoService is srepo:u, srepo:a {
	[0] Unknown0();
	[1] Unknown1();
	[2] Unknown2();
}

interface nn::ssl::sf::ISslConnection {
	[0] SetSocketDescriptor(i32) -> i32;
	[1] SetHostName(buffer<unknown,5,0>);
	[2] SetVerifyOption(nn::ssl::sf::VerifyOption);
	[3] SetIoMode(nn::ssl::sf::IoMode);
	[4] GetSocketDescriptor() -> i32;
	[5] GetHostName() -> (u32, buffer<unknown,6,0>);
	[6] GetVerifyOption() -> nn::ssl::sf::VerifyOption;
	[7] GetIoMode() -> nn::ssl::sf::IoMode;
	[8] DoHandshake();
	[9] DoHandshakeGetServerCert() -> (u32, u32, buffer<unknown,6,0>);
	[10] Read() -> (u32, buffer<unknown,6,0>);
	[11] Write(buffer<unknown,5,0>) -> u32;
	[12] Pending() -> i32;
	[13] Peek() -> (u32, buffer<unknown,6,0>);
	[14] Poll(nn::ssl::sf::PollEvent, u32) -> nn::ssl::sf::PollEvent;
	[15] GetVerifyCertError();
	[16] GetNeededServerCertBufferSize() -> u32;
	[17] SetSessionCacheMode(nn::ssl::sf::SessionCacheMode);
	[18] GetSessionCacheMode() -> nn::ssl::sf::SessionCacheMode;
	[19] FlushSessionCache();
	[20] SetRenegotiationMode(nn::ssl::sf::RenegotiationMode);
	[21] GetRenegotiationMode() -> nn::ssl::sf::RenegotiationMode;
	[22] SetOption(bool, nn::ssl::sf::OptionType);
	[23] GetOption(nn::ssl::sf::OptionType) -> bool;
	[24] GetVerifyCertErrors() -> (u32, u32, buffer<unknown,6,0>);
	@version(4.0.0+)
	[25] GetCipherInfo();
}

interface nn::ssl::sf::ISslContext {
	[0] SetOption(nn::ssl::sf::ContextOption, i32);
	[1] GetOption(nn::ssl::sf::ContextOption) -> i32;
	[2] CreateConnection() -> object<nn::ssl::sf::ISslConnection>;
	[3] GetConnectionCount() -> u32;
	[4] ImportServerPki(nn::ssl::sf::CertificateFormat, buffer<unknown,5,0>) -> u64;
	[5] ImportClientPki(buffer<unknown,5,0>, buffer<unknown,5,0>) -> u64;
	[6] RemoveServerPki(u64);
	[7] RemoveClientPki(u64);
	[8] RegisterInternalPki(nn::ssl::sf::InternalPki) -> u64;
	[9] AddPolicyOid(buffer<unknown,5,0>);
	[10] ImportCrl(buffer<unknown,5,0>) -> u64;
	[11] RemoveCrl(u64);
}

interface nn::ssl::sf::ISslService is ssl {
	[0] CreateContext(nn::ssl::sf::SslVersion, u64, pid) -> object<nn::ssl::sf::ISslContext>;
	[1] GetContextCount() -> u32;
	[2] GetCertificates(buffer<unknown,5,0>) -> (u32, buffer<unknown,6,0>);
	[3] GetCertificateBufSize(buffer<unknown,5,0>) -> u32;
	[4] DebugIoctl(u64, buffer<unknown,5,0>) -> buffer<unknown,6,0>;
	[5] SetInterfaceVersion(u32);
	@version(5.0.0+)
	[6] FlushSessionCache();
}

interface nn::tc::IManager is tc {
	[0] SetOperatingMode(u32);
	[1] GetThermalEvent(u32) -> KObject;
	[2] Unknown2(u32) -> u8;
	[3] Unknown3(u32);
	[4] Unknown4(u32);
	[5] Unknown5(u32, u32);
	[6] Unknown6();
	[7] Unknown7();
	[8] Unknown8() -> u8;
}

interface nn::timesrv::detail::service::IStaticService is time:s, time:u, time:r, time:a {
	[0] GetStandardUserSystemClock() -> object<nn::timesrv::detail::service::ISystemClock>;
	[1] GetStandardNetworkSystemClock() -> object<nn::timesrv::detail::service::ISystemClock>;
	[2] GetStandardSteadyClock() -> object<nn::timesrv::detail::service::ISteadyClock>;
	[3] GetTimeZoneService() -> object<nn::timesrv::detail::service::ITimeZoneService>;
	[4] GetStandardLocalSystemClock() -> object<nn::timesrv::detail::service::ISystemClock>;
	@version(4.0.0+)
	[5] GetEphemeralNetworkSystemClock();
	@version(4.0.0+)
	[50] SetStandardSteadyClockInternalOffset();
	[100] IsStandardUserSystemClockAutomaticCorrectionEnabled() -> bool;
	[101] SetStandardUserSystemClockAutomaticCorrectionEnabled(bool);
	@version(5.0.0+)
	[102] GetStandardUserSystemClockInitialYear();
	@version(3.0.0+)
	[200] IsStandardNetworkSystemClockAccuracySufficient() -> bool;
	@version(4.0.0+)
	[300] CalculateMonotonicSystemClockBaseTimePoint();
	@version(4.0.0+)
	[400] GetClockSnapshot();
	@version(4.0.0+)
	[401] GetClockSnapshotFromSystemClockContext();
	@version(4.0.0+)
	[500] CalculateStandardUserSystemClockDifferenceByUser();
	@version(4.0.0+)
	[501] CalculateSpanBetween();
}

interface nn::timesrv::detail::service::ISteadyClock {
	[0] GetCurrentTimePoint() -> nn::time::SteadyClockTimePoint;
	[2] GetTestOffset() -> nn::TimeSpanType;
	[3] SetTestOffset(nn::TimeSpanType);
	@version(2.0.0+)
	[100] GetRtcValue() -> i64;
	@version(2.0.0+)
	[101] IsRtcResetDetected() -> bool;
	@version(2.0.0+)
	[102] GetSetupResultValue() -> u32;
	@version(3.0.0+)
	[200] GetInternalOffset() -> nn::TimeSpanType;
	@version(3.0.0-3.0.2)
	[201] SetInternalOffset(nn::TimeSpanType);
}

interface nn::timesrv::detail::service::ISystemClock {
	[0] GetCurrentTime() -> nn::time::PosixTime;
	[1] SetCurrentTime(nn::time::PosixTime);
	[2] GetSystemClockContext() -> nn::time::SystemClockContext;
	[3] SetSystemClockContext(nn::time::SystemClockContext);
}

interface nn::timesrv::detail::service::ITimeZoneService {
	[0] GetDeviceLocationName() -> nn::time::LocationName;
	[1] SetDeviceLocationName(nn::time::LocationName);
	[2] GetTotalLocationNameCount() -> i32;
	[3] LoadLocationNameList(i32) -> (i32, array<nn::time::LocationName,6>);
	[4] LoadTimeZoneRule(nn::time::LocationName) -> buffer<nn::time::TimeZoneRule,22,16384>;
	@version(2.0.0+)
	[5] GetTimeZoneRuleVersion() -> nn::time::TimeZoneRuleVersion;
	[100] ToCalendarTime(nn::time::PosixTime, buffer<nn::time::TimeZoneRule,21,16384>) -> (nn::time::CalendarTime, nn::time::sf::CalendarAdditionalInfo);
	[101] ToCalendarTimeWithMyRule(nn::time::PosixTime) -> (nn::time::CalendarTime, nn::time::sf::CalendarAdditionalInfo);
	[201] ToPosixTime(nn::time::CalendarTime, buffer<nn::time::TimeZoneRule,21,16384>) -> (i32, array<nn::time::PosixTime,10>);
	[202] ToPosixTimeWithMyRule(nn::time::CalendarTime) -> (i32, array<nn::time::PosixTime,10>);
}

interface nn::tma::IHtcManager is htc {
	[0] GetEnvironmentVariable(buffer<unknown,5,0>) -> (u32, buffer<unknown,6,0>);
	[1] GetEnvironmentVariableLength(buffer<unknown,5,0>) -> u32;
	[2] BindHostConnectionEvent() -> KObject;
	[3] BindHostDisconnectionEvent() -> KObject;
	[4] BindHostConnectionEventForSystem() -> KObject;
	[5] BindHostDisconnectionEventForSystem() -> KObject;
	@version(3.0.0+)
	[6] GetBridgeIpAddress() -> buffer<unknown,6,0>;
	@version(3.0.0+)
	[7] GetBridgePort() -> buffer<unknown,6,0>;
	@version(3.0.0+)
	[8] SetUsbDetachedForDebug(u8);
	@version(4.0.0+)
	[9] GetBridgeSubnetMask();
	@version(4.0.0+)
	[10] GetBridgeMacAddress();
}

interface nn::tma::IHtcsManager is htcs {
	[0] Unknown0() -> (u32, u32);
	[1] Unknown1(u32) -> (u32, u32);
	[2] Unknown2(bytes<66>, u32) -> (u32, u32);
	[3] Unknown3(bytes<66>, u32) -> (u32, u32);
	[4] Unknown4(u32, u32) -> (u32, u32);
	[5] Unknown5(u32) -> (bytes<66>, u32, u32);
	[6] Unknown6(u32, u32) -> (u32, u64, buffer<unknown,6,0>);
	[7] Unknown7(u32, u32, buffer<unknown,5,0>) -> (u32, u64);
	[8] Unknown8(u32, u32) -> (u32, u32);
	[9] Unknown9(u32, u32, u32) -> (u32, u32);
	[10] GetPeerNameAny() -> bytes<32>;
	[11] GetDefaultHostName() -> bytes<32>;
	[12] CreateSocketOld() -> (u32, object<IUnknown>);
	[13] CreateSocket(u8) -> (u32, object<IUnknown>);
	[100] RegisterProcessId(u64, pid);
	[101] MonitorManager(u64, pid);
}

interface nn::tma::ISocket {
	[0] Close() -> (u32, u32);
	[1] Connect(bytes<66>) -> (u32, u32);
	[2] Bind(bytes<66>) -> (u32, u32);
	[3] Listen(u32) -> (u32, u32);
	[4] Accept() -> (bytes<66>, u32, object<IUnknown>);
	[5] Recv(u32) -> (u32, u64, buffer<unknown,34,0>);
	[6] Send(u32, buffer<unknown,33,0>) -> (u32, u64);
	[7] Shutdown(u32) -> (u32, u32);
	[8] Fcntl(u32, u32) -> (u32, u32);
}

interface nn::ts::server::IMeasurementServer is ts {
	@undocumented
	[0] Unknown0();
	@undocumented
	[1] Unknown1();
	@undocumented
	[2] Unknown2();
	@undocumented
	[3] Unknown3();
}

interface nn::uart::IManager is uart {
	[0] DoesUartExist(u32) -> u8;
	[1] DoesUartExistForTest(u32) -> u8;
	@undocumented
	[2] SetUartBaudrate();
	@undocumented
	[3] SetUartBaudrateForTest();
	@undocumented
	[4] IsSomethingUartValid();
	@undocumented
	[5] IsSomethingUartValidForTest();
	[6] GetSession() -> object<IUnknown>;
	@undocumented
	[7] IsSomethingUartValid2();
	@undocumented
	[8] IsSomethingUartValid2ForTest();
}

interface nn::uart::IPortSession {
	@undocumented
	[0] OpenSession();
	@undocumented
	[1] OpenSessionForTest();
	[2] Unknown2() -> u64;
	@undocumented
	[3] Unknown3();
	[4] Unknown4() -> u64;
	@undocumented
	[5] Unknown5();
	@undocumented
	[6] Unknown6();
	[7] Unknown7(u32) -> u8;
}

interface nn::usb::ds::IDsEndpoint {
	# Takes an u32 (**size**) and an u64 (**buffer**). Returns an output u32 (**urbId**). The output urbId can then be used while parsing the output of [\#GetReportData](#nn::usb::ds::IDsEndpoint(3) "wikilink"), after waiting for the CompletionEvent to be signalled.
	# 
	# The buffer address must be 0x1000-byte aligned. The input size doesn't matter. It helps to use svcSetMemoryAttribute to turn off caching on the buffer.
	# 
	# Used for data-transfer with input/output endpoints.
	# 
	# The user-process must flush dcache for the buffer before using this command.
	# 
	# When sending data where size is larger than wMaxPacketSize, it will automatically send multiple USB packets where last packet size = {remaining size}. Every {wMaxPacketSize}-bytes is a different packet. This only occurs in some cases. When **size** is ~0x1000000(exact size unknown), Switch-side silently hangs, while host-side will timeout(no traffic on USB bus indicating failure).
	# 
	# For receiving data, if size is less than {actual received USB packet size} the rest of the packet will be discarded. Later PostBufferAsync cmd(s) will only return data from new packets, not the remainder of the earlier packet(s).
	# 
	@undocumented
	[0] PostBufferAsync();
	@undocumented
	[1] Unknown1();
	# No input. Returns an output event handle for polling the completion of [\#PostBufferAsync](#nn::usb::ds::IDsEndpoint(0) "wikilink"), even when it finished via [\#Stall](#nn::usb::ds::IDsEndpoint(4) "wikilink").
	# 
	@undocumented
	[2] GetCompletionEvent();
	# No input. Returns 0x84 bytes of report data from the endpoint. Seems to be eventually loaded from state, since this doesn't trigger any USB bus activity. All-zero before PostBufferAsync was used at least once.
	# 
	# | Offset | Size            | Description                                  |
	# |--------|-----------------|----------------------------------------------|
	# | 0x0    | 0x10\*0x8(0x80) | 0x8 entries 0x10-bytes each for each report. |
	# | 0x80   | 0x4             | u32 report count                             |
	# 
	# Entry data:
	# 
	# | Offset | Size | Description                                                                                                        |
	# |--------|------|--------------------------------------------------------------------------------------------------------------------|
	# | 0x0    | 0x4  | u32 id (urbId from post-buffer commands)                                                                           |
	# | 0x4    | 0x4  | u32 requestedSize                                                                                                  |
	# | 0x8    | 0x4  | u32 transferredSize                                                                                                |
	# | 0xC    | 0x4  | u32 urb status, converted to error-codes. 0x3 = success, 0x4 = 0x828c, 0x5 = 0x748c. All other values are invalid. |
	# |        |      |                                                                                                                    |
	# 
	@undocumented
	[3] GetReportData();
	# No input/output.
	# 
	# Calls the same function used by [\#StallCtrl](#nn::usb::ds::IDsInterface(11) "wikilink"), except this uses the endpoint associated with the current session.
	# 
	# Stops in-progress data-transfer done by [\#PostBufferAsync](#nn::usb::ds::IDsEndpoint(0) "wikilink").
	# 
	@undocumented
	[4] Stall();
	@undocumented
	[5] Unknown5();
}

interface nn::usb::ds::IDsInterface {
	# Takes a type-5 buffer and returns an [\#IDsEndpoint](#nn::usb::ds::IDsEndpoint "wikilink"). [Manu](http://switchbrew.org/index.php?title=Manu_Services "wikilink") uses this twice for getting two endpoint sessions, with the following 0x7-byte buffer data:
	# 
	# -   First endpoint: 0x07, 0x05, 0x80, 0x02, 0x00, 0x02, 0x00
	#     -   bLength=0x7
	#     -   bDescriptorType=LIBUSB\_DT\_ENDPOINT
	#     -   bEndpointAddress=LIBUSB\_ENDPOINT\_IN
	#     -   bmAttributes=LIBUSB\_TRANSFER\_TYPE\_BULK
	#     -   wMaxPacketSize=0x200
	#     -   bInterval=0
	# -   Second endpoint: Same as above except byte2 is 0x00(bEndpointAddress=LIBUSB\_ENDPOINT\_OUT).
	# 
	# Each field is an u8, except for offset 0x4-0x5 which is an u16.
	# 
	# This structure matches [libusb\_endpoint\_descriptor](http://switchbrew.org/index.php?title=http://libusb.sourceforge.net/api-1.0/structlibusb__endpoint__descriptor.html), with audio-only-devices fields bRefresh and bSynchAddress removed.
	# 
	# The buffer size must be &gt;=0x7. Only the first 0x7-bytes from the buffer are used.
	# 
	# -   Byte0(bLength) must match 0x7.
	# -   Byte1(bDescriptorType) must match 0x5.
	# -   Byte2(bEndpointAddress) is only compared with 0x80 to determine whether to use an input or output endpoint, the actual endpoint-number is allocated automatically by checking state. Hence, all input endpoints must use bEndpointAddress==0x80. Up to endpoint-number 0xF can be allocated for each endpoint-direction, for a total of 16 endpoints including control, and 15 for non-control endpoints([\#IDsEndpoint](#nn::usb::ds::IDsEndpoint "wikilink") sessions for each direction). This matches the Tegra maximum.
	# 
	# From the Tegra datasheet: The maximum packet size supported on any endpoint is 1024 bytes in high-speed mode, for both device and host modes.
	# 
	@undocumented
	[0] GetDsEndpoint();
	# Returns an event handle. Unknown what triggers signalling, not signalled during interface-enable / device&lt;&gt;host USB-comms init.
	# 
	@undocumented
	[1] GetSetupEvent();
	@undocumented
	[2] Unknown2();
	# Takes no arguments. Enables the current interface.
	# 
	# Only one interface can be enabled at a time per bInterfaceNumber. When bInterfaceNumber is auto-allocate(0x4) for [\#GetDsEndpoint](#nn::usb::ds::IDsInterface(0) "wikilink") this isn't an issue since the final bInterfaceNumber will be unique.
	# 
	# Once enabled, the device/interface can then actually be used over USB.
	# 
	@undocumented
	[3] EnableInterface();
	# Takes no arguments. Disables the current interface.
	# 
	@undocumented
	[4] DisableInterface();
	# Same as [\#PostBufferAsync](#nn::usb::ds::IDsEndpoint(0) "wikilink")(with same input/output), except this uses control input endpoint 0x80.
	# 
	@undocumented
	[5] CtrlInPostBufferAsync();
	# Same as [\#PostBufferAsync](#nn::usb::ds::IDsEndpoint(0) "wikilink")(with same input/output), except this uses control output endpoint 0x00.
	# 
	@undocumented
	[6] CtrlOutPostBufferAsync();
	# Returns an event handle for polling the completion of input control commands. Same as [\#GetCompletionEvent](#nn::usb::ds::IDsEndpoint(2) "wikilink"), except this uses control input endpoint 0x80.
	# 
	@undocumented
	[7] GetCtrlInCompletionEvent();
	# Same as [\#GetReportData](#nn::usb::ds::IDsEndpoint(3) "wikilink")(with same input/output), except this uses control input endpoint 0x80.
	# 
	@undocumented
	[8] GetCtrlInReportData();
	# Returns an event handle for polling the completion of output control commands. Same as [\#GetCompletionEvent](#nn::usb::ds::IDsEndpoint(2) "wikilink"), except this uses control output endpoint 0x00.
	# 
	@undocumented
	[9] GetCtrlOutCompletionEvent();
	# Same as [\#GetReportData](#nn::usb::ds::IDsEndpoint(3) "wikilink")(with same input/output), except this uses control output endpoint 0x00.
	# 
	@undocumented
	[10] GetCtrlOutReportData();
	# No input/output.
	# 
	# Calls a function with both control endpoints(0x80 and 0x00) with the same function. From strings: m\_pProtocol-&gt;Stall(0x80) m\_pProtocol-&gt;Stall(0x00).
	# 
	@undocumented
	[11] StallCtrl();
	@version(5.0.0+)
	[12] AppendConfigurationData();
}

interface nn::usb::ds::IDsService is usb:ds {
	# Takes an u32 (**complexId**). [Manu](http://switchbrew.org/index.php?title=Manu_Services "wikilink") sends 0x02.
	# 
	# Binding more than once with the current session is not allowed. Once this command is used, the USB device will not be listed with `lsusb` until [\#EnableInterface](#nn::usb::ds::IDsInterface(3) "wikilink") is used.
	# 
	# Returns a not-found error when complexId isn't 0x02, for values 0x0-0x4 at least.
	# 
	@undocumented
	[0] BindDevice();
	# Takes 1 copy-handle for the current process (0xFFFF8001).
	# 
	@undocumented
	[1] BindClientProcess();
	# Takes 2 type-5 buffers and returns an [\#IDsInterface](#nn::usb::ds::IDsInterface "wikilink"). [Manu](http://switchbrew.org/index.php?title=Manu_Services "wikilink") sends a 0x09-byte command (e.g.: 0x09, 0x04, 0x04, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00) in the first buffer and a string (usb) in the second buffer.
	# 
	# When the strlen output for the second buffer is &gt;=0x40, size 0x40 is used instead for copying the string. This is the interface name, it's not sent over USB.
	# 
	# Returns an error when [\#BindDevice](#nn::usb::ds::IDsService(0) "wikilink") wasn't used.
	# 
	# Up to 4 interfaces can be used+[enabled](#nn::usb::ds::IDsInterface(3) "wikilink").
	# 
	# Structure of the first buffer(this is the same as [libusb\_\_interface\_\_descriptor](http://switchbrew.org/index.php?title=http://libusb.sourceforge.net/api-1.0/structlibusb__interface__descriptor.html)):
	# 
	# | Offset | Size | Description                                                                                                                                                      |
	# |--------|------|------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	# | 0x0    | 0x1  | bLength. Must match 0x9.                                                                                                                                         |
	# | 0x1    | 0x1  | bDescriptorType. Must match 0x4.                                                                                                                                 |
	# | 0x2    | 0x1  | bInterfaceNumber. When 0x4, the bInterfaceNumber is automatically allocated(error will be thrown if no space). Otherwise, it's used directly and must be &lt;=3. |
	# | 0x3    | 0x1  | bAlternateSetting. Must match 0x0.                                                                                                                               |
	# | 0x4    | 0x1  | bNumEndpoints. Ignored.                                                                                                                                          |
	# | 0x5    | 0x1  | bInterfaceClass                                                                                                                                                  |
	# | 0x6    | 0x1  | bInterfaceSubClass                                                                                                                                               |
	# | 0x7    | 0x1  | bInterfaceProtocol                                                                                                                                               |
	# | 0x8    | 0x1  | iInterface. Ignored.                                                                                                                                             |
	# 
	# Only the first 0x9-bytes are used.
	# 
	@undocumented
	[2] GetDsInterface();
	# Returns an event handle for when the state returned by [\#GetState](#nn::usb::ds::IDsService(4) "wikilink") changes. Signalled when Switch&lt;-&gt;host USB comms change between started/stopped. USB cable connected/disconnected while at least 1 interface was enabled, or interface enabled/disabled while the USB cable was connected which then caused USB-comms state to change.
	# 
	@undocumented
	[3] GetStateChangeEvent();
	# No input. Returns an output u32. Returns an error when [\#BindDevice](#nn::usb::ds::IDsService(0) "wikilink") wasn't used.
	# 
	# Returns the current state. Values:
	# 
	# -   0: Initial state.
	# -   6: Device init starting.
	# -   3: {Initialization}, previous state is 6.
	# -   4: {Initialization}, previous state is 3.
	# -   5: Initialization done, data-transfer is now available.
	# 
	@undocumented
	[4] GetState();
	# Takes a type-5 buffer with 0x66 bytes of USB descriptor data (see [manu](http://switchbrew.org/index.php?title=Manu_Services#manu "wikilink")).
	# 
	# | Offset | Size | Description     |
	# |--------|------|-----------------|
	# | 0x0    | 0x2  | VID (idVendor)  |
	# | 0x2    | 0x2  | PID (idProduct) |
	# | 0x4    | 0x2  | bcdDevice       |
	# | 0x6    | 0x20 | Manufacturer    |
	# | 0x26   | 0x20 | Product         |
	# | 0x46   | 0x20 | SerialNumber    |
	# 
	# The last 3 blocks are ASCII strings. The data following each string is all-zero, for padding to size 0x20.
	# 
	@version(2.0.0-4.1.0)
	@undocumented
	[5] SetVidPidBcd();
	@version(5.0.0+)
	@undocumented
	[5] ClearDeviceData();
	@version(5.0.0+)
	[6] AddUsbStringDescriptor();
	@version(5.0.0+)
	[7] DeleteUsbStringDescriptor();
	@version(5.0.0+)
	[8] SetUsbDeviceDescriptor();
	@version(5.0.0+)
	[9] SetBinaryObjectStore();
	@version(5.0.0+)
	[10] Enable();
	@version(5.0.0+)
	[11] Disable();
}

interface nn::usb::hs::IClientEpSession {
	[0] Unknown0();
	[1] Unknown1();
	[2] Unknown2() -> KObject;
	[3] Unknown3();
	@undocumented
	[4] PostBufferAsync();
	@undocumented
	[5] Unknown5();
	@undocumented
	[6] Unknown6();
	@version(4.0.0+)
	[7] Unknown7();
	@version(4.0.0+)
	[8] Unknown8();
}

interface nn::usb::hs::IClientIfSession {
	[0] Unknown0() -> KObject;
	@undocumented
	[1] Unknown1();
	@undocumented
	[2] Unknown2();
	@undocumented
	[3] Unknown3();
	[4] Unknown4() -> u32;
	@undocumented
	[5] CtrlXferAsync();
	[6] Unknown6() -> KObject;
	@undocumented
	[7] GetCtrlXferReport();
	[8] Unknown8();
	@undocumented
	[9] GetClientEpSession();
}

interface nn::usb::hs::IClientRootSession is usb:hs {
	@undocumented
	[0] BindClientProcess();
	@undocumented
	[1] Unknown1();
	@undocumented
	[2] Unknown2();
	@undocumented
	[3] Unknown3();
	@undocumented
	[4] Unknown4();
	[5] Unknown5(u8);
	[6] GetInterfaceStateChangeEvent() -> KObject;
	@undocumented
	[7] GetClientIfSession();
}

interface nn::usb::pd::detail::IPdCradleManager is usb:pd:c {
	[0] GetPdCradleSession() -> object<IUnknown>;
}

interface nn::usb::pd::detail::IPdCradleSession {
	[0] VdmUserWrite(u32, u32);
	[1] VdmUserRead(u32) -> u32;
	[2] Vdm20Init();
	@undocumented
	[3] GetFwType();
	@undocumented
	[4] GetFwRevision();
	@undocumented
	[5] GetManufacturerId();
	@undocumented
	[6] GetDeviceId();
	@version(3.0.0+)
	[7] Unknown7() -> u8;
	@version(3.0.0+)
	[8] Unknown8() -> u8;
}

interface nn::usb::pd::detail::IPdManager is usb:pd {
	[0] GetPdSession() -> object<IUnknown>;
}

interface nn::usb::pd::detail::IPdSession {
	[0] BindNoticeEvent() -> KObject;
	[1] Unknown1();
	@undocumented
	[2] GetStatus();
	[3] GetNotice() -> u32;
	[4] Unknown4();
	[5] Unknown5();
	[6] ReplyPowerRequest(u8);
}

interface nn::usb::pm::IPmService is usb:pm {
	[0] Unknown0() -> KObject;
	@undocumented
	[1] Unknown1();
	[2] Unknown2() -> KObject;
	[3] Unknown3() -> u32;
	[4] Unknown4(u32, u32);
	@undocumented
	[5] Unknown5();
}

interface nn::visrv::sf::IApplicationDisplayService {
	# Returns an [IHOSBinderDriver](http://switchbrew.org/index.php?title=Nvnflinger_services#dispdrv "wikilink") interface which abstracts nn::visrv::[service::RelayServiceImpl](http://switchbrew.org/index.php?title=service::RelayServiceImpl).
	# 
	[100] GetRelayService() -> object<nns::hosbinder::IHOSBinderDriver>;
	# Returns an [\#ISystemDisplayService](#nn::visrv::sf::ISystemDisplayService "wikilink").
	# 
	[101] GetSystemDisplayService() -> object<nn::visrv::sf::ISystemDisplayService>;
	# Returns an [\#IManagerDisplayService](#nn::visrv::sf::IManagerDisplayService "wikilink").
	# 
	[102] GetManagerDisplayService() -> object<nn::visrv::sf::IManagerDisplayService>;
	# Returns an [IHOSBinderDriver](http://switchbrew.org/index.php?title=Nvnflinger_services#dispdrv "wikilink") interface which abstracts nn::visrv::[service::IndirectDisplayTransactionServiceImpl](http://switchbrew.org/index.php?title=service::IndirectDisplayTransactionServiceImpl).
	# 
	@version(2.0.0+)
	[103] GetIndirectDisplayTransactionService() -> object<nns::hosbinder::IHOSBinderDriver>;
	# Takes a type-0x6 output buffer containing the array of [\#DisplayInfo](http://switchbrew.org/index.php?title=Display services#DisplayInfo "wikilink") output entries. Returns an output u64: total number of output entries.
	# 
	# Normally(?) this only returns the Default display.
	# 
	[1000] ListDisplays() -> (i64, array<nn::vi::DisplayInfo,6>);
	# Takes a [\#DisplayName](http://switchbrew.org/index.php?title=Display services#DisplayName "wikilink") as input. Returns an output u64, the DisplayId.
	# 
	# To open the default display, input string Default can be used.
	# 
	[1010] OpenDisplay(nn::vi::DisplayName) -> u64;
	# Returns an output u64.
	# 
	# Probably not (?) used by newer official user-processes, since those use OpenDisplay with the default string instead.
	# 
	[1011] OpenDefaultDisplay() -> u64;
	# Takes an input u64, DisplayId.
	# 
	[1020] CloseDisplay(u64);
	# Takes an input u32 boolean, and an u64(DisplayId?).
	# 
	[1101] SetDisplayEnabled(bool, u64);
	# Takes an input u64 DisplayId and returns two output u64s: width and height.
	# 
	[1102] GetDisplayResolution(u64) -> (i64, i64);
	# Takes a PID-descriptor, a type-0x6 buffer for the output [\#NativeWindow](http://switchbrew.org/index.php?title=Display services#NativeWindow "wikilink"), a [\#DisplayName](http://switchbrew.org/index.php?title=Display services#DisplayName "wikilink")(which was previously used with [\#OpenDisplay](#nn::visrv::sf::IApplicationDisplayService(1010) "wikilink")), an u64 LayerId, and an u64 [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"). Returns an output u64 NativeWindow\_Size.
	# 
	# Official user-processes use a LayerId stored in a global state field(...ExternalLayerId) if non-zero, otherwise:
	# 
	# -   When AppletResourceUserId==0, [\#CreateStrayLayer](#nn::visrv::sf::IApplicationDisplayService(2030) "wikilink") is used instead of the OpenLayer cmd.
	# -   When AppletResourceUserId!=0, [AM\_services\#CreateManagedDisplayLayer](http://switchbrew.org/index.php?title=AM_services#CreateManagedDisplayLayer "wikilink") is used and the output from that is used for LayerId with the OpenLayer cmd.
	# 
	# This OpenLayer command returns error 0x272 when the AppletResourceUserId is invalid.
	# 
	[2020] OpenLayer(nn::vi::DisplayName, u64, nn::applet::AppletResourceUserId, pid) -> (i64, buffer<unknown,6,0>);
	# Takes an input u64: LayerId which was used with [\#OpenLayer](#nn::visrv::sf::IApplicationDisplayService(2020) "wikilink").
	# 
	[2021] CloseLayer(u64);
	# Takes a type-0x6 buffer for the output [\#NativeWindow](http://switchbrew.org/index.php?title=Display services#NativeWindow "wikilink"), an u32(LayerFlags bitmask), and an u64 DisplayId. Returns two output u64s: LayerId and NativeWindow\_Size.
	# 
	[2030] CreateStrayLayer(u32, u64) -> (u64, i64, buffer<unknown,6,0>);
	# Takes an input u64: LayerId from [\#CreateStrayLayer](#nn::visrv::sf::IApplicationDisplayService(2030) "wikilink").
	# 
	[2031] DestroyStrayLayer(u64);
	# Takes an input u64(ScalingMode) and u64 (LayerId).
	# 
	[2101] SetLayerScalingMode(u32, u64);
	@version(5.0.0+)
	[2102] ConvertScalingMode();
	# Takes a PID-descriptor, an type-0x46 buffer, and four u64s: width(s32), height(s32),
	# 
	# <output from [[AM_services|AM]] GetIndirectLayerConsumerHandle>
	# , and [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"). Returns two output u64s.
	# 
	[2450] GetIndirectLayerImageMap(i64, i64, u64, nn::applet::AppletResourceUserId, pid) -> (i64, i64, buffer<unknown,70,0>);
	# Takes a PID-descriptor, an type-0x46 buffer, four floats, four u64s(last u64 is [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink")). Returns two output u64s. The floats are stored immediately after each other(32bits).
	# 
	[2451] GetIndirectLayerImageCropMap(f32, f32, f32, f32, i64, i64, u64, nn::applet::AppletResourceUserId, pid) -> (i64, i64, buffer<unknown,70,0>);
	# Takes two input u64s: with and height. Returns two output u64s. First u64 is the buffer size to use with the ImageMap cmds.
	# 
	[2460] GetIndirectLayerImageRequiredMemoryInfo(i64, i64) -> (i64, i64);
	# Takes an input u64 DisplayId and returns a handle.
	# 
	[5202] GetDisplayVsyncEvent(u64) -> KObject;
	# Takes an input u64 DisplayId and returns a handle.
	# 
	[5203] GetDisplayVsyncEventForDebug(u64) -> KObject;
}

interface nn::visrv::sf::IApplicationRootService is vi:u {
	# Returns an [\#IApplicationDisplayService](#nn::visrv::sf::IApplicationDisplayService "wikilink"). Takes an input u32, user-processes use 0 or 1, with 0 for regular-applications normally. 0 = user-service(vi:u), 1 = non-user-service? Returns an error when using value 1 with vi:u(same error listed below for IApplicationDisplayService for unavailable commands).
	# 
	[0] GetDisplayService(u32) -> object<nn::visrv::sf::IApplicationDisplayService>;
}

interface nn::visrv::sf::IManagerDisplayService {
	@version(4.0.0+)
	[200] AllocateProcessHeapBlock();
	@version(4.0.0+)
	[201] FreeProcessHeapBlock();
	[1102] GetDisplayResolution(u64) -> (i64, i64);
	[2010] CreateManagedLayer(u32, u64, nn::applet::AppletResourceUserId) -> u64;
	[2011] DestroyManagedLayer(u64);
	[2050] CreateIndirectLayer() -> u64;
	[2051] DestroyIndirectLayer(u64);
	[2052] CreateIndirectProducerEndPoint(u64, nn::applet::AppletResourceUserId) -> u64;
	[2053] DestroyIndirectProducerEndPoint(u64);
	[2054] CreateIndirectConsumerEndPoint(u64, nn::applet::AppletResourceUserId) -> u64;
	[2055] DestroyIndirectConsumerEndPoint(u64);
	[2300] AcquireLayerTexturePresentingEvent(u64) -> KObject;
	[2301] ReleaseLayerTexturePresentingEvent(u64);
	[2302] GetDisplayHotplugEvent(u64) -> KObject;
	[2402] GetDisplayHotplugState(u64) -> u32;
	@version(4.0.0+)
	[2501] GetCompositorErrorInfo();
	@version(4.0.0+)
	[2601] GetDisplayErrorEvent();
	[4201] SetDisplayAlpha(f32, u64);
	[4203] SetDisplayLayerStack(u32, u64);
	[4205] SetDisplayPowerState(u32, u64);
	@version(4.0.0+)
	[4206] SetDefaultDisplay();
	[6000] AddToLayerStack(u32, u64);
	[6001] RemoveFromLayerStack(u32, u64);
	[6002] SetLayerVisibility(bool, u64);
	@version(5.0.0+)
	[6003] SetLayerConfig();
	@version(5.0.0+)
	[6004] AttachLayerPresentationTracer();
	@version(5.0.0+)
	[6005] DetachLayerPresentationTracer();
	@version(5.0.0+)
	[6006] StartLayerPresentationRecording();
	@version(5.0.0+)
	[6007] StopLayerPresentationRecording();
	@version(5.0.0+)
	[6008] StartLayerPresentationFenceWait();
	@version(5.0.0+)
	[6009] StopLayerPresentationFenceWait();
	@version(5.0.0+)
	[6010] GetLayerPresentationAllFencesExpiredEvent();
	[7000] SetContentVisibility(bool);
	[8000] SetConductorLayer(bool, u64);
	[8100] SetIndirectProducerFlipOffset(u64, u64, nn::TimeSpan);
	@version(4.0.0+)
	[8200] CreateSharedBufferStaticStorage();
	@version(4.0.0+)
	[8201] CreateSharedBufferTransferMemory();
	@version(4.0.0+)
	[8202] DestroySharedBuffer();
	@version(4.0.0+)
	[8203] BindSharedLowLevelLayerToManagedLayer();
	@version(4.0.0+)
	[8204] BindSharedLowLevelLayerToIndirectLayer();
	@version(4.0.0+)
	[8207] UnbindSharedLowLevelLayer();
	@version(4.0.0+)
	[8208] ConnectSharedLowLevelLayerToSharedBuffer();
	@version(4.0.0+)
	[8209] DisconnectSharedLowLevelLayerFromSharedBuffer();
	@version(4.0.0+)
	[8210] CreateSharedLayer();
	@version(4.0.0+)
	[8211] DestroySharedLayer();
	@version(4.0.0+)
	[8216] AttachSharedLayerToLowLevelLayer();
	@version(4.0.0+)
	[8217] ForceDetachSharedLayerFromLowLevelLayer();
	@version(4.0.0+)
	[8218] StartDetachSharedLayerFromLowLevelLayer();
	@version(4.0.0+)
	[8219] FinishDetachSharedLayerFromLowLevelLayer();
	@version(4.0.0+)
	[8220] GetSharedLayerDetachReadyEvent();
	@version(4.0.0+)
	[8221] GetSharedLowLevelLayerSynchronizedEvent();
	@version(4.0.0+)
	[8222] CheckSharedLowLevelLayerSynchronized();
	@version(4.0.0+)
	[8223] RegisterSharedBufferImporterAruid();
	@version(4.0.0+)
	[8224] UnregisterSharedBufferImporterAruid();
	@version(4.0.0+)
	[8227] CreateSharedBufferProcessHeap();
	@version(4.0.0+)
	[8228] GetSharedLayerLayerStacks();
	@version(4.0.0+)
	[8229] SetSharedLayerLayerStacks();
	@version(4.0.0+)
	[8291] PresentDetachedSharedFrameBufferToLowLevelLayer();
	@version(4.0.0+)
	[8292] FillDetachedSharedFrameBufferColor();
	@version(4.0.0+)
	[8293] GetDetachedSharedFrameBufferImage();
	@version(4.0.0+)
	[8294] SetDetachedSharedFrameBufferImage();
	@version(4.0.0+)
	[8295] CopyDetachedSharedFrameBufferImage();
	@version(4.0.0+)
	[8296] SetDetachedSharedFrameBufferSubImage();
	@version(4.0.0+)
	[8297] GetSharedFrameBufferContentParameter();
	@version(5.0.0+)
	[8298] ExpandStartupLogoOnSharedFrameBuffer();
}

interface nn::visrv::sf::IManagerRootService is vi:m {
	# Returns an [\#IApplicationDisplayService](#nn::visrv::sf::IApplicationDisplayService "wikilink"). Takes an input u32, user-processes use 0 or 1, with 0 for regular-applications normally. 0 = user-service(vi:u), 1 = non-user-service? Returns an error when using value 1 with vi:u(same error listed below for IApplicationDisplayService for unavailable commands).
	# 
	[2] GetDisplayService(u32) -> object<nn::visrv::sf::IApplicationDisplayService>;
	# Returns an [\#IApplicationDisplayService](#nn::visrv::sf::IApplicationDisplayService "wikilink").
	# 
	[3] GetDisplayServiceWithProxyNameExchange(nn::vi::ProxyName, u32) -> object<nn::visrv::sf::IApplicationDisplayService>;
}

interface nn::visrv::sf::ISystemDisplayService {
	[1200] GetZOrderCountMin(u64) -> i64;
	[1202] GetZOrderCountMax(u64) -> i64;
	[1203] GetDisplayLogicalResolution(u64) -> (i32, i32);
	[1204] SetDisplayMagnification(i32, i32, i32, i32, u64);
	[2201] SetLayerPosition(f32, f32, u64);
	[2203] SetLayerSize(u64, i64, i64);
	[2204] GetLayerZ(u64) -> i64;
	[2205] SetLayerZ(u64, i64);
	[2207] SetLayerVisibility(bool, u64);
	[2209] SetLayerAlpha(f32, u64);
	[2312] CreateStrayLayer(u32, u64) -> (u64, i64, buffer<unknown,6,0>);
	[2400] OpenIndirectLayer(u64, nn::applet::AppletResourceUserId, pid) -> (i64, buffer<unknown,6,0>);
	[2401] CloseIndirectLayer(u64);
	[2402] FlipIndirectLayer(u64);
	[3000] ListDisplayModes(u64) -> (i64, array<nn::vi::DisplayModeInfo,6>);
	[3001] ListDisplayRgbRanges(u64) -> (i64, array<u32,6>);
	[3002] ListDisplayContentTypes(u64) -> (i64, array<u32,6>);
	[3200] GetDisplayMode(u64) -> nn::vi::DisplayModeInfo;
	[3201] SetDisplayMode(u64, nn::vi::DisplayModeInfo);
	[3202] GetDisplayUnderscan(u64) -> i64;
	[3203] SetDisplayUnderscan(u64, i64);
	[3204] GetDisplayContentType(u64) -> u32;
	[3205] SetDisplayContentType(u32, u64);
	[3206] GetDisplayRgbRange(u64) -> u32;
	[3207] SetDisplayRgbRange(u32, u64);
	[3208] GetDisplayCmuMode(u64) -> u32;
	[3209] SetDisplayCmuMode(u32, u64);
	[3210] GetDisplayContrastRatio(u64) -> f32;
	[3211] SetDisplayContrastRatio(f32, u64);
	[3214] GetDisplayGamma(u64) -> f32;
	[3215] SetDisplayGamma(f32, u64);
	[3216] GetDisplayCmuLuma(u64) -> f32;
	[3217] SetDisplayCmuLuma(f32, u64);
	@version(4.0.0+)
	[8225] GetSharedBufferMemoryHandleId();
	@version(4.0.0+)
	[8250] OpenSharedLayer();
	@version(4.0.0+)
	[8251] CloseSharedLayer();
	@version(4.0.0+)
	[8252] ConnectSharedLayer();
	@version(4.0.0+)
	[8253] DisconnectSharedLayer();
	@version(4.0.0+)
	[8254] AcquireSharedFrameBuffer();
	@version(4.0.0+)
	[8255] PresentSharedFrameBuffer();
	@version(4.0.0+)
	[8256] GetSharedFrameBufferAcquirableEvent();
	@version(4.0.0+)
	[8257] FillSharedFrameBufferColor();
	@version(5.0.0+)
	[8258] CancelSharedFrameBuffer();
}

interface nn::visrv::sf::ISystemRootService is vi:s {
	# Returns an [\#IApplicationDisplayService](#nn::visrv::sf::IApplicationDisplayService "wikilink"). Takes an input u32, user-processes use 0 or 1, with 0 for regular-applications normally. 0 = user-service(vi:u), 1 = non-user-service? Returns an error when using value 1 with vi:u(same error listed below for IApplicationDisplayService for unavailable commands).
	# 
	[1] GetDisplayService(u32) -> object<nn::visrv::sf::IApplicationDisplayService>;
	# Returns an [\#IApplicationDisplayService](#nn::visrv::sf::IApplicationDisplayService "wikilink").
	# 
	[3] GetDisplayServiceWithProxyNameExchange(nn::vi::ProxyName, u32) -> object<nn::visrv::sf::IApplicationDisplayService>;
}

interface nn::wlan::detail::IInfraManager is wlan:inf {
	[0] Unknown0();
	[1] Unknown1();
	@undocumented
	[2] GetMacAddress();
	@undocumented
	[3] StartScan();
	[4] StopScan();
	@undocumented
	[5] Connect();
	[6] CancelConnect();
	[7] Disconnect();
	@undocumented
	[8] Unknown8();
	@undocumented
	[9] Unknown9();
	[10] GetState() -> u32;
	@undocumented
	[11] GetScanResult();
	[12] GetRssi() -> u32;
	[13] ChangeRxAntenna(u32);
	@undocumented
	[14] Unknown14();
	[15] Unknown15();
	[16] RequestWakeUp();
	@undocumented
	[17] RequestIfUpDown();
	@version(2.0.0+)
	[18] Unknown18() -> u32;
	@version(2.0.0+)
	@undocumented
	[19] Unknown19();
	@version(2.0.0+)
	[20] Unknown20();
	@version(2.0.0+)
	[21] Unknown21() -> u32;
	@version(2.0.0+)
	[22] Unknown22(u32);
	@version(2.0.0+)
	[23] Unknown23(u32);
	@version(2.0.0+)
	@undocumented
	[24] Unknown24();
	@version(2.0.0+)
	@undocumented
	[25] Unknown25();
	@version(4.0.0+)
	[26] Unknown26();
	@version(4.0.0+)
	[27] Unknown27();
}

interface nn::wlan::detail::ILocalGetActionFrame is wlan:lga {
	@undocumented
	[0] Unknown0();
}

interface nn::wlan::detail::ILocalGetFrame is wlan:lg {
	@undocumented
	[0] Unknown0();
}

interface nn::wlan::detail::ILocalManager is wlan:lcl {
	[0] Unknown0();
	[1] Unknown1();
	[2] Unknown2();
	[3] Unknown3();
	[4] Unknown4();
	[5] Unknown5();
	@undocumented
	[6] GetMacAddress();
	@undocumented
	[7] CreateBss();
	[8] DestroyBss();
	@undocumented
	[9] StartScan();
	[10] StopScan();
	@undocumented
	[11] Connect();
	[12] CancelConnect();
	@undocumented
	[13] Join();
	[14] CancelJoin();
	@undocumented
	[15] Disconnect();
	[16] SetBeaconLostCount(u32);
	@undocumented
	[17] Unknown17();
	@undocumented
	[18] Unknown18();
	@undocumented
	[19] Unknown19();
	[20] GetBssIndicationEvent() -> KObject;
	@undocumented
	[21] GetBssIndicationInfo();
	[22] GetState() -> u32;
	@undocumented
	[23] GetAllowedChannels();
	@undocumented
	[24] AddIe();
	[25] DeleteIe(u32);
	@undocumented
	[26] Unknown26();
	[27] Unknown27(u32);
	@undocumented
	[28] CreateRxEntry();
	[29] DeleteRxEntry(u32);
	@undocumented
	[30] Unknown30();
	@undocumented
	[31] Unknown31();
	@undocumented
	[32] AddMatchingDataToRxEntry();
	@undocumented
	[33] RemoveMatchingDataFromRxEntry();
	@undocumented
	[34] GetScanResult();
	@undocumented
	[35] Unknown35();
	@undocumented
	[36] SetActionFrameWithBeacon();
	[37] CancelActionFrameWithBeacon();
	@undocumented
	[38] CreateRxEntryForActionFrame();
	[39] DeleteRxEntryForActionFrame(u32);
	@undocumented
	[40] Unknown40();
	@undocumented
	[41] Unknown41();
	[42] CancelGetActionFrame(u32);
	[43] GetRssi() -> u32;
	[44] Unknown44(u32);
	@version(4.0.0+)
	[45] Unknown45();
	@version(4.0.0+)
	[46] Unknown46();
	@version(4.0.0+)
	[47] Unknown47();
	@version(4.0.0+)
	[48] Unknown48();
}

interface nn::wlan::detail::ISocketGetFrame is wlan:sg {
	@undocumented
	[0] Unknown0();
}

interface nn::wlan::detail::ISocketManager is wlan:soc {
	[0] Unknown0(buffer<unknown,5,0>);
	[1] Unknown1(u32);
	@undocumented
	[2] Unknown2();
	[3] Unknown3(u32);
	@undocumented
	[4] Unknown4();
	@undocumented
	[5] Unknown5();
	@undocumented
	[6] GetMacAddress();
	[7] SwitchTsfTimerFunction(u8);
	[8] Unknown8() -> u64;
	@undocumented
	[9] Unknown9();
	[10] Unknown10();
	[11] Unknown11();
}

interface nn::xcd::detail::ISystemServer is xcd:sys {
	[0] GetDataFormat(u64) -> u8;
	@undocumented
	[1] SetDataFormat();
	[2] GetMcuState(u64) -> u8;
	@undocumented
	[3] SetMcuState();
	@undocumented
	[4] GetMcuVersionForNfc();
	[5] CheckNfcDevicePower(u64);
	@undocumented
	[10] SetNfcEvent();
	@undocumented
	[11] GetNfcInfo();
	@undocumented
	[12] StartNfcDiscovery();
	[13] StopNfcDiscovery(u64);
	@undocumented
	[14] StartNtagRead();
	@undocumented
	[15] StartNtagWrite();
	@undocumented
	[16] SendNfcRawData();
	@undocumented
	[17] RegisterMifareKey();
	@undocumented
	[18] ClearMifareKey();
	@undocumented
	[19] StartMifareRead();
	@undocumented
	[20] StartMifareWrite();
	[101] GetAwakeTriggerReasonForLeftRail() -> u64;
	[102] GetAwakeTriggerReasonForRightRail() -> u64;
}

interface nns::hosbinder::IHOSBinderDriver is dispdrv {
	# Takes a s32 (**ID**), an u32 (**code**), a type-0x5 input buffer (**parcel\_data**), a type-0x6 output buffer (**parcel\_reply**) and an input u32 (**flags**). Each word is placed immediately after the previous word.
	# 
	# Analogous to onTransact from android.os.IServiceManager.
	# 
	[0] TransactParcel(i32, u32, u32, buffer<unknown,5,0>) -> buffer<unknown,6,0>;
	# Takes 3 input s32s: **ID**, **addval**, and **type**. Each word immediately follows the previous word. No additional output.
	# 
	# | Called by official function          | addval | type |
	# |--------------------------------------|--------|------|
	# | android::BpBinder::onFirstRef      | 1      | 1    |
	# | android::BpBinder::onLastStrongRef | -1     | 1    |
	# | ?                                    | 1      | 0    |
	# | ?                                    | -1     | 0    |
	# 
	# During init, {addval=1, type=0} is used then {addval=1, type=1} is used.
	# 
	[1] AdjustRefcount(i32, i32, i32);
	# Takes an input s32 (**ID**) and u32, with the latter immediately following the previous word. Returns an output event handle.
	# 
	[2] GetNativeHandle(i32, u32) -> KObject;
	# Takes a s32 (**ID**), an u32 (**code**), a type-0x21 input buffer (**parcel\_data**), a type-0x22 output buffer (**parcel\_reply**) and an input u32 (**flags**). Each word is placed immediately after the previous word.
	# 
	# [Category:Services](http://switchbrew.org/index.php?title=Category:Services "wikilink")
	# 
	@version(3.0.0+)
	[3] TransactParcelAuto(i32, u32, u32, buffer<unknown,33,0>) -> buffer<unknown,34,0>;
}

interface nns::nvdrv::INvDrvDebugFSServices is nvdrvdbg {
	# Takes process handle. Returns an fd.
	# 
	@undocumented
	[0] OpenLog();
	# Takes fd and closes it.
	# 
	@undocumented
	[1] CloseLog();
	# Takes fd and reads log into a type-6 buffer.
	# 
	@undocumented
	[2] ReadLog();
	@undocumented
	[3] Unknown3();
	@undocumented
	[4] Unknown4();
}

interface nns::nvdrv::INvDrvServices is nvdrv:s, nvdrv:t, nvdrv:a, nvdrv {
	# Takes a type-0x5 input buffer for the device-path. Returns the output 32bit **fd** and the u32 **error\_code**.
	# 
	@undocumented
	[0] Open();
	# Takes a 32bit **fd**, an u32 **ioctl\_cmd**, a type-0x21 input buffer, and a type-0x22 output buffer. Returns an output u32 (**error\_code**).
	# 
	# The addr/size for send/recv buffers are only set when the associated direction bit is set in the ioctl cmd (addr/size = 0 otherwise).
	# 
	@undocumented
	[1] Ioctl();
	# Takes a 32bit **fd**. Returns an output u32 (**error\_code**).
	# 
	@undocumented
	[2] Close();
	# Takes two copy-handles (**current\_process** and **transfer\_memory**) and an input u32 (**transfer\_memory\_size**). Returns an output u32 (**error\_code**).
	# 
	# Webkit applet creates the transfer-memory with perm = 0 and size 0x300000.
	# 
	@undocumented
	[3] Initialize();
	# Takes two input u32s (**fd** and **event\_id**), with the second word immediately after the first one. Returns an output u32 (**error\_code**) and a copy-handle (**event\_handle**).
	# 
	# QueryEvent is only supported on (and implemented differently on):
	# 
	# -   /dev/nvhost-gpu
	#     -   1: SmException\_BptIntReport
	#     -   2: SmException\_BptPauseReport
	#     -   3: ErrorNotifierEvent
	# -   /dev/nvhost-ctrl: Used to get events for SyncPts.
	#     -   If bit31-28 is 1, then lower 16-bits contain event\_slot, bit27-16 contain syncpt\_number.
	#     -   If bit31-28 is 0, then lower 4-bits contain event\_slot, bit31-4 contains syncpt\_number.
	# -   /dev/nvhost-ctrl-gpu
	#     -   1: Returns error\_event\_handle.
	#     -   2: Returns unknown event.
	# -   /dev/nvhost-dbg-gpu
	#     -   Ignores event\_id.
	# 
	@undocumented
	[4] QueryEvent();
	# Takes a copy-handle (**transfer\_memory**) and two input u32s (**fd** and **nvmap\_handle**). Returns an output u32 (**error\_code**).
	# 
	@undocumented
	[5] MapSharedMem();
	# Takes no input. Returns 0x10-bytes and an output u32 (**error\_code**).
	# 
	@undocumented
	[6] GetStatus();
	# Takes an input u64 which must [match](http://switchbrew.org/index.php?title=IPC_Marshalling "wikilink") the user-process PID ([AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink")). Returns an output u32 (**error\_code**).
	# 
	@undocumented
	[7] ForceSetClientPID();
	# Takes a PID-descriptor and an u64 which must [match](http://switchbrew.org/index.php?title=IPC_Marshalling "wikilink") the user-process PID ([AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink")). Returns an output u32 (**error\_code**).
	# 
	@undocumented
	[8] SetClientPID();
	# No input or output. Does nothing.
	# 
	@undocumented
	[9] DumpGraphicsMemoryInfo();
	# Takes a copy-handle and an input u32. Returns an output u32 (**error\_code**).
	# 
	@version(3.0.0+)
	@undocumented
	[10] InitializeDevtools();
	# Takes a type-0x21 buffer, a type-0x22 buffer, a type-0x21 buffer, and two input u32s. Returns an output u32 (**error\_code**).
	# 
	@version(3.0.0+)
	@undocumented
	[11] Ioctl2();
	# Same input/output as Ioctl2, except cmdhdr\_word1 is 0x100B instead of 0xC0B.
	# 
	@version(3.0.0+)
	@undocumented
	[12] Ioctl3();
	@version(3.0.0+)
	@undocumented
	[13] FinishInitialize();
}

interface nv::gemcontrol::INvGemControl is nvgem:c {
	@undocumented
	[0] Unknown0();
	@undocumented
	[1] Unknown1();
	@undocumented
	[2] Unknown2();
	@undocumented
	[3] Unknown3();
	@undocumented
	[4] Unknown4();
	@undocumented
	[5] Unknown5();
	@undocumented
	[6] Unknown6();
	@undocumented
	[7] Unknown7();
}

interface nv::gemcoredump::INvGemCoreDump is nvgem:cd {
	@undocumented
	[0] Unknown0();
	@undocumented
	[1] Unknown1();
	@undocumented
	[2] Unknown2();
}

